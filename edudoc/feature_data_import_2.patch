diff --git a/queries/Data manipulation/UpdateGroupEncounterStatus.sql b/queries/Data manipulation/UpdateGroupEncounterStatus.sql
new file mode 100644
index 000000000..0bd307ff9
--- /dev/null
+++ b/queries/Data manipulation/UpdateGroupEncounterStatus.sql	
@@ -0,0 +1,75 @@
+-- Update script for encounters incorrectly marked as group when they're individual sessions
+-- This script sets the encounter status to 31 and adds corresponding records in EncounterStudentStatuses
+
+-- First, let's create a temporary table with the encounter student IDs we need to update
+-- This query is based on GroupVsIndividualEncounterIssues_Query1.sql
+WITH EncountersToUpdate AS (
+    SELECT DISTINCT es.Id AS EncounterStudentId
+    FROM dbo.Encounters e
+    JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+    JOIN dbo.EncounterStudentCptCodes esc ON es.Id = esc.EncounterStudentId
+    JOIN dbo.CPTCodes c ON esc.CptCodeId = c.Id
+    JOIN dbo.Students s ON es.StudentId = s.Id
+    JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+    JOIN dbo.Providers p ON e.ProviderId = p.Id
+    JOIN dbo.Users u ON p.ProviderUserId = u.Id
+    JOIN dbo.EncounterStatuses est ON es.EncounterStatusId = est.Id
+    LEFT JOIN dbo.ProviderLicenses pl ON p.Id = pl.ProviderId
+    LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+    LEFT JOIN dbo.EncounterStudentStatuses ess ON es.Id = ess.EncounterStudentId
+    WHERE 
+        e.AdditionalStudents = 0
+        AND es.ESignedById IS NOT NULL
+        AND es.DateESigned IS NOT NULL
+        AND es.StudentDeviationReasonId IS NULL
+        AND c.Code IN ('90853', '92508', '96164', '97150')
+        AND (es.EncounterStatusId = 22 OR ess.EncounterStatusId = 22)
+        AND ce.PaidAmount IS NOT NULL
+        AND CAST(ce.PaidAmount AS DECIMAL(18,2)) > 0
+        AND EXISTS (
+            SELECT 1
+            FROM dbo.EncounterStudents es2
+            WHERE es2.EncounterId = e.Id
+            AND es2.StudentDeviationReasonId IS NULL
+            GROUP BY es2.EncounterId
+            HAVING COUNT(DISTINCT StudentId) = 1
+        )
+)
+
+-- Begin transaction for safety
+BEGIN TRANSACTION;
+
+-- Print the count of records we're going to update
+DECLARE @UpdateCount INT;
+SELECT @UpdateCount = COUNT(*) FROM EncountersToUpdate;
+PRINT 'Number of encounter students to update: ' + CAST(@UpdateCount AS VARCHAR);
+
+-- Update the EncounterStatusId to 31 in EncounterStudents table
+UPDATE es
+SET es.EncounterStatusId = 31
+FROM dbo.EncounterStudents es
+JOIN EncountersToUpdate etu ON es.Id = etu.EncounterStudentId;
+
+-- Insert records into EncounterStudentStatuses table
+INSERT INTO dbo.EncounterStudentStatuses (
+    EncounterStudentId,
+    EncounterStatusId,
+    CreatedById,
+    DateCreated
+)
+SELECT 
+    etu.EncounterStudentId,
+    31, -- Status ID 31
+    1,  -- Default CreatedById (replace with appropriate user ID if needed)
+    GETUTCDATE() -- Current date/time
+FROM EncountersToUpdate etu;
+
+-- Uncomment the following line to commit the transaction
+-- COMMIT TRANSACTION;
+
+-- Comment out the following line if you want to commit the transaction
+ROLLBACK TRANSACTION;
+
+-- Print a message to indicate that this is a test run by default
+PRINT 'This was a test run. The transaction was rolled back.';
+PRINT 'To actually perform the updates, uncomment the COMMIT line and comment out the ROLLBACK line.'; 
\ No newline at end of file
diff --git a/queries/Report requests/ActiveProvidersWithLicenses.sql b/queries/Report requests/ActiveProvidersWithLicenses.sql
new file mode 100644
index 000000000..39287ca21
--- /dev/null
+++ b/queries/Report requests/ActiveProvidersWithLicenses.sql	
@@ -0,0 +1,79 @@
+-- Provider Report Query with License Information
+WITH LatestLicense AS (
+    SELECT 
+        ProviderId,
+        License as LicenseNumber,
+        AsOfDate as LicenseAsOfDate,
+        ExpirationDate as LicenseExpirationDate,
+        ROW_NUMBER() OVER (PARTITION BY ProviderId ORDER BY AsOfDate DESC) as LicenseRank
+    FROM [dbo].[ProviderLicenses]
+),
+LatestAssignment AS (
+    SELECT 
+        Id as ProviderEscAssignmentId,
+        ProviderId,
+        EscId,
+        StartDate as AssignmentStartDate,
+        EndDate as AssignmentEndDate,
+        ROW_NUMBER() OVER (PARTITION BY ProviderId ORDER BY StartDate DESC) as AssignmentRank
+    FROM [dbo].[ProviderEscAssignments]
+    WHERE Archived = 0
+),
+ProviderSchoolDistricts AS (
+    SELECT 
+        pea.ProviderId,
+        CASE 
+            WHEN COUNT(DISTINCT sd.Name) > 1 THEN 'Multiple'
+            ELSE MAX(sd.Name)
+        END as SchoolDistrictName
+    FROM [dbo].[ProviderEscAssignments] pea
+    INNER JOIN [dbo].[ProviderEscSchoolDistricts] pesd ON pea.Id = pesd.ProviderEscAssignmentId
+    INNER JOIN [dbo].[SchoolDistricts] sd ON pesd.SchoolDistrictId = sd.Id
+    WHERE pea.Archived = 0
+    GROUP BY pea.ProviderId
+),
+ProviderInfo AS (
+    SELECT 
+        p.Id as ProviderId,
+        u.FirstName,
+        u.LastName,
+        u.Email,
+        pt.Name as Title,
+        pet.Name as EmploymentType,
+        p.NPI,
+        CASE WHEN la.EscId IS NOT NULL THEN e.Name ELSE NULL END as ESCName,
+        psd.SchoolDistrictName,
+        la.AssignmentStartDate,
+        la.AssignmentEndDate,
+        ll.LicenseNumber,
+        ll.LicenseAsOfDate,
+        ll.LicenseExpirationDate
+    FROM [dbo].[Providers] p
+    INNER JOIN [dbo].[Users] u ON p.ProviderUserId = u.Id
+    INNER JOIN [dbo].[ProviderTitles] pt ON p.TitleId = pt.Id
+    INNER JOIN [dbo].[ProviderEmploymentTypes] pet ON p.ProviderEmploymentTypeId = pet.Id
+    LEFT JOIN LatestAssignment la ON p.Id = la.ProviderId AND la.AssignmentRank = 1
+    LEFT JOIN [dbo].[Escs] e ON la.EscId = e.Id
+    LEFT JOIN ProviderSchoolDistricts psd ON p.Id = psd.ProviderId
+    LEFT JOIN LatestLicense ll ON p.Id = ll.ProviderId AND ll.LicenseRank = 1
+    WHERE 
+        p.Archived = 0
+        AND p.TitleId NOT IN (7, 27, 42)  -- Excluding School Psychologist titles
+        AND la.AssignmentStartDate <= GETUTCDATE()
+        AND (la.AssignmentEndDate IS NULL OR la.AssignmentEndDate > GETUTCDATE())
+)
+SELECT DISTINCT
+    LastName,
+    FirstName,
+    Title,
+    NPI,
+    EmploymentType,
+    ESCName,
+    SchoolDistrictName,
+    LicenseNumber,
+    FORMAT(LicenseAsOfDate, 'MM/dd/yyyy') as LicenseAsOfDate,
+    FORMAT(LicenseExpirationDate, 'MM/dd/yyyy') as LicenseExpirationDate
+FROM ProviderInfo
+ORDER BY 
+    LastName,
+    FirstName; 
\ No newline at end of file
diff --git a/queries/Report requests/ActivePsychologists.sql b/queries/Report requests/ActivePsychologists.sql
new file mode 100644
index 000000000..0419c0b60
--- /dev/null
+++ b/queries/Report requests/ActivePsychologists.sql	
@@ -0,0 +1,67 @@
+-- Provider Report Query
+WITH LatestAssignment AS (
+    SELECT 
+        Id as ProviderEscAssignmentId,
+        ProviderId,
+        EscId,
+        StartDate as AssignmentStartDate,
+        EndDate as AssignmentEndDate,
+        ROW_NUMBER() OVER (PARTITION BY ProviderId ORDER BY StartDate DESC) as AssignmentRank
+    FROM [dbo].[ProviderEscAssignments]
+    WHERE Archived = 0
+),
+ProviderSchoolDistricts AS (
+    SELECT 
+        pea.ProviderId,
+        CASE 
+            WHEN COUNT(DISTINCT sd.Name) > 1 THEN 'Multiple'
+            ELSE MAX(sd.Name)
+        END as SchoolDistrictName
+    FROM [dbo].[ProviderEscAssignments] pea
+    INNER JOIN [dbo].[ProviderEscSchoolDistricts] pesd ON pea.Id = pesd.ProviderEscAssignmentId
+    INNER JOIN [dbo].[SchoolDistricts] sd ON pesd.SchoolDistrictId = sd.Id
+    WHERE pea.Archived = 0
+    GROUP BY pea.ProviderId
+),
+ProviderInfo AS (
+    SELECT 
+        p.Id as ProviderId,
+        u.FirstName,
+        u.LastName,
+        u.Email,
+        pt.Name as Title,
+        pet.Name as EmploymentType,
+        poc.CertificationNumber as ODECertification,
+        CASE WHEN la.EscId IS NOT NULL THEN e.Name ELSE NULL END as ESCName,
+        psd.SchoolDistrictName,
+        la.AssignmentStartDate,
+        la.AssignmentEndDate
+    FROM [dbo].[Providers] p
+    INNER JOIN [dbo].[Users] u ON p.ProviderUserId = u.Id
+    INNER JOIN [dbo].[ProviderTitles] pt ON p.TitleId = pt.Id
+    INNER JOIN [dbo].[ProviderEmploymentTypes] pet ON p.ProviderEmploymentTypeId = pet.Id
+    LEFT JOIN [dbo].[ProviderODECertifications] poc ON p.Id = poc.ProviderId
+    LEFT JOIN LatestAssignment la ON p.Id = la.ProviderId AND la.AssignmentRank = 1
+    LEFT JOIN [dbo].[Escs] e ON la.EscId = e.Id
+    LEFT JOIN ProviderSchoolDistricts psd ON p.Id = psd.ProviderId
+    WHERE 
+        p.Archived = 0
+        AND p.TitleId IN (7, 27, 42)  -- School Psychologist, Licensed Psychologist, Professional Pupil Service License Holder - School Psychologist
+        AND la.AssignmentStartDate <= GETUTCDATE()
+        AND (la.AssignmentEndDate IS NULL OR la.AssignmentEndDate > GETUTCDATE())
+)
+SELECT DISTINCT
+    LastName,
+    FirstName,
+    Title,
+    ODECertification,
+    EmploymentType,
+    Email,
+    ESCName,
+    SchoolDistrictName,
+    FORMAT(AssignmentStartDate, 'MM/dd/yyyy') as AssignmentStartDate,
+    FORMAT(AssignmentEndDate, 'MM/dd/yyyy') as AssignmentEndDate
+FROM ProviderInfo
+ORDER BY 
+    LastName,
+    FirstName;
\ No newline at end of file
diff --git a/queries/Report requests/ClaimsWithStateClaimNoNotInvoiced.sql b/queries/Report requests/ClaimsWithStateClaimNoNotInvoiced.sql
new file mode 100644
index 000000000..3106bd142
--- /dev/null
+++ b/queries/Report requests/ClaimsWithStateClaimNoNotInvoiced.sql	
@@ -0,0 +1,54 @@
+SELECT DISTINCT
+    CAST(d.Id AS VARCHAR(50)) AS 'District ID',
+    d.Name AS 'District Name',
+    CAST(s.Id AS VARCHAR(50)) AS 'Student ID',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CAST(s.StudentCode AS VARCHAR(50)) AS 'Student Code',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    s.MedicaidNo AS 'Medicaid No',
+    ce.ReferenceNumber AS 'EDI Claim No',
+    ce.ProcedureIdentifier AS 'CPT Code',
+    CONVERT(VARCHAR, es.EncounterDate, 110) AS 'Session Date',
+    ce.BillingUnits AS 'Service Units',
+    COALESCE(sc.Name, 'Treatment') AS 'Service Desc',
+    st.Name AS 'Service Type Desc',
+    ce.BillingUnits AS 'Units Paid',
+    ce.PaidAmount AS 'Paid Amount',
+    CONVERT(VARCHAR, ce.VoucherDate, 110) AS 'Voucher Date',
+    es.EncounterNumber AS 'Encounter No',
+    ce.ClaimId AS 'State Claim No',
+    CAST(p.Id AS VARCHAR(50)) AS 'Provider ID',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    pl.License AS 'License No',
+    p.NPI AS 'NPI Number',
+    estat.Id AS 'Status ID',
+    estat.Name AS 'Status Name'
+FROM dbo.EncounterStudents es
+JOIN dbo.EncounterStatuses estat ON es.EncounterStatusId = estat.Id
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Encounters e ON es.EncounterId = e.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN ProviderTitles pt ON p.TitleId = pt.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+LEFT JOIN dbo.ProviderLicenses pl ON p.Id = pl.ProviderId
+LEFT JOIN dbo.ServiceCodes sc ON pt.ServiceCodeId = sc.Id
+LEFT JOIN dbo.ServiceTypes st ON e.ServiceTypeId = st.Id
+WHERE 
+    es.EncounterDate BETWEEN '2023-07-01' AND '2024-06-30'
+    AND ce.ClaimId IS NOT NULL
+    AND es.EncounterStatusId NOT IN (22, 23)  -- Not in expected statuses
+    AND es.Archived = 0  -- Filter out archived encounter students
+    AND e.Archived = 0   -- Filter out archived encounters
+    AND s.Archived = 0   -- Filter out archived students
+    AND p.Archived = 0   -- Filter out archived providers
+    AND d.Archived = 0   -- Filter out archived districts (if this column exists)
+ORDER BY 
+    estat.Name,
+    [District Name],
+    [Student Last Name],
+    [Student First Name],
+    [Session Date];
\ No newline at end of file
diff --git a/queries/Report requests/EncounterCountsPerProvider.sql b/queries/Report requests/EncounterCountsPerProvider.sql
new file mode 100644
index 000000000..e74ee9291
--- /dev/null
+++ b/queries/Report requests/EncounterCountsPerProvider.sql	
@@ -0,0 +1,35 @@
+SELECT 
+    sd.Name AS 'District',
+    u.LastName AS 'Provider Last Name',
+    u.FirstName AS 'Provider First Name',
+    p.Id AS 'Provider ID',
+    sc.Name AS 'Service Area',  -- Using ServiceCode.Name as the service area
+    pet.Name AS 'Employment Type',
+    CASE WHEN p.Archived = 1 THEN 'Yes' ELSE 'No' END AS 'Provider Archived',
+    COUNT(DISTINCT es.Id) AS 'Number of Encounters'
+FROM dbo.Providers p
+INNER JOIN dbo.Users u ON p.ProviderUserId = u.Id
+INNER JOIN dbo.ProviderTitles pt ON p.TitleId = pt.Id
+INNER JOIN dbo.ServiceCodes sc ON pt.ServiceCodeId = sc.Id  -- Join to ServiceCodes
+INNER JOIN dbo.ProviderEmploymentTypes pet ON p.ProviderEmploymentTypeId = pet.Id  -- Join to ProviderEmploymentTypes
+INNER JOIN dbo.Encounters e ON p.Id = e.ProviderId
+INNER JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+INNER JOIN dbo.Students s ON es.StudentId = s.Id
+INNER JOIN dbo.SchoolDistricts sd ON s.DistrictId = sd.Id
+WHERE 
+    e.EncounterDate BETWEEN '2023-07-01' AND '2024-06-30'
+    AND e.Archived = 0
+    AND es.Archived = 0
+GROUP BY
+    sd.Name,
+    u.LastName,
+    u.FirstName,
+    p.Id,
+    sc.Name,
+    pet.Name,
+    p.Archived
+ORDER BY 
+    sd.Name,
+    u.LastName,
+    u.FirstName,
+    sc.Name;
\ No newline at end of file
diff --git a/queries/Report requests/EncounterDSTIssues.sql b/queries/Report requests/EncounterDSTIssues.sql
new file mode 100644
index 000000000..8e46267d5
--- /dev/null
+++ b/queries/Report requests/EncounterDSTIssues.sql	
@@ -0,0 +1,49 @@
+-- Query to find encounters with time mismatches between Encounter and EncounterStudent
+-- This helps identify potential DST-related issues where times are exactly one hour apart
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    es.EncounterNumber AS 'Encounter No',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    p.NPI AS 'NPI Number',
+    CASE WHEN e.IsGroup = 1 THEN 'true' ELSE 'false' END AS 'Is Group',
+    e.AdditionalStudents AS 'Additional Students',
+    (SELECT COUNT(DISTINCT es2.StudentId) 
+     FROM dbo.EncounterStudents es2 
+     WHERE es2.EncounterId = e.Id 
+     AND es2.StudentDeviationReasonId IS NULL) AS 'Unique Students',
+    e.EncounterDate AS 'Encounter Date',
+    e.EncounterStartTime AS 'Encounter Start Time',
+    e.EncounterEndTime AS 'Encounter End Time',
+    es.EncounterStartTime AS 'Student Start Time',
+    es.EncounterEndTime AS 'Student End Time',
+    DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) AS 'Start Time Diff (minutes)',
+    DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) AS 'End Time Diff (minutes)',
+    ce.ClaimId AS 'Claim ID'
+FROM dbo.Encounters e
+JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+WHERE 
+    e.Archived = 0
+    AND es.Archived = 0
+    AND s.Archived = 0
+    AND (
+        -- Check for exactly one hour difference in either direction
+        (DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) = 60 
+         AND DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) = 60)
+        OR
+        (DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) = -60 
+         AND DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) = -60)
+    )
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName,
+    e.EncounterDate; 
\ No newline at end of file
diff --git a/queries/Report requests/EncountersForStudentsWithNullConsentDate.sql b/queries/Report requests/EncountersForStudentsWithNullConsentDate.sql
new file mode 100644
index 000000000..377b6e515
--- /dev/null
+++ b/queries/Report requests/EncountersForStudentsWithNullConsentDate.sql	
@@ -0,0 +1,64 @@
+SELECT
+	d.Name AS 'District Name',
+	s.FirstName,
+	s.LastName,
+	s.MedicaidNo,
+	spc.ParentalConsentEffectiveDate,
+	spct.Name AS 'Parental Consent Type'
+FROM Students s
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN StudentParentalConsents spc ON s.Id = spc.StudentId
+JOIN StudentParentalConsentTypes spct on spc.ParentalConsentTypeId = spct.Id
+WHERE spc.ParentalConsentEffectiveDate IS NULL
+ORDER BY d.Name;
+
+SELECT DISTINCT
+    CAST(d.Id AS VARCHAR(50)) AS 'District ID',
+    d.Name AS 'District Name',
+    CAST(s.Id AS VARCHAR(50)) AS 'Student ID',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CAST(s.StudentCode AS VARCHAR(50)) AS 'Student Code',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    s.MedicaidNo AS 'Medicaid No',
+	spc.ParentalConsentEffectiveDate,
+	spct.Name AS 'Parental Consent Type',
+    ce.ReferenceNumber AS 'EDI Claim No',
+    ce.ProcedureIdentifier AS 'CPT Code',
+    CONVERT(VARCHAR, es.EncounterDate, 110) AS 'Session Date',
+    ce.BillingUnits AS 'Service Units',
+	COALESCE(sc.Name, 'Treatment') AS 'Service Desc',
+    st.Name AS 'Service Type Desc',
+    ce.BillingUnits AS 'Units Paid',
+    ce.PaidAmount AS 'Paid Amount',
+    CONVERT(VARCHAR, ce.VoucherDate, 110) AS 'Voucher Date',
+    es.EncounterNumber AS 'Encounter No',
+    ce.ClaimId AS 'State Claim No',
+    CAST(p.Id AS VARCHAR(50)) AS 'Provider ID',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    pl.License AS 'License No',
+    p.NPI AS 'NPI Number',
+	estat.Name AS 'Encounter Status'
+FROM dbo.EncounterStudents es
+JOIN dbo.EncounterStatuses estat ON es.EncounterStatusId = estat.Id
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Encounters e ON es.EncounterId = e.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN ProviderTitles pt ON p.TitleId = pt.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+JOIN StudentParentalConsents spc ON s.Id = spc.StudentId
+JOIN StudentParentalConsentTypes spct ON spc.ParentalConsentTypeId = spct.Id
+LEFT JOIN dbo.ProviderLicenses pl ON p.Id = pl.ProviderId
+LEFT JOIN dbo.ServiceCodes sc ON pt.ServiceCodeId = sc.Id
+LEFT JOIN dbo.ServiceTypes st ON e.ServiceTypeId = st.Id
+WHERE 
+    es.EncounterDate BETWEEN '2024-01-01' AND '2025-02-25'
+    AND spc.ParentalConsentEffectiveDate IS NULL
+ORDER BY 
+    [District Name],
+    [Student Last Name],
+    [Student First Name],
+    [Session Date];
\ No newline at end of file
diff --git a/queries/Report requests/GroupCPTCodesWithOnlyOneStudent.sql b/queries/Report requests/GroupCPTCodesWithOnlyOneStudent.sql
new file mode 100644
index 000000000..4dd71c62a
--- /dev/null
+++ b/queries/Report requests/GroupCPTCodesWithOnlyOneStudent.sql	
@@ -0,0 +1,56 @@
+-- Query 1: Find encounters incorrectly marked as group when they're individual sessions
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    c.Code AS 'CPT Code',
+    c.Description AS 'CPT Description',
+    es.EncounterNumber AS 'Encounter No',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    e.AdditionalStudents AS 'Additional Students',
+    (SELECT COUNT(DISTINCT es2.StudentId) 
+     FROM dbo.EncounterStudents es2 
+     WHERE es2.EncounterId = e.Id 
+     AND es2.StudentDeviationReasonId IS NULL
+     AND es2.DateESigned IS NOT NULL) AS 'Unique Students',
+    es.EncounterDate AS 'Session Date',
+    est.Name AS 'Encounter Status',
+    ce.ClaimId AS 'Claim ID',
+    ce.PaidAmount AS 'Paid Amount'
+FROM dbo.Encounters e
+JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+JOIN dbo.EncounterStudentCptCodes esc ON es.Id = esc.EncounterStudentId
+JOIN dbo.CPTCodes c ON esc.CptCodeId = c.Id
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+JOIN dbo.EncounterStatuses est ON es.EncounterStatusId = est.Id
+LEFT JOIN dbo.ProviderLicenses pl ON p.Id = pl.ProviderId
+LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+LEFT JOIN dbo.EncounterStudentStatuses ess ON es.Id = ess.EncounterStudentId
+WHERE 
+    e.AdditionalStudents = 0
+    AND es.ESignedById IS NOT NULL
+    AND es.DateESigned IS NOT NULL
+    AND es.StudentDeviationReasonId IS NULL
+    AND c.Code IN ('90853', '92508', '96164', '97150')
+    AND ce.PaidAmount IS NOT NULL
+    AND ce.PaidAmount <> '0'
+    AND d.Id != 125
+    AND EXISTS (
+        SELECT 1
+        FROM dbo.EncounterStudents es2
+        WHERE es2.EncounterId = e.Id
+        AND es2.StudentDeviationReasonId IS NULL
+        AND es2.DateESigned IS NOT NULL
+        GROUP BY es2.EncounterId
+        HAVING COUNT(DISTINCT StudentId) = 1
+    )
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName,
+    es.EncounterDate;
\ No newline at end of file
diff --git a/queries/Report requests/IndividualCPTCodesWithMultipleStudents.sql b/queries/Report requests/IndividualCPTCodesWithMultipleStudents.sql
new file mode 100644
index 000000000..e181aa830
--- /dev/null
+++ b/queries/Report requests/IndividualCPTCodesWithMultipleStudents.sql	
@@ -0,0 +1,58 @@
+-- Query 2: Find encounters incorrectly marked as individual when they're group sessions
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    c.Code AS 'CPT Code',
+    c.Description AS 'CPT Description',
+    es.EncounterNumber AS 'Encounter No',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    e.AdditionalStudents AS 'Additional Students',
+    (SELECT COUNT(DISTINCT es2.StudentId) 
+     FROM dbo.EncounterStudents es2 
+     WHERE es2.EncounterId = e.Id 
+     AND es2.StudentDeviationReasonId IS NULL
+     AND es2.DateESigned IS NOT NULL) AS 'Unique Students',
+    es.EncounterDate AS 'Session Date',
+    est.Name AS 'Encounter Status',
+    ce.ClaimId AS 'Claim ID',
+    ce.PaidAmount AS 'Paid Amount'
+FROM dbo.Encounters e
+JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+JOIN dbo.EncounterStudentCptCodes esc ON es.Id = esc.EncounterStudentId
+JOIN dbo.CPTCodes c ON esc.CptCodeId = c.Id
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+JOIN dbo.EncounterStatuses est ON es.EncounterStatusId = est.Id
+LEFT JOIN dbo.ProviderLicenses pl ON p.Id = pl.ProviderId
+LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+LEFT JOIN dbo.EncounterStudentStatuses ess ON es.Id = ess.EncounterStudentId
+WHERE 
+    (
+        e.AdditionalStudents > 0
+        OR EXISTS (
+            SELECT 1
+            FROM dbo.EncounterStudents es2
+            WHERE es2.EncounterId = e.Id
+            AND es2.StudentDeviationReasonId IS NULL
+            AND es2.DateESigned IS NOT NULL
+            GROUP BY es2.EncounterId
+            HAVING COUNT(DISTINCT StudentId) > 1
+        )
+    )
+    AND es.ESignedById IS NOT NULL
+    AND es.DateESigned IS NOT NULL
+    AND es.StudentDeviationReasonId IS NULL
+    AND c.Code NOT IN ('90853', '92508', '96164', '97150')
+    AND ce.PaidAmount IS NOT NULL
+    AND ce.PaidAmount <> '0'
+    AND d.Id != 125
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName,
+    es.EncounterDate; 
\ No newline at end of file
diff --git a/queries/Report requests/MonthlyEncountersByTypeByProviderByESC.sql b/queries/Report requests/MonthlyEncountersByTypeByProviderByESC.sql
new file mode 100644
index 000000000..2aa2f4630
--- /dev/null
+++ b/queries/Report requests/MonthlyEncountersByTypeByProviderByESC.sql	
@@ -0,0 +1,140 @@
+WITH DateRange AS (
+    SELECT CAST('2024-07-01' AS DATE) AS MonthStart
+    UNION ALL
+    SELECT DATEADD(MONTH, 1, MonthStart)
+    FROM DateRange
+    WHERE DATEADD(MONTH, 1, MonthStart) <= CAST(GETDATE() AS DATE)
+),
+MonthsTable AS (
+    SELECT FORMAT(MonthStart, 'yyyy-MM') AS MonthFormat, MonthStart
+    FROM DateRange
+),
+ProviderAssignments AS (
+    SELECT 
+        esc.Id AS EscId,
+        esc.Name AS EscName,
+        p.Id AS ProviderId,
+        u.LastName AS ProviderLast,
+        u.FirstName AS ProviderFirst,
+        pt.Name AS ProviderTitle,
+        d.Id AS DistrictId,
+        d.Name AS DistrictName,
+        st.Id AS ServiceTypeId,
+        st.Name AS ServiceTypeName
+    FROM 
+        Escs esc
+    INNER JOIN ProviderEscAssignments pea ON pea.EscId = esc.Id
+    INNER JOIN ProviderEscSchoolDistricts pesd ON pesd.ProviderEscAssignmentId = pea.Id
+    INNER JOIN SchoolDistricts d ON d.Id = pesd.SchoolDistrictId
+    INNER JOIN Providers p ON p.Id = pea.ProviderId
+    INNER JOIN ProviderTitles pt ON p.TitleId = pt.Id
+    INNER JOIN Users u ON u.Id = p.ProviderUserId
+    CROSS JOIN ServiceTypes st
+    WHERE 
+        esc.Name IN (
+            'Ashtabula County ESC',
+            'ESC of Eastern Ohio',
+            'ESC of the Western Reserve',
+            'Greene ESC',
+            'North Point ESC',
+            'Northwest Ohio ESC'
+        )
+        AND p.Archived = 0
+        AND (
+            (pea.StartDate IS NULL OR pea.StartDate <= GETDATE())
+            AND (pea.EndDate IS NULL OR pea.EndDate >= '2024-07-01')
+        )
+),
+DistrictResults AS (
+    -- First query with district breakdown
+    SELECT
+        pa.EscName AS 'ESC Name',
+        pa.ProviderLast AS 'Provider Last',
+        pa.ProviderFirst AS 'Provider First',
+        pa.ProviderTitle AS 'Provider Title',
+        pa.DistrictName AS 'School District',
+        pa.ServiceTypeName AS 'Service Type',
+        m.MonthFormat AS 'Month',
+        COUNT(DISTINCT es.Id) AS 'Count'
+    FROM
+        ProviderAssignments pa
+    CROSS JOIN
+        MonthsTable m
+    LEFT JOIN Encounters e ON 
+        e.ProviderId = pa.ProviderId 
+        AND e.ServiceTypeId = pa.ServiceTypeId
+        AND e.Archived = 0
+        AND FORMAT(e.EncounterDate, 'yyyy-MM') = m.MonthFormat
+    LEFT JOIN EncounterStudents es ON 
+        es.EncounterId = e.Id 
+        AND es.Archived = 0
+        AND es.EncounterStatusId NOT IN (12, 13, 14, 15, 26, 8)
+    LEFT JOIN Students s ON 
+        s.Id = es.StudentId 
+        AND s.DistrictId = pa.DistrictId
+        AND s.Archived = 0
+    GROUP BY
+        pa.EscName,
+        pa.ProviderLast,
+        pa.ProviderFirst,
+        pa.ProviderTitle,
+        pa.DistrictName,
+        pa.ServiceTypeName,
+        m.MonthFormat
+),
+ServiceResults AS (
+    -- Second query without district breakdown
+    SELECT
+        pa.EscName AS 'ESC Name',
+        pa.ProviderLast AS 'Provider Last',
+        pa.ProviderFirst AS 'Provider First',
+        pa.ProviderTitle AS 'Provider Title',
+        pa.ServiceTypeName AS 'Service Type',
+        m.MonthFormat AS 'Month',
+        COUNT(DISTINCT es.Id) AS 'Count'
+    FROM
+        ProviderAssignments pa
+    CROSS JOIN
+        MonthsTable m
+    LEFT JOIN Encounters e ON 
+        e.ProviderId = pa.ProviderId 
+        AND e.ServiceTypeId = pa.ServiceTypeId
+        AND e.Archived = 0
+        AND FORMAT(e.EncounterDate, 'yyyy-MM') = m.MonthFormat
+    LEFT JOIN EncounterStudents es ON 
+        es.EncounterId = e.Id 
+        AND es.Archived = 0
+        AND es.EncounterStatusId NOT IN (12, 13, 14, 15, 26, 8)
+    LEFT JOIN Students s ON 
+        s.Id = es.StudentId 
+        AND s.DistrictId = pa.DistrictId
+        AND s.Archived = 0
+    GROUP BY
+        pa.EscName,
+        pa.ProviderLast,
+        pa.ProviderFirst,
+        pa.ProviderTitle,
+        pa.ServiceTypeName,
+        m.MonthFormat
+)
+
+-- Comment/uncomment to toggle between district and service results
+
+-- Output district results
+-- SELECT * FROM DistrictResults
+-- ORDER BY
+--     [ESC Name],
+--     [Provider Last],
+--     [Provider First],
+--     [School District],
+--     [Service Type],
+--     [Month];
+
+-- -- Output service results
+SELECT * FROM ServiceResults
+ORDER BY
+    [ESC Name],
+    [Provider Last],
+    [Provider First],
+    [Service Type],
+    [Month];
\ No newline at end of file
diff --git a/queries/Report requests/PaidClaims2024.sql b/queries/Report requests/PaidClaims2024.sql
new file mode 100644
index 000000000..b1e4f15f2
--- /dev/null
+++ b/queries/Report requests/PaidClaims2024.sql	
@@ -0,0 +1,64 @@
+SELECT DISTINCT
+    CAST(d.Id AS VARCHAR(50)) AS 'District ID',
+    d.Name AS 'District Name',
+    CAST(s.Id AS VARCHAR(50)) AS 'Student ID',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CAST(s.StudentCode AS VARCHAR(50)) AS 'Student Code',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    s.MedicaidNo AS 'Medicaid No',
+    ce.ReferenceNumber AS 'EDI Claim No',
+    ce.ProcedureIdentifier AS 'CPT Code',
+    CONVERT(VARCHAR, es.EncounterDate, 110) AS 'Session Date',
+    ce.BillingUnits AS 'Service Units',
+	COALESCE(sc.Name, 'Treatment') AS 'Service Desc',
+    st.Name AS 'Service Type Desc',
+    ce.BillingUnits AS 'Units Paid',
+    ce.PaidAmount AS 'Paid Amount',
+    CONVERT(VARCHAR, ce.VoucherDate, 110) AS 'Voucher Date',
+    es.EncounterNumber AS 'Encounter No',
+    ce.ClaimId AS 'State Claim No',
+    CAST(p.Id AS VARCHAR(50)) AS 'Provider ID',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    pl.License AS 'License No',
+    p.NPI AS 'NPI Number'
+FROM dbo.EncounterStudents es
+JOIN dbo.EncounterStatuses estat ON es.EncounterStatusId = estat.Id
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Encounters e ON es.EncounterId = e.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN ProviderTitles pt ON p.TitleId = pt.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+LEFT JOIN (
+    -- Subquery to select one license per provider with preference for non-"cond" licenses
+    SELECT 
+        pl.ProviderId,
+        pl.License
+    FROM dbo.ProviderLicenses pl
+    WHERE pl.Id IN (
+        -- For each provider, select the license ID based on priority
+        SELECT TOP 1 pl2.Id
+        FROM dbo.ProviderLicenses pl2
+        WHERE pl2.ProviderId = pl.ProviderId
+        ORDER BY 
+            -- Prioritize licenses that don't start with "cond"
+            CASE WHEN pl2.License NOT LIKE 'cond%' THEN 0 ELSE 1 END,
+            -- Then by expiration date (most recent first)
+            pl2.ExpirationDate DESC
+    )
+) pl ON p.Id = pl.ProviderId
+LEFT JOIN dbo.ServiceCodes sc ON pt.ServiceCodeId = sc.Id
+LEFT JOIN dbo.ServiceTypes st ON e.ServiceTypeId = st.Id
+WHERE 
+    es.EncounterDate BETWEEN '2023-07-01' AND '2024-06-30'
+    AND es.EncounterStatusId = 22
+    AND ce.ClaimId IS NOT NULL
+    AND ce.PaidAmount <> '0'
+ORDER BY 
+    [District Name],
+    [Student Last Name],
+    [Student First Name],
+    [Session Date];
\ No newline at end of file
diff --git a/queries/Report requests/StudentsWithNullNursingDiagnosisCodes.sql b/queries/Report requests/StudentsWithNullNursingDiagnosisCodes.sql
new file mode 100644
index 000000000..4d5df60fb
--- /dev/null
+++ b/queries/Report requests/StudentsWithNullNursingDiagnosisCodes.sql	
@@ -0,0 +1,52 @@
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    es.EncounterDate AS 'Most Recent Encounter Date',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+	u.Email AS 'Provider Email',
+    pt.Name AS 'Provider Title',
+    (
+        SELECT COUNT(*)
+        FROM dbo.CaseLoads cl
+        JOIN dbo.CaseLoadScripts cs ON cl.Id = cs.CaseLoadId
+        WHERE cl.StudentId = s.Id
+        AND cs.DiagnosisCodeId IS NULL
+        AND cs.Archived = 0
+        AND cl.Archived = 0
+    ) AS 'Null Diagnosis Script Count'
+FROM dbo.Students s
+INNER JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+INNER JOIN dbo.EncounterStudents es ON s.Id = es.StudentId
+INNER JOIN dbo.Encounters e ON es.EncounterId = e.Id
+INNER JOIN dbo.Providers p ON e.ProviderId = p.Id
+INNER JOIN dbo.Users u ON p.ProviderUserId = u.Id
+INNER JOIN dbo.ProviderTitles pt ON p.TitleId = pt.Id
+WHERE 
+    EXISTS (
+        SELECT 1
+        FROM dbo.CaseLoads cl
+        JOIN dbo.CaseLoadScripts cs ON cl.Id = cs.CaseLoadId
+        WHERE cl.StudentId = s.Id
+        AND cs.DiagnosisCodeId IS NULL
+        AND cs.Archived = 0
+        AND cl.Archived = 0
+    )
+    AND s.Archived = 0
+    AND es.Archived = 0
+    AND pt.ServiceCodeId = 5  -- Nursing service code
+    AND es.EncounterDate = (
+        SELECT MAX(es2.EncounterDate)
+        FROM dbo.EncounterStudents es2
+        JOIN dbo.Encounters e2 ON es2.EncounterId = e2.Id
+        JOIN dbo.Providers p2 ON e2.ProviderId = p2.Id
+        JOIN dbo.ProviderTitles pt2 ON p2.TitleId = pt2.Id
+        WHERE es2.StudentId = s.Id
+        AND es2.Archived = 0
+        AND pt2.ServiceCodeId = 5
+    )
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName;
diff --git a/queries/Report requests/TotalMinutesOfStudentEncountersByProvider.sql b/queries/Report requests/TotalMinutesOfStudentEncountersByProvider.sql
new file mode 100644
index 000000000..f6b9de26d
--- /dev/null
+++ b/queries/Report requests/TotalMinutesOfStudentEncountersByProvider.sql	
@@ -0,0 +1,30 @@
+SELECT 
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    SUM(DATEDIFF(MINUTE, e.EncounterStartTime, e.EncounterEndTime)) AS 'Total Minutes',
+    COUNT(*) AS 'Number of Encounters'
+FROM dbo.SchoolDistricts sd
+INNER JOIN dbo.Students s ON sd.Id = s.DistrictId
+INNER JOIN dbo.EncounterStudents es ON s.Id = es.StudentId
+INNER JOIN dbo.Encounters e ON es.EncounterId = e.Id
+INNER JOIN dbo.Providers p ON e.ProviderId = p.Id
+INNER JOIN dbo.Users u ON p.ProviderUserId = u.Id
+INNER JOIN dbo.ProviderTitles pt ON p.TitleId = pt.Id
+WHERE 
+    sd.Id = 160
+    AND e.EncounterDate BETWEEN '2023-07-01' AND '2024-06-30'
+    AND s.Archived = 0
+    AND es.Archived = 0
+    AND e.Archived = 0
+GROUP BY
+    u.FirstName,
+    u.LastName,
+    s.FirstName,
+    s.LastName
+ORDER BY 
+    u.LastName,
+    u.FirstName,
+    s.LastName,
+    s.FirstName;
\ No newline at end of file
diff --git a/queries/Useful queries/ClaimInfoByEncounterNumber.sql b/queries/Useful queries/ClaimInfoByEncounterNumber.sql
new file mode 100644
index 000000000..9a99ec43b
--- /dev/null
+++ b/queries/Useful queries/ClaimInfoByEncounterNumber.sql	
@@ -0,0 +1,21 @@
+SELECT
+es.Id,
+	es.EncounterNumber,
+	es.EncounterDate,
+	s.FirstName AS 'Student First',
+	s.LastName AS 'Student Last',
+	cc.Code AS 'CPT Code',
+	ce.ClaimAmount AS 'Claim Amount',
+	ce.ClaimId AS 'State Claim ID',
+	ce.ReferenceNumber AS 'ReferenceNumber',
+	ce.BillingUnits,
+	ce.PaidAmount AS 'Paid Amount',
+	ce.VoucherDate,
+	eec.Name AS 'Edi Code'
+FROM EncounterStudents es
+JOIN ClaimsEncounters ce ON ce.EncounterStudentId = es.Id
+JOIN Students s ON s.Id = es.StudentId
+JOIN EncounterStudentCptCodes escc ON escc.Id = ce.EncounterStudentCptCodeId
+JOIN CPTCodes cc ON cc.Id = escc.CptCodeId
+JOIN EdiErrorCodes eec ON eec.Id = ce.EdiErrorCodeId
+WHERE es.EncounterNumber IN ()
\ No newline at end of file
diff --git a/queries/Useful queries/CompareDBs.sql b/queries/Useful queries/CompareDBs.sql
new file mode 100644
index 000000000..b8553f00d
--- /dev/null
+++ b/queries/Useful queries/CompareDBs.sql	
@@ -0,0 +1,68 @@
+/*
+DATABASE ROW COUNT COMPARISON SCRIPT GENERATOR
+
+Purpose:
+This script generates a SQL query that can be run on a second database to compare 
+row counts between two databases. It identifies tables that have different numbers 
+of rows between the databases. I wanted to know if the data set up by the post
+deployment script was an accurate representation of the data in prod for things
+like value lists etc.
+
+How to use:
+1. Run this script on your first/source database
+2. Copy the output from the Results pane
+3. Run that output script on your second/target database
+4. The results will show:
+   - TableName: The schema and table name
+   - FirstDBCount: Number of rows in the first database
+   - SecondDBCount: Number of rows in the second database
+   - Difference: "X" if counts differ, empty string if they match
+
+The results are sorted to show tables with differences first.
+
+Note: This script only includes tables that have at least one row in the first database.
+*/
+
+-- Run this on your first database to generate a script for the second database
+DECLARE @SQL NVARCHAR(MAX) = 
+'-- Run this on your second database
+WITH FirstDBCounts AS (
+    SELECT * FROM (
+        VALUES
+';
+
+-- Build the VALUES part for the first database counts
+SELECT @SQL = @SQL + 
+    '        (''' + s.name + '.' + t.name + ''', ' + 
+    CAST(SUM(CASE WHEN i.indid <= 1 THEN i.[rows] ELSE 0 END) AS VARCHAR(20)) + '),
+'
+FROM 
+    sys.tables t
+JOIN sys.schemas s ON t.schema_id = s.schema_id
+JOIN sys.sysindexes i ON t.object_id = i.id
+WHERE 
+    t.is_ms_shipped = 0  -- Exclude system tables
+    AND i.indid <= 1     -- Only count rows from heap (0) or clustered index (1)
+    AND i.[rows] > 0     -- Only include tables with at least one row
+GROUP BY 
+    s.name, t.name
+ORDER BY 
+    s.name, t.name;
+
+-- Remove the last comma and add the closing part
+SET @SQL = LEFT(@SQL, LEN(@SQL) - 3) + '
+    ) AS t(TableName, FirstDBCount)
+)
+SELECT 
+    f.TableName,
+    f.FirstDBCount,
+    ISNULL(s.SecondDBCount, 0) AS SecondDBCount,
+    CASE WHEN f.FirstDBCount <> ISNULL(s.SecondDBCount, 0) THEN ''X'' ELSE '''' END AS Difference
+FROM 
+    FirstDBCounts f
+LEFT JOIN (
+';
+
+-- Build the UNION ALL part for the second database counts
+SELECT @SQL = @SQL + 
+    '    
\ No newline at end of file
diff --git a/queries/Useful queries/EncounterDSTIssues.sql b/queries/Useful queries/EncounterDSTIssues.sql
new file mode 100644
index 000000000..8e46267d5
--- /dev/null
+++ b/queries/Useful queries/EncounterDSTIssues.sql	
@@ -0,0 +1,49 @@
+-- Query to find encounters with time mismatches between Encounter and EncounterStudent
+-- This helps identify potential DST-related issues where times are exactly one hour apart
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    es.EncounterNumber AS 'Encounter No',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    p.NPI AS 'NPI Number',
+    CASE WHEN e.IsGroup = 1 THEN 'true' ELSE 'false' END AS 'Is Group',
+    e.AdditionalStudents AS 'Additional Students',
+    (SELECT COUNT(DISTINCT es2.StudentId) 
+     FROM dbo.EncounterStudents es2 
+     WHERE es2.EncounterId = e.Id 
+     AND es2.StudentDeviationReasonId IS NULL) AS 'Unique Students',
+    e.EncounterDate AS 'Encounter Date',
+    e.EncounterStartTime AS 'Encounter Start Time',
+    e.EncounterEndTime AS 'Encounter End Time',
+    es.EncounterStartTime AS 'Student Start Time',
+    es.EncounterEndTime AS 'Student End Time',
+    DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) AS 'Start Time Diff (minutes)',
+    DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) AS 'End Time Diff (minutes)',
+    ce.ClaimId AS 'Claim ID'
+FROM dbo.Encounters e
+JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+WHERE 
+    e.Archived = 0
+    AND es.Archived = 0
+    AND s.Archived = 0
+    AND (
+        -- Check for exactly one hour difference in either direction
+        (DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) = 60 
+         AND DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) = 60)
+        OR
+        (DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) = -60 
+         AND DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) = -60)
+    )
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName,
+    e.EncounterDate; 
\ No newline at end of file
diff --git a/queries/Useful queries/EncounterStatusMismatchComprehensive.sql b/queries/Useful queries/EncounterStatusMismatchComprehensive.sql
new file mode 100644
index 000000000..42328dcd5
--- /dev/null
+++ b/queries/Useful queries/EncounterStatusMismatchComprehensive.sql	
@@ -0,0 +1,65 @@
+-- Comprehensive query to find all encounters where the current status differs from the latest status log entry
+-- Shows school district, provider, student, and status details for analysis
+-- This is useful for identifying status synchronization issues in the system
+
+SELECT 
+    sd.Name AS SchoolDistrict,
+    prov_user.FirstName AS ProviderFirstName,
+    prov_user.LastName AS ProviderLastName,
+    s.FirstName AS StudentFirstName,
+    s.LastName AS StudentLastName,
+    es.EncounterNumber,
+    CONVERT(VARCHAR, es.EncounterDate, 101) AS EncounterDate,
+    es.EncounterStatusId AS CurrentStatusId,
+    current_status.Name AS CurrentStatus,
+    latest_status.EncounterStatusId AS LatestLogStatusId,
+    log_status.Name AS LatestLogStatus,
+    CONVERT(VARCHAR, latest_status.DateCreated, 101) AS StatusLogDate,
+    u.FirstName + ' ' + u.LastName AS StatusChangedBy
+FROM 
+    dbo.EncounterStudents es
+JOIN 
+    dbo.EncounterStatuses current_status ON es.EncounterStatusId = current_status.Id
+JOIN 
+    dbo.Students s ON es.StudentId = s.Id
+JOIN 
+    dbo.SchoolDistricts sd ON s.DistrictId = sd.Id
+JOIN 
+    dbo.Encounters e ON es.EncounterId = e.Id
+JOIN 
+    dbo.Providers p ON e.ProviderId = p.Id
+JOIN 
+    dbo.Users prov_user ON p.ProviderUserId = prov_user.Id
+JOIN 
+    (
+        -- Get the most recent status log entry for each encounter student
+        SELECT 
+            ess.EncounterStudentId,
+            ess.EncounterStatusId,
+            ess.DateCreated,
+            ess.CreatedById
+        FROM 
+            dbo.EncounterStudentStatuses ess
+        INNER JOIN 
+            (
+                SELECT 
+                    EncounterStudentId, 
+                    MAX(DateCreated) AS MaxDate
+                FROM 
+                    dbo.EncounterStudentStatuses
+                GROUP BY 
+                    EncounterStudentId
+            ) AS latest ON ess.EncounterStudentId = latest.EncounterStudentId 
+            AND ess.DateCreated = latest.MaxDate
+    ) AS latest_status ON es.Id = latest_status.EncounterStudentId
+JOIN 
+    dbo.EncounterStatuses log_status ON latest_status.EncounterStatusId = log_status.Id
+LEFT JOIN
+    dbo.Users u ON latest_status.CreatedById = u.Id
+WHERE 
+    -- Current status is different from latest log status
+    es.EncounterStatusId <> latest_status.EncounterStatusId
+    -- Only include non-archived encounters
+    AND es.Archived = 0
+ORDER BY 
+    latest_status.DateCreated DESC; 
\ No newline at end of file
diff --git a/queries/Useful queries/EncounterStudentCPTNullMinutes.sql b/queries/Useful queries/EncounterStudentCPTNullMinutes.sql
new file mode 100644
index 000000000..602d2800d
--- /dev/null
+++ b/queries/Useful queries/EncounterStudentCPTNullMinutes.sql	
@@ -0,0 +1,21 @@
+-- Query 1: Find all EncounterStudents with exactly one linked CPT code that has NULL minutes
+SELECT es.*
+FROM [dbo].[EncounterStudents] es
+WHERE es.[Id] IN (
+    SELECT escc.[EncounterStudentId]
+    FROM [dbo].[EncounterStudentCptCodes] escc
+    GROUP BY escc.[EncounterStudentId]
+    HAVING COUNT(*) = 1
+    AND MAX(CASE WHEN escc.[Minutes] IS NULL THEN 1 ELSE 0 END) = 1
+);
+
+-- Query 2: Find all EncounterStudents with multiple linked CPT codes where at least one has NULL minutes
+SELECT es.*
+FROM [dbo].[EncounterStudents] es
+WHERE es.[Id] IN (
+    SELECT escc.[EncounterStudentId]
+    FROM [dbo].[EncounterStudentCptCodes] escc
+    GROUP BY escc.[EncounterStudentId]
+    HAVING COUNT(*) > 1
+    AND SUM(CASE WHEN escc.[Minutes] IS NULL THEN 1 ELSE 0 END) > 0
+);
\ No newline at end of file
diff --git a/queries/Useful queries/EncounterTimeBoundaryIssues.sql b/queries/Useful queries/EncounterTimeBoundaryIssues.sql
new file mode 100644
index 000000000..bbd5a3fd2
--- /dev/null
+++ b/queries/Useful queries/EncounterTimeBoundaryIssues.sql	
@@ -0,0 +1,47 @@
+-- Query to find encounters where EncounterStudent times fall outside the Encounter's time boundaries
+-- This helps identify potential time entry issues where student times don't match the encounter time range
+SELECT DISTINCT
+    d.Name AS 'District Name',
+    s.FirstName AS 'Student First Name',
+    s.LastName AS 'Student Last Name',
+    CONVERT(VARCHAR, s.DateOfBirth, 110) AS 'Student Birthdate',
+    es.EncounterNumber AS 'Encounter No',
+    u.FirstName AS 'Provider First Name',
+    u.LastName AS 'Provider Last Name',
+    p.NPI AS 'NPI Number',
+    CASE WHEN e.IsGroup = 1 THEN 'true' ELSE 'false' END AS 'Is Group',
+    e.AdditionalStudents AS 'Additional Students',
+    (SELECT COUNT(DISTINCT es2.StudentId) 
+     FROM dbo.EncounterStudents es2 
+     WHERE es2.EncounterId = e.Id 
+     AND es2.StudentDeviationReasonId IS NULL) AS 'Unique Students',
+    e.EncounterDate AS 'Encounter Date',
+    e.EncounterStartTime AS 'Encounter Start Time',
+    e.EncounterEndTime AS 'Encounter End Time',
+    es.EncounterStartTime AS 'Student Start Time',
+    es.EncounterEndTime AS 'Student End Time',
+    DATEDIFF(MINUTE, e.EncounterStartTime, es.EncounterStartTime) AS 'Start Time Diff (minutes)',
+    DATEDIFF(MINUTE, e.EncounterEndTime, es.EncounterEndTime) AS 'End Time Diff (minutes)',
+    ce.ClaimId AS 'Claim ID'
+FROM dbo.Encounters e
+JOIN dbo.EncounterStudents es ON e.Id = es.EncounterId
+JOIN dbo.Students s ON es.StudentId = s.Id
+JOIN dbo.SchoolDistricts d ON s.DistrictId = d.Id
+JOIN dbo.Providers p ON e.ProviderId = p.Id
+JOIN dbo.Users u ON p.ProviderUserId = u.Id
+LEFT JOIN dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+WHERE 
+    e.Archived = 0
+    AND es.Archived = 0
+    AND (
+        -- Student start time is before encounter start time
+        es.EncounterStartTime < e.EncounterStartTime
+        OR
+        -- Student end time is after encounter end time
+        es.EncounterEndTime > e.EncounterEndTime
+    )
+ORDER BY 
+    d.Name,
+    s.LastName,
+    s.FirstName,
+    e.EncounterDate; 
\ No newline at end of file
diff --git a/queries/Useful queries/EncountersWithDuplicateStatuses.sql b/queries/Useful queries/EncountersWithDuplicateStatuses.sql
new file mode 100644
index 000000000..b873996a7
--- /dev/null
+++ b/queries/Useful queries/EncountersWithDuplicateStatuses.sql	
@@ -0,0 +1,29 @@
+WITH StatusSequence AS (
+    SELECT 
+        ess.EncounterStudentId,
+        ess.EncounterStatusId,
+        es.Name as StatusName,
+        ess.DateCreated,
+        ROW_NUMBER() OVER (PARTITION BY ess.EncounterStudentId ORDER BY ess.DateCreated) as RowNum,
+        LAG(ess.EncounterStatusId) OVER (PARTITION BY ess.EncounterStudentId ORDER BY ess.DateCreated) as PrevStatus,
+        LAG(es.Name) OVER (PARTITION BY ess.EncounterStudentId ORDER BY ess.DateCreated) as PrevStatusName,
+        LAG(ess.DateCreated) OVER (PARTITION BY ess.EncounterStudentId ORDER BY ess.DateCreated) as PrevDateCreated
+    FROM EncounterStudentStatuses ess
+    JOIN EncounterStatuses es ON ess.EncounterStatusId = es.Id
+)
+SELECT DISTINCT
+    ss.EncounterStudentId,
+    ss.StatusName,
+    MIN(ss.DateCreated) as FirstOccurrence,
+    ss.PrevStatusName as PreviousStatus,
+    MIN(ss.PrevDateCreated) as PreviousStatusDate
+FROM StatusSequence ss
+WHERE ss.EncounterStatusId = ss.PrevStatus 
+    AND ss.RowNum > 1
+GROUP BY 
+    ss.EncounterStudentId,
+    ss.StatusName,
+    ss.PrevStatusName
+ORDER BY 
+    ss.EncounterStudentId,
+    FirstOccurrence;
\ No newline at end of file
diff --git a/queries/Useful queries/EncountersWithMismatchedStatuses.sql b/queries/Useful queries/EncountersWithMismatchedStatuses.sql
new file mode 100644
index 000000000..7add6617e
--- /dev/null
+++ b/queries/Useful queries/EncountersWithMismatchedStatuses.sql	
@@ -0,0 +1,26 @@
+WITH LatestStatus AS (
+    SELECT 
+        EncounterStudentId,
+        EncounterStatusId as LatestStatusId,
+        DateCreated as LatestStatusDate
+    FROM EncounterStudentStatuses ess1
+    WHERE DateCreated = (
+        SELECT MAX(DateCreated)
+        FROM EncounterStudentStatuses ess2
+        WHERE ess2.EncounterStudentId = ess1.EncounterStudentId
+    )
+)
+SELECT 
+    es.Id as EncounterStudentId,
+    es.EncounterNumber,
+    es.EncounterStatusId as CurrentStatusId,
+    ess_current.Name as CurrentStatusName,
+    ls.LatestStatusId,
+    ess_latest.Name as LatestStatusName,
+    ls.LatestStatusDate
+FROM EncounterStudents es
+JOIN LatestStatus ls ON es.Id = ls.EncounterStudentId
+JOIN EncounterStatuses ess_current ON es.EncounterStatusId = ess_current.Id
+JOIN EncounterStatuses ess_latest ON ls.LatestStatusId = ess_latest.Id
+WHERE es.EncounterStatusId <> ls.LatestStatusId
+ORDER BY ls.LatestStatusDate DESC;
\ No newline at end of file
diff --git a/queries/Useful queries/EncountersWithRebilledStatusMismatch.sql b/queries/Useful queries/EncountersWithRebilledStatusMismatch.sql
new file mode 100644
index 000000000..663fd2d90
--- /dev/null
+++ b/queries/Useful queries/EncountersWithRebilledStatusMismatch.sql	
@@ -0,0 +1,54 @@
+SELECT 
+    es.EncounterNumber,
+    CONVERT(VARCHAR, es.EncounterDate, 101) AS EncounterDate,
+    denied.Name AS CurrentStatus,
+    ready.Name AS LatestLogStatus,
+    CONVERT(VARCHAR, latest_status.DateCreated, 101) AS StatusLogDate,
+    u.FirstName + ' ' + u.LastName AS StatusChangedBy,
+    ce.ClaimId AS StateClaimId,
+    ce.ProcedureIdentifier AS CPTCode,
+    CONVERT(VARCHAR, ce.VoucherDate, 101) AS VoucherDate
+FROM 
+    dbo.EncounterStudents es
+JOIN 
+    dbo.EncounterStatuses denied ON es.EncounterStatusId = denied.Id
+JOIN 
+    (
+        -- Get the most recent status log entry for each encounter student
+        SELECT 
+            ess.EncounterStudentId,
+            ess.EncounterStatusId,
+            ess.DateCreated,
+            ess.CreatedById
+        FROM 
+            dbo.EncounterStudentStatuses ess
+        INNER JOIN 
+            (
+                SELECT 
+                    EncounterStudentId, 
+                    MAX(DateCreated) AS MaxDate
+                FROM 
+                    dbo.EncounterStudentStatuses
+                GROUP BY 
+                    EncounterStudentId
+            ) AS latest ON ess.EncounterStudentId = latest.EncounterStudentId 
+            AND ess.DateCreated = latest.MaxDate
+    ) AS latest_status ON es.Id = latest_status.EncounterStudentId
+JOIN 
+    dbo.EncounterStatuses ready ON latest_status.EncounterStatusId = ready.Id
+JOIN
+    dbo.ClaimsEncounters ce ON es.Id = ce.EncounterStudentId
+LEFT JOIN
+    dbo.Users u ON latest_status.CreatedById = u.Id
+WHERE 
+    -- Encounter status is "Invoiced and Denied" (status ID 23)
+    es.EncounterStatusId = 23
+    -- But latest status log has "READY_FOR_BILLING" (status ID 30)
+    AND latest_status.EncounterStatusId = 30
+    -- And the claim has been marked as rebilled
+    AND ce.Rebilled = 1
+	-- AND es.EncounterNumber IN ('T2370503240308','T2370503240315','T2370509248137')
+	AND ce.ClaimId IS NOT NULL
+ORDER BY 
+    es.EncounterNumber,
+    ce.Id;
\ No newline at end of file
diff --git a/queries/Useful queries/ProviderLookup.sql b/queries/Useful queries/ProviderLookup.sql
new file mode 100644
index 000000000..c511f50b7
--- /dev/null
+++ b/queries/Useful queries/ProviderLookup.sql	
@@ -0,0 +1,25 @@
+-- ProviderLookupByEmail.sql
+-- This query retrieves provider information based on the provided email address or name
+-- It joins the Providers, Users, and AuthUsers tables to fetch comprehensive information
+
+DECLARE @ProviderEmail VARCHAR(254) = NULL -- Set to provider's email or NULL if searching by name
+DECLARE @FirstName VARCHAR(50) = NULL -- Set to provider's first name or NULL
+DECLARE @LastName VARCHAR(50) = NULL -- Set to provider's last name or NULL
+
+SELECT *
+FROM 
+    dbo.Users u
+INNER JOIN 
+    dbo.AuthUsers au ON u.AuthUserId = au.Id
+INNER JOIN 
+    dbo.Providers p ON u.Id = p.ProviderUserId
+LEFT JOIN 
+    dbo.ProviderTitles pt ON p.TitleId = pt.Id
+LEFT JOIN 
+    dbo.ProviderEmploymentTypes pet ON p.ProviderEmploymentTypeId = pet.Id
+LEFT JOIN 
+    dbo.ProviderDoNotBillReasons dnbr ON p.DoNotBillReasonId = dnbr.Id
+WHERE 
+    (@ProviderEmail IS NULL OR u.Email = @ProviderEmail)
+    AND (@FirstName IS NULL OR u.FirstName LIKE @FirstName + '%')
+    AND (@LastName IS NULL OR u.LastName LIKE @LastName + '%') 
\ No newline at end of file
diff --git a/queries/Useful queries/WhitespaceCleanup.sql b/queries/Useful queries/WhitespaceCleanup.sql
new file mode 100644
index 000000000..bdb9a85d6
--- /dev/null
+++ b/queries/Useful queries/WhitespaceCleanup.sql	
@@ -0,0 +1,54 @@
+-- WhitespaceCleanup.sql
+-- Trims leading and trailing whitespace from a column in a specified table
+-- Replace @TableName and @ColumnName with your actual table and column names
+-- WARNING: Run this only after confirming issues with WhitespaceIssueFinder.sql
+-- Make sure to create a backup or run this in a transaction first
+
+DECLARE @TableName NVARCHAR(128) = 'Addresses';  -- Default to Addresses table
+DECLARE @ColumnName NVARCHAR(128) = 'Address1';  -- Default to Address1 column
+DECLARE @PrimaryKeyColumn NVARCHAR(128) = 'Id'; -- Assumes a primary key named Id, change if different
+
+DECLARE @SQL NVARCHAR(MAX);
+
+-- Begin transaction for safety - you can commit after reviewing changes
+BEGIN TRANSACTION;
+
+SET @SQL = N'
+-- Show the records that will be changed (before)
+SELECT 
+    ' + QUOTENAME(@PrimaryKeyColumn) + ' AS [Primary Key],
+    ' + QUOTENAME(@ColumnName) + ' AS [Original Value],
+    LTRIM(RTRIM(' + QUOTENAME(@ColumnName) + ')) AS [Trimmed Value],
+    CASE
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE ''% '' THEN ''Has trailing spaces''
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE '' %'' THEN ''Has leading spaces''
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE '' %'' AND ' + QUOTENAME(@ColumnName) + ' LIKE ''% '' THEN ''Has both leading and trailing spaces''
+    END AS WhitespaceIssue
+FROM
+    ' + QUOTENAME(@TableName) + '
+WHERE
+    ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
+    AND (' + QUOTENAME(@ColumnName) + ' LIKE ''% '' OR ' + QUOTENAME(@ColumnName) + ' LIKE '' %'');
+
+-- Update the records to trim whitespace
+UPDATE ' + QUOTENAME(@TableName) + '
+SET ' + QUOTENAME(@ColumnName) + ' = LTRIM(RTRIM(' + QUOTENAME(@ColumnName) + '))
+WHERE
+    ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
+    AND (' + QUOTENAME(@ColumnName) + ' LIKE ''% '' OR ' + QUOTENAME(@ColumnName) + ' LIKE '' %'');';
+
+EXEC sp_executesql @SQL;
+
+-- Count how many records were updated
+SET @SQL = N'
+SELECT 
+    @@ROWCOUNT AS [Records Updated];
+';
+
+EXEC sp_executesql @SQL;
+
+-- Uncomment to commit the changes
+-- COMMIT TRANSACTION;
+
+-- Or rollback if you want to cancel the changes
+ROLLBACK TRANSACTION; 
\ No newline at end of file
diff --git a/queries/Useful queries/WhitespaceIssueFinder.sql b/queries/Useful queries/WhitespaceIssueFinder.sql
new file mode 100644
index 000000000..e8ed31a9b
--- /dev/null
+++ b/queries/Useful queries/WhitespaceIssueFinder.sql	
@@ -0,0 +1,26 @@
+-- WhitespaceIssueFinder.sql
+-- Lists all entries in a column that have leading or trailing whitespace
+-- Replace @TableName and @ColumnName with your actual table and column names
+
+DECLARE @TableName NVARCHAR(128) = 'Addresses';  -- Default to Addresses table
+DECLARE @ColumnName NVARCHAR(128) = 'Address1';  -- Default to Address1 column
+
+DECLARE @SQL NVARCHAR(MAX);
+
+SET @SQL = N'
+SELECT
+    *,
+    CASE
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE ''% '' THEN ''Has trailing spaces''
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE '' %'' THEN ''Has leading spaces''
+        WHEN ' + QUOTENAME(@ColumnName) + ' LIKE '' %'' AND ' + QUOTENAME(@ColumnName) + ' LIKE ''% '' THEN ''Has both leading and trailing spaces''
+    END AS WhitespaceIssue
+FROM
+    ' + QUOTENAME(@TableName) + '
+WHERE
+    ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
+    AND (' + QUOTENAME(@ColumnName) + ' LIKE ''% '' OR ' + QUOTENAME(@ColumnName) + ' LIKE '' %'')
+ORDER BY
+    ' + QUOTENAME(@ColumnName) + ';';
+
+EXEC sp_executesql @SQL;
\ No newline at end of file
diff --git a/src/API/AdminPortal/DataImport/DataImportController.cs b/src/API/AdminPortal/DataImport/DataImportController.cs
new file mode 100644
index 000000000..fc031c118
--- /dev/null
+++ b/src/API/AdminPortal/DataImport/DataImportController.cs
@@ -0,0 +1,178 @@
+using API.Core.Claims;
+using API.ControllerBase;
+using Microsoft.AspNetCore.Http;
+using Microsoft.AspNetCore.Mvc;
+using Service.DataImport;
+using System;
+using System.IO;
+using System.Threading.Tasks;
+
+namespace API.AdminPortal.DataImport
+{
+    [Route("api/v1/data-import")]
+    [Restrict(ClaimTypes.Encounters, ClaimValues.ReadOnly | ClaimValues.FullAccess)]
+    public class DataImportController : ApiControllerBase
+    {
+        private readonly IDataImportService _dataImportService;
+
+        public DataImportController(
+            IDataImportService dataImportService)
+        {
+            _dataImportService = dataImportService;
+        }
+
+        [HttpGet]
+        [Route("encounters/template")]
+        public IActionResult GetEncounterTemplate()
+        {
+            try
+            {
+                var csvData = _dataImportService.GenerateTemplate();
+                return File(csvData, "text/csv", "encounter_import_template.csv");
+            }
+            catch (Exception ex)
+            {
+                return BadRequest($"Error generating template: {ex.Message}");
+            }
+        }
+
+        [HttpPost]
+        [Route("encounters/import")]
+        public async Task<IActionResult> ValidateEncounterImport(IFormFile file, [FromQuery] bool createMissingStudentRecords = false)
+        {
+            if (file == null || file.Length == 0)
+            {
+                return BadRequest("No file uploaded");
+            }
+
+            // Validate file type
+            var fileExtension = Path.GetExtension(file.FileName).ToLowerInvariant();
+            if (fileExtension != ".csv")
+            {
+                return BadRequest("Only CSV files are allowed");
+            }
+
+            try
+            {
+                // Read the file into a byte array
+                byte[] fileBytes;
+                using (var ms = new MemoryStream())
+                {
+                    await file.CopyToAsync(ms);
+                    fileBytes = ms.ToArray();
+                }
+
+                // Process the file
+                var result = await _dataImportService.ProcessImportFileAsync(fileBytes, this.GetUserId(), createMissingStudentRecords);
+
+                // If there are errors, return the error file
+                if (result.ErrorCount > 0 && result.ErrorFileContent != null)
+                {
+                    var originalFileName = Path.GetFileNameWithoutExtension(file.FileName);
+                    var errorFileName = $"{originalFileName}_errors_{DateTime.Now:yyyyMMdd_HHmmss}.csv";
+                    return File(
+                        result.ErrorFileContent, 
+                        "text/csv", 
+                        errorFileName
+                    );
+                }
+
+                // If successful with no errors, return a success message
+                return Ok(new { 
+                    Success = result.Success, 
+                    Message = result.Message,
+                    SuccessCount = result.SuccessCount
+                });
+            }
+            catch (Exception ex)
+            {
+                return BadRequest($"Error processing file: {ex.Message}");
+            }
+        }
+
+        [HttpPost]
+        [Route("convert")]
+        public async Task<IActionResult> ConvertPartnerFiles([FromQuery] string partner, [FromForm] IFormFile studentFile, [FromForm] IFormFile serviceFile)
+        {
+            if (string.IsNullOrWhiteSpace(partner))
+            {
+                return BadRequest("Integration partner must be specified");
+            }
+
+            // Validate based on partner type
+            switch (partner.ToUpperInvariant())
+            {
+                case "SNAP":
+                    if (studentFile == null || serviceFile == null || studentFile.Length == 0 || serviceFile.Length == 0)
+                    {
+                        return BadRequest("Both student and service files are required for SNAP integration");
+                    }
+                    break;
+                case "MST":
+                    if (serviceFile == null || serviceFile.Length == 0)
+                    {
+                        return BadRequest("Service file is required for MST integration");
+                    }
+                    break;
+                default:
+                    return BadRequest($"Unsupported integration partner: {partner}");
+            }
+
+            // Validate file types
+            // var studentFileExtension = Path.GetExtension(studentFile.FileName).ToLowerInvariant();
+            // var serviceFileExtension = Path.GetExtension(serviceFile.FileName).ToLowerInvariant();
+            // if (fileExtension != ".csv")
+            // {
+            //     return BadRequest("Only CSV files are allowed");
+            // }
+
+            try
+            {
+                // Read the files into byte arrays
+                byte[] studentFileBytes = null;
+                byte[] serviceFileBytes;
+                
+                // Read service file
+                using (var ms = new MemoryStream())
+                {
+                    await serviceFile.CopyToAsync(ms);
+                    serviceFileBytes = ms.ToArray();
+                }
+                
+                // Read student file only if it's SNAP
+                if (partner.ToUpperInvariant() == "SNAP")
+                {
+                    using (var ms = new MemoryStream())
+                    {
+                        await studentFile.CopyToAsync(ms);
+                        studentFileBytes = ms.ToArray();
+                    }
+                }
+
+                // Process the files based on partner
+                byte[] convertedFile;
+                switch (partner.ToUpperInvariant())
+                {
+                    case "SNAP":
+                        convertedFile = await _dataImportService.ConvertSnapFilesAsync(studentFileBytes, serviceFileBytes, studentFile.FileName);
+                        break;
+                    case "MST":
+                        convertedFile = await _dataImportService.ConvertMstFilesAsync(serviceFileBytes);
+                        break;
+                    default:
+                        return BadRequest($"Unsupported integration partner: {partner}");
+                }
+
+                return File(
+                    convertedFile,
+                    "text/csv",
+                    $"converted_encounters_{DateTime.Now:yyyyMMdd_HHmmss}.csv"
+                );
+            }
+            catch (Exception ex)
+            {
+                return BadRequest($"Error converting files: {ex.Message}");
+            }
+        }
+    }
+} 
diff --git a/src/API/AdminPortal/DataImport/Notes.cs b/src/API/AdminPortal/DataImport/Notes.cs
new file mode 100644
index 000000000..2015f4ee0
--- /dev/null
+++ b/src/API/AdminPortal/DataImport/Notes.cs
@@ -0,0 +1,71 @@
+/*
+ * Data Import Feature Implementation Notes
+ * =======================================
+ * 
+ * Files Modified in Data Import Implementation
+ * -------------------------------------------
+ * 
+ * Frontend Files:
+ * 1. src/app/admin-portal/data-import/components/data-import/data-import.component.html - Basic UI with a download template button
+ * 2. src/app/admin-portal/data-import/components/data-import/data-import.component.ts - Component logic for handling template download
+ * 3. src/app/admin-portal/data-import/services/data-import.service.ts - Service with mock implementation for template download
+ * 4. src/app/admin-portal/data-import/data-import.module.ts - Module definition with necessary imports
+ * 5. src/app/admin-portal/data-import/data-import-routes.library.ts - Routing configuration for the data import feature
+ * 6. src/app/admin-portal/nav/admin-nav-menu.config.ts - Navigation menu configuration with data import entry
+ * 
+ * Backend Files:
+ * 1. src/API/AdminPortal/DataImport/DataImportController.cs - API controller with endpoint for template download
+ * 2. src/Service/DataImport/IDataImportService.cs - Service interface defining template generation method and validation interfaces
+ * 3. src/Service/DataImport/EncounterImportService.cs - Service implementation for encounter imports with validation and processing logic
+ * 4. src/Service.Test/DataImport/EncounterImportServiceTests.cs - Comprehensive tests for the encounter import service
+ * 
+ * Summary:
+ * We've implemented a robust data import feature that allows users to download CSV templates for encounter imports
+ * and process uploaded files with comprehensive validation. The implementation includes:
+ * 
+ * 1. Template Generation:
+ *    - Users can download a CSV template with all required fields for encounter imports
+ *    - The template includes headers for district, provider, student, and encounter information
+ * 
+ * 2. Data Validation:
+ *    - Comprehensive validation of imported data including:
+ *      - District validation (by ID or name)
+ *      - Provider validation (by ID, NPI, or name)
+ *      - Student validation (by ID, code, or name+DOB)
+ *    - Detailed error messages for invalid data
+ * 
+ * 3. File Processing:
+ *    - Parsing of CSV files with proper handling of headers and data types
+ *    - Processing of each row with validation
+ *    - Generation of error reports for invalid rows
+ *    - Summary statistics (success count, error count)
+ * 
+ * 4. Error Reporting:
+ *    - Generation of error CSV files with validation messages
+ *    - Preservation of original data with added error information
+ *    - Clear indication of which fields failed validation
+ * 
+ * The frontend includes a simple UI with a download button that triggers a request to the backend.
+ * The backend includes a controller endpoint that calls a service to generate the template.
+ * The service is automatically registered through the existing ServiceModule convention.
+ * 
+ * Next Steps:
+ * 1. Implement file upload UI component
+ * 2. Add backend endpoint for receiving uploaded files
+ * 3. Connect the frontend to the backend processing logic
+ * 4. Implement progress tracking and status reporting
+ * 5. Add user feedback for successful and failed imports
+ * 6. Implement actual database operations for creating encounters from valid data
+ */
+
+namespace API.DataImport
+{
+    /// <summary>
+    /// This file contains implementation notes for the Data Import feature.
+    /// It does not contain any actual code and is for documentation purposes only.
+    /// </summary>
+    public class Notes
+    {
+        // This class is intentionally empty and serves only as a container for the documentation comments above.
+    }
+} 
\ No newline at end of file
diff --git a/src/Documentation/DatabaseFlows/NursingStudentEncounterFlow.md b/src/Documentation/DatabaseFlows/NursingStudentEncounterFlow.md
new file mode 100644
index 000000000..c26e6be96
--- /dev/null
+++ b/src/Documentation/DatabaseFlows/NursingStudentEncounterFlow.md
@@ -0,0 +1,905 @@
+# Nursing Student and Encounter Creation Flow
+
+## Overview
+This document captures the database operations that occur when a nurse creates a student and associated encounters through the application UI. This information will be used to ensure that data imported through the `EncounterImportService` matches what would be created manually.
+
+## Flow Sequence
+Below we'll document the SQL operations as captured by SQL Server Profiler when performing the following actions:
+1. Creating a new student
+2. Creating a case load for the student
+3. Creating a case load script (required for nursing)
+4. Creating an encounter for the student
+
+## Database Operations
+*The SQL operations below were captured during manual testing with SQL Server Profiler.*
+
+### 1. Student Creation
+
+#### 1.1 Create Address Record
+```sql
+INSERT [dbo].[Addresses]([Address1], [Address2], [City], [StateCode], [Zip], [CountryCode], [Province], [County])
+VALUES (@Address1, @Address2, @City, @StateCode, @Zip, @CountryCode, @Province, @County)
+```
+
+**Columns populated:**
+- ≡ƒöñ `Address1`: Street address (e.g., 'TestAddr1') - *manually entered*
+- ≡ƒöñ `Address2`: Additional address info (e.g., 'TestAddr2') - *manually entered*
+- ≡ƒöñ `City`: City name (e.g., 'TestCity') - *manually entered*
+- ≡ƒöñ `StateCode`: Two-character state code (e.g., 'OH') - *manually entered*
+- ≡ƒöñ `Zip`: Postal code (e.g., '37920') - *manually entered*
+- ≡ƒöä `CountryCode`: Two-character country code (e.g., 'US') - *default value*
+- ≡ƒöñ `Province`: Province name (optional, left empty in example) - *manually entered (empty)*
+- ≡ƒöñ `County`: County name (e.g., 'TestCounty') - *manually entered*
+
+**Notes:**
+- The operation returns the newly created Address ID using `scope_identity()`
+- This address record will be associated with the student record
+- All string fields have specific length constraints (e.g., StateCode is char(2))
+
+#### 1.2 Create Student Record
+```sql
+INSERT [dbo].[Students]([FirstName], [MiddleName], [LastName], [StudentCode], [MedicaidNo], [Grade], [DateOfBirth], [Notes], [AddressId], [SchoolId], [DistrictId], [EnrollmentDate], [EscId], [CreatedById], [ModifiedById], [DateCreated], [DateModified], [Archived])
+VALUES (@FirstName, NULL, @LastName, @StudentCode, NULL, @Grade, @DateOfBirth, NULL, @AddressId, @SchoolId, @DistrictId, @EnrollmentDate, NULL, @CreatedById, NULL, @DateCreated, NULL, @Archived)
+```
+
+**Columns populated:**
+- ≡ƒöñ `FirstName`: Student's first name (e.g., 'Flow') - *manually entered*
+- ≡ƒöñ `MiddleName`: Middle name (NULL in example) - *not entered*
+- ≡ƒöñ `LastName`: Last name (e.g., 'Test') - *manually entered*
+- ≡ƒöñ `StudentCode`: Unique identifier for the student (e.g., '1234567890AB') - *manually entered*
+- ≡ƒöñ `MedicaidNo`: Medicaid number (NULL in example) - *not entered*
+- ≡ƒöñ `Grade`: Student's grade level (e.g., 'DI') - *manually entered*
+- ≡ƒöñ `DateOfBirth`: Student's birth date (e.g., '2020-03-21') - *manually entered*
+- ≡ƒöñ `Notes`: Additional notes (NULL in example) - *not entered*
+- ≡ƒöä `AddressId`: Foreign key reference to the Address record created in step 1.1 - *auto-populated*
+- ≡ƒöì `SchoolId`: Foreign key reference to the School (e.g., 1001) - *selected from UI dropdown*
+- ≡ƒöä `DistrictId`: Foreign key reference to the District (e.g., 1) - *auto-populated from SchoolId*
+- ≡ƒöä `EnrollmentDate`: When the student was enrolled (e.g., current date) - *auto-populated*
+- ≡ƒöñ `EscId`: ESC identifier (NULL in example) - *not entered*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created Student ID using `scope_identity()`
+- The `AddressId` links to the address created in the previous step
+- Several fields are left NULL initially (MiddleName, MedicaidNo, Notes, EscId, ModifiedById, DateModified)
+- The `EnrollmentDate` is set to the current date by default
+- The `CreatedById` corresponds to the logged-in user's ID
+- The student record is linked to both a School and a District
+- The DistrictId is inferred automatically from the selected School
+
+**Legend:**
+- ≡ƒöñ Manually entered value
+- ≡ƒöì Selected from UI (dropdown, etc.)
+- ≡ƒöä Auto-populated value
+
+#### 1.3 Create Provider-Student Relationship
+```sql
+INSERT [dbo].[ProviderStudents]([ProviderId], [StudentId], [CreatedById], [DateCreated])
+VALUES (@ProviderId, @StudentId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `ProviderId`: Foreign key reference to the Provider record (e.g., 1) - *auto-populated from logged-in user*
+- ≡ƒöä `StudentId`: Foreign key reference to the Student record created in step 1.2 (e.g., 2) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created relationship ID using `scope_identity()`
+- This establishes the association between a provider and a student
+- This relationship is created automatically when a provider creates a student
+- No user input is required; it happens by virtue of being logged in as the provider
+- The relationship is required before creating case loads and encounters
+- No ModifiedById or DateModified fields are included, suggesting these may be added only when the record is updated
+
+#### 1.4 Create Student Parental Consent
+```sql
+INSERT [dbo].[StudentParentalConsents]([StudentId], [ParentalConsentEffectiveDate], [ParentalConsentDateEntered], [ParentalConsentTypeId], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@StudentId, @ParentalConsentEffectiveDate, @ParentalConsentDateEntered, @ParentalConsentTypeId, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `StudentId`: Foreign key reference to the Student record created in step 1.2 (e.g., 2) - *auto-populated*
+- ≡ƒöä `ParentalConsentEffectiveDate`: When the consent becomes effective (e.g., current date/time) - *auto-populated*
+- ≡ƒöä `ParentalConsentDateEntered`: When the consent was entered into the system (e.g., current date/time) - *auto-populated*
+- ≡ƒöä `ParentalConsentTypeId`: Type of parental consent (e.g., 3) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created consent ID using `scope_identity()`
+- This record is automatically created as part of student creation without any user input
+- The ParentalConsentTypeId of 3 likely corresponds to a default consent type in a lookup table
+- Both effective date and entered date are automatically set to the current timestamp
+- This appears to be a system-generated record created whenever a new student is added
+- ModifiedById and DateModified are NULL initially and would be populated on update
+
+### 2. Case Load Creation
+
+#### 2.1 Create Case Load Record
+```sql
+INSERT [dbo].[CaseLoads]([StudentTypeId], [ServiceCodeId], [StudentId], [DiagnosisCodeId], [DisabilityCodeId], [IEPStartDate], [IEPEndDate], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@StudentTypeId, @ServiceCodeId, @StudentId, NULL, NULL, @IEPStartDate, @IEPEndDate, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöì `StudentTypeId`: Type of student (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `ServiceCodeId`: Service code for the case load (e.g., 5 - nursing services) - *auto-populated from provider's title*
+- ≡ƒöä `StudentId`: Foreign key reference to the Student record (e.g., 2) - *auto-populated*
+- ≡ƒöñ `DiagnosisCodeId`: Foreign key reference to diagnosis code (NULL in example) - *not entered*
+- ≡ƒöñ `DisabilityCodeId`: Foreign key reference to disability code (NULL in example) - *not entered*
+- ≡ƒöñ `IEPStartDate`: Start date for the Individualized Education Program (e.g., '2025-03-20') - *manually entered*
+- ≡ƒöñ `IEPEndDate`: End date for the Individualized Education Program (e.g., '2026-03-21') - *manually entered*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created CaseLoad ID using `scope_identity()`
+- This record represents a "Plan Type" in the UI, which appears to be a nursing service plan for this student
+- The ServiceCodeId of 5 corresponds to nursing services, inferred from the provider's title
+- DiagnosisCodeId and DisabilityCodeId are left NULL in this example but could be populated
+- The IEP start and end dates establish the timeframe for this service
+- ModifiedById and DateModified are NULL initially and would be populated on update
+
+### 3. Case Load Script Creation
+
+#### 3.1 Create Case Load Script Record
+```sql
+INSERT [dbo].[CaseLoadScripts]([NPI], [DiagnosisCodeId], [DoctorFirstName], [DoctorLastName], [InitiationDate], [ExpirationDate], [FileName], [FilePath], [CaseLoadId], [Archived], [UploadedById], [ModifiedById], [DateUpload], [DateModified])
+VALUES (@NPI, @DiagnosisCodeId, @DoctorFirstName, @DoctorLastName, @InitiationDate, @ExpirationDate, @FileName, @FilePath, @CaseLoadId, @Archived, @UploadedById, NULL, @DateUpload, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöñ `NPI`: National Provider Identifier for the prescribing doctor (e.g., '1234567890') - *manually entered*
+- ≡ƒöì `DiagnosisCodeId`: Foreign key reference to diagnosis code (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöñ `DoctorFirstName`: First name of the prescribing doctor (e.g., 'TestDoctorFirst') - *manually entered*
+- ≡ƒöñ `DoctorLastName`: Last name of the prescribing doctor (e.g., 'TestDoctorLast') - *manually entered*
+- ≡ƒöñ `InitiationDate`: Start date for the prescription (e.g., '2025-03-20') - *manually entered*
+- ≡ƒöñ `ExpirationDate`: End date for the prescription (e.g., '2025-10-30') - *manually entered*
+- ≡ƒöä `FileName`: Name of the uploaded prescription file (empty in this example) - *populated from uploaded file name, if any*
+- ≡ƒöä `FilePath`: Path to the uploaded prescription file (empty in this example) - *auto-populated from system file storage path*
+- ≡ƒöä `CaseLoadId`: Foreign key reference to the CaseLoad record created in step 2.1 (e.g., 2) - *auto-populated*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `UploadedById`: User ID of the person who uploaded the script (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateUpload`: Timestamp of upload (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created CaseLoadScript ID using `scope_identity()`
+- This record represents a doctor's prescription/authorization for the nursing services
+- It's a critical component specifically for nursing providers (unlike some other provider types)
+- The script has its own diagnosis code which may differ from the case load's diagnosis
+- The script has its own date range (InitiationDate to ExpirationDate) which might be different from the IEP dates
+- File upload is optional (FileName and FilePath are empty in this example) but would be populated from an uploaded file if provided
+- ModifiedById and DateModified are NULL initially and would be populated on update
+
+#### 3.2 Create Case Load Script Goal
+```sql
+INSERT [dbo].[CaseLoadScriptGoals]([CaseLoadScriptId], [GoalId], [MedicationName], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@CaseLoadScriptId, @GoalId, NULL, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `CaseLoadScriptId`: Foreign key reference to the CaseLoadScript created in step 3.1 (e.g., 2) - *auto-populated*
+- ≡ƒöì `GoalId`: Foreign key reference to a predefined goal (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöñ `MedicationName`: Name of medication (NULL in this example) - *not entered*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created CaseLoadScriptGoal ID using `scope_identity()`
+- This links a predefined goal (likely from a goals table) to the case load script
+- For nursing providers, this represents a treatment goal or objective
+- MedicationName is NULL in this example but could be populated for medication-related goals
+- Multiple goals can be added by repeating this operation with different GoalId values
+- The user only needs to select the goal(s) from a dropdown; all other fields are auto-populated
+
+#### 3.3 Update Case Load Script with Modification Info
+```sql
+UPDATE [dbo].[CaseLoadScripts]
+SET [ModifiedById] = @ModifiedById, [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- `ModifiedById`: User ID of the person who modified the record (e.g., 1007)
+- `DateModified`: Timestamp of modification (current date/time)
+
+**Where condition:**
+- `Id`: The ID of the CaseLoadScript to update (e.g., 2)
+
+**Notes:**
+- This update occurs immediately after creating the case load script and associated goals
+- It's likely setting the modification information to track that the script has been fully configured
+- The ModifiedById matches the original creator's ID in this example
+- This update completes the script creation process
+
+### 4. Encounter Creation
+
+#### 4.1 Create Initial Encounter Record
+```sql
+INSERT [dbo].[Encounters]([ProviderId], [ServiceTypeId], [NonMspServiceTypeId], [EvaluationTypeId], [EncounterDate], [EncounterStartTime], [EncounterEndTime], [IsGroup], [AdditionalStudents], [FromSchedule], [DiagnosisCodeId], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@ProviderId, @ServiceTypeId, NULL, NULL, NULL, NULL, NULL, @IsGroup, @AdditionalStudents, @FromSchedule, NULL, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `ProviderId`: Foreign key reference to the Provider record (e.g., 1) - *auto-populated from logged-in user*
+- ≡ƒöä `ServiceTypeId`: Type of service (e.g., 3) - *auto-populated*
+- ≡ƒöä `NonMspServiceTypeId`: NULL for initial encounter - *auto-populated*
+- ≡ƒöä `EvaluationTypeId`: NULL for initial encounter - *auto-populated*
+- ≡ƒöä `EncounterDate`: NULL initially - *auto-populated*
+- ≡ƒöä `EncounterStartTime`: NULL initially - *auto-populated*
+- ≡ƒöä `EncounterEndTime`: NULL initially - *auto-populated*
+- ≡ƒöä `IsGroup`: Boolean flag indicating if this is a group encounter (false/0) - *auto-populated*
+- ≡ƒöä `AdditionalStudents`: Number of additional students (0) - *auto-populated*
+- ≡ƒöä `FromSchedule`: Boolean flag indicating if created from schedule (false/0) - *auto-populated*
+- ≡ƒöä `DiagnosisCodeId`: NULL initially - *auto-populated*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: NULL for new records - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: NULL for new records - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created Encounter ID using `scope_identity()`
+- This initial record is created automatically when navigating to the create encounter page
+- No user input is required at this stage - all fields are populated automatically by the system
+- The encounter is linked to the specific provider
+- Date and time fields are left NULL initially, to be populated later
+- The ServiceTypeId of 3 appears to be a default value for this type of encounter
+- This is the first step in creating an encounter
+
+#### 4.2 Update Encounter with Date and Time Details
+```sql
+UPDATE [dbo].[Encounters]
+SET [EncounterDate] = @EncounterDate, [EncounterStartTime] = @EncounterStartTime, [EncounterEndTime] = @EncounterEndTime, [ModifiedById] = @ModifiedById, [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöñ `EncounterDate`: Date of the encounter (e.g., '2025-03-21') - *manually entered*
+- ≡ƒöñ `EncounterStartTime`: Start time of the encounter (e.g., '16:00:00') - *manually entered*
+- ≡ƒöñ `EncounterEndTime`: End time of the encounter (e.g., '16:30:00') - *manually entered*
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the Encounter to update (e.g., 9) - *auto-populated*
+
+**Notes:**
+- This update occurs when the user enters the basic encounter details in the UI
+- The initially auto-populated date and time fields are now replaced with user-specified values
+- This establishes the timeframe for the encounter (date, start and end times)
+- The record is marked as modified with the current user's ID and timestamp
+
+**Note:** At this point, the encounter creation flow diverges based on whether it is an evaluation/assessment encounter or a regular treatment/therapy encounter. The following sections document both paths.
+
+### 4A. Evaluation Encounter Creation
+
+#### 4A.1 Create Initial Evaluation Encounter Record
+```sql
+INSERT [dbo].[Encounters]([ProviderId], [ServiceTypeId], [NonMspServiceTypeId], [EvaluationTypeId], [EncounterDate], [EncounterStartTime], [EncounterEndTime], [IsGroup], [AdditionalStudents], [FromSchedule], [DiagnosisCodeId], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@ProviderId, @ServiceTypeId, NULL, @EvaluationTypeId, NULL, NULL, NULL, @IsGroup, @AdditionalStudents, @FromSchedule, NULL, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `ProviderId`: Foreign key reference to the Provider record (e.g., 1) - *auto-populated from logged-in user*
+- ≡ƒöä `ServiceTypeId`: Type of service (e.g., 1 - Evaluation/Assessment) - *auto-populated*
+- ≡ƒöä `NonMspServiceTypeId`: NULL for evaluation encounters - *auto-populated*
+- ≡ƒöä `EvaluationTypeId`: Type of evaluation (e.g., 1) - *auto-populated*
+- ≡ƒöä `EncounterDate`: NULL initially - *auto-populated*
+- ≡ƒöä `EncounterStartTime`: NULL initially - *auto-populated*
+- ≡ƒöä `EncounterEndTime`: NULL initially - *auto-populated*
+- ≡ƒöä `IsGroup`: Boolean flag indicating if this is a group encounter (false/0) - *auto-populated*
+- ≡ƒöä `AdditionalStudents`: Number of additional students (0) - *auto-populated*
+- ≡ƒöä `FromSchedule`: Boolean flag indicating if created from schedule (false/0) - *auto-populated*
+- ≡ƒöä `DiagnosisCodeId`: NULL initially - *auto-populated*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: NULL for new records - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: NULL for new records - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created Encounter ID using `scope_identity()`
+- This initial record is created automatically when navigating to the create evaluation encounter page
+- No user input is required at this stage - all fields are populated automatically by the system
+- The encounter is linked to the specific provider
+- Date and time fields are left NULL initially, to be populated later
+- The ServiceTypeId of 1 indicates this is an Evaluation/Assessment type encounter
+- The EvaluationTypeId of 1 appears to be a default value
+- This is the first step in creating an evaluation encounter
+
+#### 4A.2 Update Evaluation Encounter with Date, Time, and Diagnosis
+```sql
+UPDATE [dbo].[Encounters]
+SET [EncounterDate] = @EncounterDate, 
+    [EncounterStartTime] = @EncounterStartTime, 
+    [EncounterEndTime] = @EncounterEndTime, 
+    [DiagnosisCodeId] = @DiagnosisCodeId, 
+    [ModifiedById] = @ModifiedById, 
+    [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöñ `EncounterDate`: Date of the encounter (e.g., '2025-03-27') - *manually entered*
+- ≡ƒöñ `EncounterStartTime`: Start time of the encounter (e.g., '17:00:00') - *manually entered*
+- ≡ƒöñ `EncounterEndTime`: End time of the encounter (e.g., '17:30:00') - *manually entered*
+- ≡ƒöì `DiagnosisCodeId`: Foreign key reference to diagnosis code (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the Encounter to update (e.g., 18) - *auto-populated*
+
+**Notes:**
+- This update occurs when the user enters the basic encounter details in the UI
+- The initially NULL date and time fields are now populated with user-specified values
+- This establishes the timeframe for the evaluation encounter (date, start and end times)
+- The DiagnosisCodeId is selected from a dropdown menu in the UI
+- The record is marked as modified with the current user's ID and timestamp
+- This is a key step in setting up the evaluation encounter with its basic details
+
+### 5. Encounter Student Record Creation
+
+#### 5.1 Create Encounter Student Record
+```sql
+INSERT [dbo].[EncounterStudents]([EncounterId], [StudentId], [EncounterStatusId], [EncounterLocationId], [CaseLoadId], [EncounterStartTime], [EncounterEndTime], [EncounterDate], [IsTelehealth], [ReasonForReturn], [EncounterNumber], [StudentTherapyScheduleId], [SupervisorComments], [ESignatureText], [ESignedById], [DateESigned], [ESignedFromIp], [CPTCodeId], [DiagnosisCodeId], [Medicaid], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@EncounterId, @StudentId, @EncounterStatusId, @EncounterLocationId, @CaseLoadId, @EncounterStartTime, @EncounterEndTime, @EncounterDate, @IsTelehealth, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterId`: Foreign key reference to the Encounter record created in step 4.1 (e.g., 9) - *auto-populated*
+- ≡ƒöä `StudentId`: Foreign key reference to the Student record created in step 1.2 (e.g., 2) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: Foreign key reference to the encounter status (e.g., 26 - Draft) - *auto-populated*
+- ≡ƒöì `EncounterLocationId`: Foreign key reference to the encounter location (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `CaseLoadId`: Foreign key reference to the CaseLoad record created in step 2.1 (e.g., 2) - *auto-populated*
+- ≡ƒöä `EncounterStartTime`: Start time of the encounter (e.g., '16:00:00') - *auto-populated*
+- ≡ƒöä `EncounterEndTime`: End time of the encounter (e.g., '16:30:00') - *auto-populated*
+- ≡ƒöä `EncounterDate`: Date of the encounter (e.g., '2025-03-21') - *auto-populated*
+- ≡ƒöä `IsTelehealth`: Boolean flag indicating if this is a telehealth session (false/0) - *auto-populated*
+- ≡ƒöä `ReasonForReturn`: Reason for returning (NULL in this example) - *not entered*
+- ≡ƒöä `EncounterNumber`: Encounter number (NULL in this example) - *not entered*
+- ≡ƒöä `StudentTherapyScheduleId`: Schedule ID (NULL in this example) - *not entered*
+- ≡ƒöä `SupervisorComments`: Comments from supervisor (NULL in this example) - *not entered*
+- ≡ƒöä `ESignatureText`: Electronic signature text (NULL at this stage) - *not entered*
+- ≡ƒöä `ESignedById`: User ID who e-signed (NULL at this stage) - *not entered*
+- ≡ƒöä `DateESigned`: Timestamp of e-signing (NULL at this stage) - *not entered*
+- ≡ƒöä `ESignedFromIp`: IP address from which e-signing was done (NULL at this stage) - *not entered*
+- ≡ƒöä `CPTCodeId`: CPT code ID (NULL in this example) - *not entered*
+- ≡ƒöä `DiagnosisCodeId`: Diagnosis code ID (NULL in this example) - *not entered*
+- ≡ƒöä `Medicaid`: Medicaid flag (NULL in this example) - *not entered*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudent ID using `scope_identity()`
+- This record links a specific student to the encounter
+- It is set with a default status of "Draft" (EncounterStatusId = 26)
+- Most fields related to e-signatures are NULL at this stage
+- Date and time values are copied from the parent Encounter record
+- The location needs to be selected from a dropdown by the user
+- This record will be updated multiple times during the encounter creation and e-signing process
+
+#### 5.2 Create Encounter Student Goal Record
+```sql
+INSERT [dbo].[EncounterStudentGoals]([EncounterStudentId], [GoalId], [ServiceOutcomes], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified], [NursingResponseNote], [NursingResultNote], [NursingGoalResultId], [CaseLoadScriptGoalId])
+VALUES (@EncounterStudentId, @GoalId, NULL, @Archived, @CreatedById, NULL, @DateCreated, NULL, NULL, NULL, NULL, @CaseLoadScriptGoalId)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record created in step 5.1 (e.g., 3) - *auto-populated*
+- ≡ƒöä `GoalId`: Foreign key reference to a predefined goal (e.g., 1) - *auto-populated*
+- ≡ƒöä `ServiceOutcomes`: Outcomes of the service (NULL in this example) - *not entered*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+- ≡ƒöä `NursingResponseNote`: Notes about nursing response (NULL in this example) - *not entered*
+- ≡ƒöä `NursingResultNote`: Notes about nursing results (NULL in this example) - *not entered*
+- ≡ƒöä `NursingGoalResultId`: Result identifier (NULL in this example) - *not entered*
+- ≡ƒöä `CaseLoadScriptGoalId`: Foreign key reference to the CaseLoadScriptGoal created in step 3.2 (e.g., 2) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentGoal ID using `scope_identity()`
+- This record is created automatically with no user input required
+- It links goals from the case load script to the specific encounter based on previously created relationships
+- For nursing providers, this automatically tracks which care goals were addressed in the encounter
+- The record links back to the CaseLoadScriptGoal created earlier in the process
+- Many fields are initially NULL but will be populated later with outcome information
+- This enables tracking of goal progress across multiple encounters
+- Multiple goals can be automatically added to a single encounter based on the case load script goals
+
+#### 5.3 Update Encounter Student with Encounter Number
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [EncounterNumber] = @EncounterNumber
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `EncounterNumber`: Unique identifier for the encounter (e.g., 'T0010321250003') - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update assigns a unique encounter number to the student's encounter record
+- The number appears to follow a specific format that may include codes for provider, service type, date, etc.
+- This occurs automatically after the encounter details are populated - no user input required
+- The encounter number is used for tracking, reporting, and potentially billing purposes
+- This appears to be the final step in the basic creation of a nursing encounter
+
+#### 5.4 Create Encounter Student Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record created in step 5.1 (e.g., 3) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: Status of the encounter (e.g., 14 - likely a draft or pending status) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record tracks the status history of the encounter
+- The initial status (14) appears to match the EncounterStatusId in the EncounterStudent record
+- This creates an audit trail for status changes throughout the encounter's lifecycle
+- Additional records would be added to this table as the encounter status changes (e.g., from draft to submitted to approved)
+- This is created automatically with no user input required
+- This is the final step in the initial creation of a nursing encounter
+
+### 5A. Evaluation Encounter Student Record Creation
+
+#### 5A.1 Create Evaluation Encounter Student Record
+```sql
+INSERT [dbo].[EncounterStudents](
+    [EncounterId], [StudentId], [EncounterStatusId], [EncounterLocationId], 
+    [CaseLoadId], [EncounterStartTime], [EncounterEndTime], [EncounterDate], 
+    [IsTelehealth], [DiagnosisCodeId], [Archived], [CreatedById], [DateCreated]
+)
+VALUES (
+    @EncounterId, @StudentId, @EncounterStatusId, @EncounterLocationId, 
+    @CaseLoadId, @EncounterStartTime, @EncounterEndTime, @EncounterDate, 
+    @IsTelehealth, @DiagnosisCodeId, @Archived, @CreatedById, @DateCreated
+)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterId`: Foreign key reference to the evaluation Encounter record (e.g., 18) - *auto-populated*
+- ≡ƒöä `StudentId`: Foreign key reference to the Student record (e.g., 2) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: Status of the encounter (e.g., 15 - likely "Draft" or "In Progress") - *auto-populated*
+- ≡ƒöì `EncounterLocationId`: Foreign key reference to the encounter location (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `CaseLoadId`: Foreign key reference to the CaseLoad record (e.g., 2) - *auto-populated*
+- ≡ƒöä `EncounterStartTime`: Start time of the encounter (e.g., '17:00:00') - *auto-populated from parent encounter*
+- ≡ƒöä `EncounterEndTime`: End time of the encounter (e.g., '17:30:00') - *auto-populated from parent encounter*
+- ≡ƒöä `EncounterDate`: Date of the encounter (e.g., '2025-03-27') - *auto-populated from parent encounter*
+- ≡ƒöä `IsTelehealth`: Boolean flag indicating if this is a telehealth session (false/0) - *auto-populated*
+- ≡ƒöä `DiagnosisCodeId`: Foreign key reference to diagnosis code (e.g., 1) - *auto-populated from parent encounter*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudent ID using `scope_identity()`
+- This record links the student to the evaluation encounter
+- The EncounterStatusId of 15 indicates this is in a draft or in-progress state
+- Date and time values are copied from the parent Encounter record
+- The location needs to be selected from a dropdown by the user
+- The DiagnosisCodeId is copied from the parent Encounter record
+- Many fields are left NULL initially (ReasonForReturn, EncounterNumber, SupervisorComments, etc.)
+- These NULL fields will be populated later in the workflow as the evaluation progresses
+
+#### 5A.2 Update Evaluation Encounter Student with Encounter Number
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [EncounterNumber] = @EncounterNumber
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `EncounterNumber`: Unique identifier for the evaluation encounter (e.g., 'E0010327250011') - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 11) - *auto-populated*
+
+**Notes:**
+- This update assigns a unique encounter number to the evaluation encounter student record
+- The number appears to follow a specific format starting with 'E' for evaluation encounters
+- This occurs automatically after the evaluation encounter details are populated - no user input required
+- The encounter number is used for tracking, reporting, and potentially billing purposes
+- This appears to be the final step in the basic creation of an evaluation encounter
+
+#### 5A.3 Create Initial Evaluation Encounter Student Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the evaluation EncounterStudent record (e.g., 11) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: Initial status of the evaluation encounter (e.g., 15 - likely "Draft" or "In Progress") - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record tracks the initial status of the evaluation encounter student record
+- The EncounterStatusId of 15 matches the status set in the EncounterStudent record
+- This creates the first entry in the audit trail for the evaluation encounter's status progression
+- This is the final step in the basic creation of an evaluation encounter
+- The status will be updated as the evaluation progresses through the workflow
+
+### 6. Saving the Encounter with CPT Codes
+
+#### 6.1 Create Encounter Student CPT Code Record
+```sql
+INSERT [dbo].[EncounterStudentCptCodes]([EncounterStudentId], [CptCodeId], [Minutes], [Archived], [CreatedById], [ModifiedById], [DateCreated], [DateModified])
+VALUES (@EncounterStudentId, @CptCodeId, @Minutes, @Archived, @CreatedById, NULL, @DateCreated, NULL)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record created in step 5.1 (e.g., 3) - *auto-populated*
+- ≡ƒöì `CptCodeId`: Foreign key reference to the CPT code (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `Minutes`: Duration in minutes for the CPT code (e.g., 30) - *auto-populated from encounter duration*
+- ≡ƒöä `Archived`: Boolean flag indicating if the record is archived (false/0) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `ModifiedById`: User ID of the person who last modified the record (NULL for new records) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of last modification (NULL for new records) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentCptCode ID using `scope_identity()`
+- Adding a CPT code is required to save the encounter
+- CPT (Current Procedural Terminology) codes are standardized codes used for medical billing
+- The Minutes field is automatically calculated from the difference between encounter start and end times
+- This is an essential step for billing and reimbursement purposes
+- Multiple CPT codes could potentially be added to a single encounter
+
+#### 6.2 Update Encounter Student with Modification Info
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [ModifiedById] = @ModifiedById, [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update occurs immediately after adding the CPT code and saving the encounter
+- It records who modified the encounter student record and when
+- This is part of the encounter finalization process
+- The modification information helps track changes to the encounter over time
+
+### 7. Completing Nursing Goals (Treatment only)
+
+#### 7.1 Update Encounter Student Goal with Outcome Details
+```sql
+UPDATE [dbo].[EncounterStudentGoals]
+SET [ModifiedById] = @ModifiedById, [DateModified] = @DateModified, [NursingResponseNote] = @NursingResponseNote, [NursingResultNote] = @NursingResultNote, [NursingGoalResultId] = @NursingGoalResultId
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+- ≡ƒöñ `NursingResponseNote`: Notes about nursing response (e.g., 'test') - *manually entered*
+- ≡ƒöñ `NursingResultNote`: Notes about nursing results (e.g., 'note') - *manually entered*
+- ≡ƒöñ `NursingGoalResultId`: Result identifier for the nursing goal (e.g., 1) - *manually entered*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudentGoal to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update is required before an encounter can be e-signed/completed
+- It documents the outcomes/results of the nursing intervention related to the goal
+- The nursing goal result (NursingGoalResultId) likely comes from a lookup table of possible outcomes
+- At least one goal must have outcome details entered before the encounter can be finalized
+- This information is essential for documenting the effectiveness of the nursing intervention
+
+### 8. E-Signing/Completing the Encounter
+
+#### 8.1 Update Encounter Student Before Signing
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [ModifiedById] = @ModifiedById, [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update occurs when initiating the e-signing/completion process
+- It updates the modification timestamp just before the signature is applied
+- This is the first of several operations that occur during encounter signing
+- The record is marked as modified with the current user's ID and timestamp
+
+#### 8.2 Create New Encounter Student Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record (e.g., 3) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: New status of the encounter (e.g., 2 - likely "Completed" or "Signed") - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record tracks the change in status from the initial draft/pending status to a completed/signed status
+- The EncounterStatusId of 2 likely represents a completed or signed status (compared to 14 in the initial record)
+- This creates another entry in the audit trail for the encounter's status history
+- This is a key part of the e-signing workflow that indicates the encounter has been reviewed and approved
+
+#### 8.3 Apply E-Signature to Encounter Student Record
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [EncounterStatusId] = @EncounterStatusId, [ESignatureText] = @ESignatureText, [ESignedById] = @ESignedById, [DateESigned] = @DateESigned
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `EncounterStatusId`: New status of the encounter (e.g., 27 - likely "Signed" or "Completed") - *auto-populated*
+- ≡ƒöä `ESignatureText`: The full text of the electronic signature declaration (a legal attestation) - *auto-populated*
+- ≡ƒöä `ESignedById`: User ID of the person electronically signing (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateESigned`: Timestamp when the encounter was electronically signed (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update applies the formal electronic signature to the encounter record
+- The EncounterStatusId changes to 27, which likely represents a signed/completed status
+- The ESignatureText contains a complete legal declaration including the provider's name and credentials
+- The declaration acknowledges that the provider is legally applying their electronic signature
+- This is a critical step that makes the encounter official and legally binding
+- The record captures who signed and when (ESignedById and DateESigned)
+- This creates a permanent record of the provider's attestation of services provided
+
+#### 8.4 Create Final Encounter Student Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record (e.g., 3) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: Final status of the encounter (e.g., 27 - the signed/completed status) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record tracks the final status change to the signed/completed status
+- The EncounterStatusId of 27 matches the status ID set in the EncounterStudent record in step 8.3
+- This completes the audit trail for the encounter's status progression
+- Multiple status records provide a history of how the encounter progressed through the workflow
+- This is part of the final step in completing and signing the encounter
+
+#### 8.5 Final Update to Encounter Student Record
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [ModifiedById] = @ModifiedById, [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1007) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This final update occurs after all e-signing operations are complete
+- It registers the very last modification to the encounter student record
+- This update marks the completion of the entire nursing encounter creation and signing process
+- The timestamp provides the final record of when the encounter was fully processed
+
+## 9. Moving an Encounter to "Ready for Billing" Status
+
+After e-signing, the encounter is in a "Pending Consent" status, which requires additional steps to be completed before it can be billed. These steps are typically performed by a district administrator rather than the provider.
+
+### 9.1 Update Student Parental Consent Record
+
+```sql
+UPDATE [dbo].[StudentParentalConsents]
+SET [ParentalConsentDateEntered] = @ParentalConsentDateEntered, 
+    [ParentalConsentTypeId] = @ParentalConsentTypeId, 
+    [ModifiedById] = @ModifiedById, 
+    [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöñ `ParentalConsentDateEntered`: Date when parental consent was entered (e.g., '2025-03-21 17:02:03.0133333') - *manually entered*
+- ≡ƒöì `ParentalConsentTypeId`: Type of parental consent (e.g., 1) - *selected from UI dropdown*
+- ≡ƒöä `ModifiedById`: User ID of the person who modified the record (e.g., 1006 - district administrator) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the StudentParentalConsent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update is performed by a district administrator, not the provider who created the encounter
+- The initially auto-generated parental consent record is updated with actual consent information
+- The ModifiedById (1006) is different from the CreatedById used in previous operations (1007), indicating different user roles
+- This is a required step to move an encounter from "Pending Consent" status to "Ready for Billing"
+- The ParentalConsentTypeId of 1 likely represents a specific type of consent (e.g., "Written Consent")
+
+### 9.2 Update Encounter Student Status
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [EncounterStatusId] = @EncounterStatusId
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `EncounterStatusId`: New status of the encounter (e.g., 33 - likely "Ready for Billing") - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update occurs after the parental consent has been properly recorded
+- The EncounterStatusId changes from "Pending Consent" to a billing-ready status (33)
+- This is performed by the district administrator after updating the parental consent
+- This status change indicates that the encounter has all the necessary requirements to be billed
+- No signature information or other fields are modified in this operation
+- This is a key step in the revenue cycle management process
+
+### 9.3 Create Final Billing-Ready Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record (e.g., 3) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: New billing-ready status of the encounter (e.g., 33) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1006 - district administrator) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record captures the final status change to "Ready for Billing" in the status history
+- The EncounterStatusId of 33 matches the status just set in the EncounterStudent record in step 9.2
+- This completes the audit trail for the encounter's status progression from Draft ΓåÆ Signed ΓåÆ Pending Consent ΓåÆ Ready for Billing
+- Note that the CreatedById (1006) is the district administrator, not the provider who created the encounter
+- This is the final step required to prepare the encounter for the billing process
+- Once in this status, the encounter should appear in billing reports and be available for claim generation
+
+## 10. Resolving "Missing Medicaid Number" Status
+
+After updating parental consent, the encounter may transition to a "Missing Medicaid Number" status. This status cannot be resolved by a district administrator and requires intervention by a system administrator (an employee of the software company).
+
+### 10.1 Update Student Record with Medicaid Number
+
+```sql
+UPDATE [dbo].[Students]
+SET [MiddleName] = @MiddleName, 
+    [MedicaidNo] = @MedicaidNo, 
+    [DateOfBirth] = @DateOfBirth, 
+    [Notes] = @Notes, 
+    [ModifiedById] = @ModifiedById, 
+    [DateModified] = @DateModified
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöñ `MiddleName`: Student's middle name (empty string in this example) - *manually entered*
+- ≡ƒöñ `MedicaidNo`: Student's Medicaid number (e.g., '098765432109') - *manually entered*
+- ≡ƒöä `DateOfBirth`: Student's birth date (e.g., '2020-03-21') - *auto-populated from existing record*
+- ≡ƒöñ `Notes`: Additional notes (empty string in this example) - *manually entered*
+- ≡ƒöä `ModifiedById`: User ID of the person modifying the record (e.g., 1001 - system administrator) - *auto-populated*
+- ≡ƒöä `DateModified`: Timestamp of modification (current date/time) - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the Student to update (e.g., 2) - *auto-populated*
+
+**Notes:**
+- This update is performed by a system administrator, not the provider or district administrator
+- The key change is adding the MedicaidNo, which is required for billing Medicaid services
+- The ModifiedById (1001) indicates a system administrator role with higher privileges
+- The system verifies the student's DateOfBirth while adding the Medicaid number
+- Adding a Medicaid number is a critical step for Medicaid-billable services
+- This update must be performed by a system administrator with appropriate access rights
+
+### 10.2 Update Encounter Student Status to Ready for Billing
+```sql
+UPDATE [dbo].[EncounterStudents]
+SET [EncounterStatusId] = @EncounterStatusId
+WHERE ([Id] = @Id)
+```
+
+**Columns updated:**
+- ≡ƒöä `EncounterStatusId`: New status of the encounter (e.g., 30 - "Ready for Billing") - *auto-populated*
+
+**Where condition:**
+- ≡ƒöä `Id`: The ID of the EncounterStudent to update (e.g., 3) - *auto-populated*
+
+**Notes:**
+- This update occurs after adding the Medicaid number to the student record
+- The EncounterStatusId changes from "Missing Medicaid Number" to "Ready for Billing" (30)
+- This is performed by the system administrator after adding the required Medicaid information
+- This status change indicates that the encounter now has all the necessary information for billing
+- This update is key for moving the encounter into the final billing workflow
+- Status ID 30 appears to be another variant of a billing-ready status, possibly specific to Medicaid billing
+
+### 10.3 Create Final Medicaid Billing-Ready Status Record
+```sql
+INSERT [dbo].[EncounterStudentStatuses]([EncounterStudentId], [EncounterStatusId], [CreatedById], [DateCreated])
+VALUES (@EncounterStudentId, @EncounterStatusId, @CreatedById, @DateCreated)
+```
+
+**Columns populated:**
+- ≡ƒöä `EncounterStudentId`: Foreign key reference to the EncounterStudent record (e.g., 3) - *auto-populated*
+- ≡ƒöä `EncounterStatusId`: The final "Ready for Billing" status (e.g., 30) - *auto-populated*
+- ≡ƒöä `CreatedById`: User ID of the person creating the record (e.g., 1001 - system administrator) - *auto-populated*
+- ≡ƒöä `DateCreated`: Timestamp of creation (current date/time) - *auto-populated*
+
+**Notes:**
+- The operation returns the newly created EncounterStudentStatus ID using `scope_identity()`
+- This record captures the final status change to the Medicaid-specific "Ready for Billing" status
+- The EncounterStatusId of 30 matches the status just set in the EncounterStudent record in step 10.2
+- This creates the final entry in the audit trail for the encounter's status progression
+- The CreatedById (1001) indicates this was done by a system administrator with higher privileges
+- This completes the full workflow of getting a nursing encounter from creation to billing-ready status
+- The encounter has now progressed through multiple statuses: Draft ΓåÆ Signed ΓåÆ Pending Consent ΓåÆ Missing Medicaid Number ΓåÆ Ready for Billing
+- The encounter is now fully prepared for Medicaid billing and claim generation
+- This is the absolute final step in getting a nursing encounter ready for billing
+
+## Observations and Requirements
+- Note that for nursing providers, a case load script is required (unlike some other provider types)
+- The workflow requires creating an address record before creating a student
+- A provider-student relationship must exist before creating case loads and encounters
+- A case load must exist before creating encounters for nursing services
+- The case load must have an associated case load script for nursing providers
+- Encounter creation is a two-step process: first creating a blank encounter, then updating it with details
+- When adding a student to an encounter, the relevant case load must be referenced
+- A CPT code must be added to the encounter to finalize it, which is essential for billing
+- At least one nursing goal must have outcome details completed before the encounter can be e-signed
+
+## Implementation Requirements for EncounterImportService
+Based on the observed database operations, these are the requirements to ensure the import service correctly creates nursing encounters:
+
+1. Ensure proper validation of provider, student, and school/district relationships
+2. Create or verify a provider-student relationship exists before creating case loads
+3. For nursing encounters, ensure a case load with an appropriate service code exists
+4. For nursing encounters, ensure a case load script exists with valid doctor information and dates
+5. When creating encounters, properly link to the appropriate case load in the EncounterStudent record
+6. Maintain proper date/time fields on both the Encounter and EncounterStudent records
+7. Assign appropriate CPT codes with duration information to allow for billing
+8. For completed encounters, provide outcome details for at least one nursing goal 
\ No newline at end of file
diff --git a/src/Model/DataImport/EncounterImportModels.cs b/src/Model/DataImport/EncounterImportModels.cs
new file mode 100644
index 000000000..626f87adf
--- /dev/null
+++ b/src/Model/DataImport/EncounterImportModels.cs
@@ -0,0 +1,402 @@
+using System;
+using CsvHelper.Configuration.Attributes;
+using Newtonsoft.Json;
+
+namespace Model.DataImport
+{
+    /// <summary>
+    /// Represents a student record from a SNAP EMR Student.txt file
+    /// </summary>
+    public class SnapStudent
+    {
+        [Name("StudentId")]
+        public string StudentId { get; set; }
+
+        [Name("StudentLocalId")]
+        public string StudentLocalId { get; set; }
+
+        [Name("StudentStateId")]
+        public string StudentStateId { get; set; }
+
+        [Name("LastName")]
+        public string LastName { get; set; }
+
+        [Name("FirstName")]
+        public string FirstName { get; set; }
+
+        [Name("MiddleName")]
+        public string MiddleName { get; set; }
+
+        [Name("GenderCode")]
+        public string GenderCode { get; set; }
+
+        [Name("DateOfBirth")]
+        public string DateOfBirth { get; set; }
+
+        [Name("MedicaidNumber")]
+        public string MedicaidNumber { get; set; }
+
+        [Name("ParentAuthorization")]
+        public string ParentAuthorization { get; set; }
+
+        [Name("AddressLine1")]
+        public string AddressLine1 { get; set; }
+
+        [Name("AddressLine2")]
+        public string AddressLine2 { get; set; }
+
+        [Name("City")]
+        public string City { get; set; }
+
+        [Name("State")]
+        public string State { get; set; }
+
+        [Name("ZipCode")]
+        public string ZipCode { get; set; }
+
+        [Name("HomePhone")]
+        public string HomePhone { get; set; }
+    }
+
+    /// <summary>
+    /// Represents a service log record from a SNAP EMR ServiceLog.txt file
+    /// </summary>
+    public class SnapServiceLog
+    {
+        [Name("ServiceLogId")]
+        public string ServiceLogId { get; set; }
+
+        [Name("ProviderFirstName")]
+        public string ProviderFirstName { get; set; }
+
+        [Name("ProviderLastName")]
+        public string ProviderLastName { get; set; }
+
+        [Name("ProviderId")]
+        public string ProviderId { get; set; }
+
+        [Name("School")]
+        public string School { get; set; }
+
+        [Name("StudentId")]
+        public string StudentId { get; set; }
+
+        [Name("LogDate")]
+        public string LogDate { get; set; }
+
+        [Name("EntryDescription")]
+        public string EntryDescription { get; set; }
+
+        [Name("EntryComments")]
+        public string EntryComments { get; set; }
+
+        [Name("TimeIn")]
+        public string TimeIn { get; set; }
+
+        [Name("TimeOut")]
+        public string TimeOut { get; set; }
+
+        [Name("DirectTime")]
+        public string DirectTime { get; set; }
+
+        [Name("DiagnosisCode1")]
+        public string DiagnosisCode1 { get; set; }
+
+        [Name("DiagnosisCode2")]
+        public string DiagnosisCode2 { get; set; }
+
+        [Name("PlaceOfServiceCode")]
+        public string PlaceOfServiceCode { get; set; }
+
+        [Name("ProcedureCode")]
+        public string ProcedureCode { get; set; }
+    }
+
+    /// <summary>
+    /// Represents a row in the encounter import CSV file
+    /// </summary>
+    public class EncounterImportRow : ImportRow
+    {
+        // Integration information
+        [Name("ImportSource")]
+        [Optional]
+        public string ImportSource { get; set; }
+
+        // District and School information
+        [Name("DistrictId")]
+        [Optional]
+        public string DistrictId { get; set; }
+
+        [Name("DistrictName")]
+        [Optional]
+        public string DistrictName { get; set; }
+
+        [Name("DistrictCode")]
+        [Optional]
+        public string DistrictCode { get; set; }
+
+        [Name("SchoolId")]
+        [Optional]
+        public string SchoolId { get; set; }
+
+        [Name("SchoolName")]
+        [Optional]
+        public string SchoolName { get; set; }
+
+        // Provider information
+        [Name("ProviderId")]
+        [Optional]
+        public string ProviderId { get; set; }
+
+        [Name("ProviderNPI")]
+        [Optional]
+        public string ProviderNPI { get; set; }
+
+        [Name("ProviderFirstName")]
+        [Optional]
+        public string ProviderFirstName { get; set; }
+
+        [Name("ProviderLastName")]
+        [Optional]
+        public string ProviderLastName { get; set; }
+
+        // Student information
+        [Name("StudentId")]
+        [Optional]
+        public string StudentId { get; set; }
+
+        [Name("StudentCode")]
+        [Optional]
+        public string StudentCode { get; set; }
+
+        [Name("StudentFirstName")]
+        [Optional]
+        public string StudentFirstName { get; set; }
+
+        [Name("StudentMiddleName")]
+        [Optional]
+        public string StudentMiddleName { get; set; }
+
+        [Name("StudentLastName")]
+        [Optional]
+        public string StudentLastName { get; set; }
+
+        [Name("StudentDateOfBirth")]
+        [Optional]
+        public string StudentDateOfBirth { get; set; }
+
+        [Name("StudentGrade")]
+        [Optional]
+        public string StudentGrade { get; set; }
+
+        [Name("StudentMedicaidNo")]
+        [Optional]
+        public string StudentMedicaidNo { get; set; }
+
+        [Name("StudentNotes")]
+        [Optional]
+        public string StudentNotes { get; set; }
+
+        [Name("StudentAddressLine1")]
+        [Optional]
+        public string StudentAddressLine1 { get; set; }
+
+        [Name("StudentAddressLine2")]
+        [Optional]
+        public string StudentAddressLine2 { get; set; }
+
+        [Name("StudentCity")]
+        [Optional]
+        public string StudentCity { get; set; }
+
+        [Name("StudentState")]
+        [Optional]
+        public string StudentState { get; set; }
+
+        [Name("StudentZip")]
+        [Optional]
+        public string StudentZip { get; set; }
+
+        [Name("StudentEnrollmentDate")]
+        [Optional]
+        public string StudentEnrollmentDate { get; set; }
+
+        [Name("StudentTypeId")]
+        [Optional]
+        public string StudentTypeId { get; set; }
+
+        [Name("StudentTypeName")]
+        [Optional]
+        public string StudentTypeName { get; set; }
+
+        // Case Load information
+        [Name("ServiceCodeId")]
+        [Optional]
+        public string ServiceCodeId { get; set; }
+
+        [Name("ServiceCodeName")]
+        [Optional]
+        public string ServiceCodeName { get; set; }
+
+        [Name("CaseLoadDiagnosisCode")]
+        [Optional]
+        public string CaseLoadDiagnosisCode { get; set; }
+
+        [Name("IEPStartDate")]
+        [Optional]
+        public string IEPStartDate { get; set; }
+
+        [Name("IEPEndDate")]
+        [Optional]
+        public string IEPEndDate { get; set; }
+
+        // Prescription/Script information
+        [Name("DoctorFirstName")]
+        [Optional]
+        public string DoctorFirstName { get; set; }
+
+        [Name("DoctorLastName")]
+        [Optional]
+        public string DoctorLastName { get; set; }
+
+        [Name("DoctorNPI")]
+        [Optional]
+        public string DoctorNPI { get; set; }
+
+        [Name("PrescriptionInitiationDate")]
+        [Optional]
+        public string PrescriptionInitiationDate { get; set; }
+
+        [Name("PrescriptionExpirationDate")]
+        [Optional]
+        public string PrescriptionExpirationDate { get; set; }
+
+        [Name("CaseLoadScriptDiagnosisCode")]
+        [Optional]
+        public string CaseLoadScriptDiagnosisCode { get; set; }
+
+        // Encounter data
+        [Name("EncounterDate")]
+        [Optional]
+        public string EncounterDate { get; set; }
+
+        [Name("EncounterStartTime")]
+        [Optional]
+        public string EncounterStartTime { get; set; }
+
+        [Name("EncounterEndTime")]
+        [Optional]
+        public string EncounterEndTime { get; set; }
+
+        [Name("ServiceTypeId")]
+        [Optional]
+        public string ServiceTypeId { get; set; }
+
+        [Name("EvaluationTypeId")]
+        [Optional]
+        public string EvaluationTypeId { get; set; }
+
+        [Name("EncounterDiagnosisCode")]
+        [Optional]
+        public string EncounterDiagnosisCode { get; set; }
+
+        [Name("IsGroup")]
+        [Optional]
+        public string IsGroup { get; set; }
+
+        [Name("AdditionalStudents")]
+        [Optional]
+        public string AdditionalStudents { get; set; }
+
+        // EncounterStudent data
+        [Name("EncounterLocation")]
+        [Optional]
+        public string EncounterLocation { get; set; }
+
+        [Name("StudentStartTime")]
+        [Optional]
+        public string StudentStartTime { get; set; }
+
+        [Name("StudentEndTime")]
+        [Optional]
+        public string StudentEndTime { get; set; }
+
+        [Name("EncounterStudentDate")]
+        [Optional]
+        public string EncounterStudentDate { get; set; }
+
+        [Name("EncounterStudentDiagnosisCode")]
+        [Optional]
+        public string EncounterStudentDiagnosisCode { get; set; }
+
+        [Name("CPTCode")]
+        [Optional]
+        public string CPTCode { get; set; }
+
+        [Name("TherapyCaseNotes")]
+        [Optional]
+        public string TherapyCaseNotes { get; set; }
+
+        [Name("SupervisorComments")]
+        [Optional]
+        public string SupervisorComments { get; set; }
+
+        [Name("IsTelehealth")]
+        [Optional]
+        public string IsTelehealth { get; set; }
+    }
+
+    public class ImportRow
+    {
+        [Name("ValidationErrors")]
+        [Optional]
+        public string ValidationErrors { get; set; }
+    }
+
+    /// <summary>
+    /// Represents a service record from MST (Medical Service Technology)
+    /// </summary>
+    public class MstService
+    {
+        public string Cpt1 { get; set; }
+        public string Cpt1Duration { get; set; }
+        public string Cpt2 { get; set; }
+        public string Cpt2Duration { get; set; }
+        public string Cpt3 { get; set; }
+        public string Cpt3Duration { get; set; }
+        public string District { get; set; }
+        public string GroupNumber { get; set; }
+        public string Icd10 { get; set; }
+        public string Location { get; set; }
+        [JsonProperty("ProviderMSTKey")]
+        public string ProviderMstKey { get; set; }
+        [JsonProperty("ProviderNPI")]
+        public string ProviderNpi { get; set; }
+        public string ProviderFirstName { get; set; }
+        public string ProviderLastName { get; set; }
+        public string ProviderTitle { get; set; }
+        public string ReferralDate { get; set; }
+        [JsonProperty("ReferralTherapistNPI")]
+        public string ReferralTherapistNpi { get; set; }
+        public string ReferralTherapistFirstName { get; set; }
+        public string ReferralTherapistLastName { get; set; }
+        public string ServiceDate { get; set; }
+        public string ServiceType { get; set; }
+        public string SessionEnd { get; set; }
+        [JsonProperty("SessionMSTKey")]
+        public string SessionMstKey { get; set; }
+        public string SessionStart { get; set; }
+        public string StudentDob { get; set; }
+        public string StudentId { get; set; }
+        [JsonProperty("StudentMSTKey")]
+        public string StudentMstKey { get; set; }
+        public string StudentFirstName { get; set; }
+        public string StudentLastName { get; set; }
+        [JsonProperty("TherapistSuperMSTKey")]
+        public string TherapistSuperMstKey { get; set; }
+        [JsonProperty("TherapistSuperNPI")]
+        public string TherapistSuperNpi { get; set; }
+        public string TherapistSuperFirstName { get; set; }
+        public string TherapistSuperLastName { get; set; }
+    }
+} 
\ No newline at end of file
diff --git a/src/Model/Model.csproj b/src/Model/Model.csproj
index ebbdeb03e..45dca5b87 100644
--- a/src/Model/Model.csproj
+++ b/src/Model/Model.csproj
@@ -17,6 +17,7 @@
     <ItemGroup>
         <PackageReference Include="Breckenridge.Model.Full" Version="6.1.0" GeneratePathProperty="true" />
         <PackageReference Include="Newtonsoft.Json" Version="13.0.3" GeneratePathProperty="true" />
+        <PackageReference Include="CsvHelper" Version="31.0.0" />
     </ItemGroup>
 
     <ItemGroup>
diff --git a/src/Service.Test/DataImport/EncounterImportServiceTestBase.cs b/src/Service.Test/DataImport/EncounterImportServiceTestBase.cs
new file mode 100644
index 000000000..992e4a3cd
--- /dev/null
+++ b/src/Service.Test/DataImport/EncounterImportServiceTestBase.cs
@@ -0,0 +1,996 @@
+using System;
+using System.Data.Entity;
+using System.Data.Entity.Validation;
+using BreckServiceBase.Utilities.Interfaces;
+using Microsoft.Extensions.Configuration;
+using Model;
+using Moq;
+using Service.Encounters;
+using Xunit;
+using System.Linq;
+using System.Text;
+using System.Collections.Generic;
+
+namespace Service.DataImport
+{
+    public abstract class EncounterImportServiceTestBase : IDisposable
+    {
+        protected readonly IPrimaryContext Context;
+        protected readonly Mock<IEncounterStudentService> EncounterStudentServiceMock;
+        protected readonly Mock<IEncounterStudentStatusService> EncounterStudentStatusServiceMock;
+        protected readonly EncounterImportService Service;
+        protected readonly DbContextTransaction Transaction;
+
+        // Test data properties
+        protected SchoolDistrict TestDistrict { get; private set; }
+        protected School TestSchool { get; private set; }
+        protected Provider TestProvider { get; private set; }
+        protected Provider TestArchivedProvider { get; private set; }
+        protected Provider TestNonNursingProvider { get; private set; }
+        protected Student TestStudent { get; private set; }
+        protected Student TestArchivedStudent { get; private set; }
+        protected Student TestArchivedSchoolStudent { get; private set; }
+        protected CaseLoad TestCaseLoad { get; private set; }
+        protected CptCode TestCptCode { get; private set; }
+
+        public EncounterImportServiceTestBase()
+        {
+            // Create configuration for database connection
+            var configuration = new ConfigurationBuilder()
+                .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
+                .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
+                .AddEnvironmentVariables()
+                .Build();
+
+            // Initialize the database context with the configuration
+            Context = new PrimaryContext(configuration);
+
+            // Initialize mock services
+            EncounterStudentServiceMock = new Mock<IEncounterStudentService>();
+            EncounterStudentStatusServiceMock = new Mock<IEncounterStudentStatusService>();
+
+            // Set up mock behavior
+            EncounterStudentServiceMock
+                .Setup(x => x.GenerateEncounterNumber(
+                    It.IsAny<int>(), 
+                    It.IsAny<EncounterStudent>(), 
+                    It.IsAny<int>()))
+                .Returns((int serviceTypeId, EncounterStudent encounterStudent, int districtId) => encounterStudent);
+
+            EncounterStudentStatusServiceMock
+                .Setup(x => x.CheckEncounterStudentStatus(
+                    It.IsAny<int>(), 
+                    It.IsAny<int>()))
+                .Verifiable();
+
+            // Initialize the service under test
+            Service = new EncounterImportService(Context, EncounterStudentServiceMock.Object, EncounterStudentStatusServiceMock.Object);
+
+            // Begin transaction for test isolation
+            Transaction = Context.Database.BeginTransaction();
+
+            // Set up test data
+            SetupTestData();
+        }
+
+        protected virtual void SetupTestData()
+        {
+            // Create ProviderTitles first since they're referenced by CPT code associations
+            var providerTitles = new[]
+            {
+                new ProviderTitle
+                {
+                    Name = "Test Provider Title",
+                    ServiceCodeId = 5, // Nursing Service
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new ProviderTitle
+                {
+                    Name = "Archived Provider Title",
+                    ServiceCodeId = 5, // Nursing Service
+                    Archived = true,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new ProviderTitle
+                {
+                    Name = "Non-nursing provider title",
+                    ServiceCodeId = 3,
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow   
+                }
+            };
+            Context.ProviderTitles.AddRange(providerTitles);
+            Context.SaveChanges();
+
+            // Create CPT codes
+            var cptCode = new CptCode
+            {
+                Code = "NU",
+                Description = "Nursing Service",
+                Archived = false,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.CptCodes.Add(cptCode);
+            Context.SaveChanges();
+
+            TestCptCode = cptCode;
+
+            // Create CPT code associations
+            var cptCodeAssociations = new[]
+            {
+                new CptCodeAssocation
+                {
+                    CptCodeId = cptCode.Id,
+                    ProviderTitleId = providerTitles[0].Id,
+                    ServiceCodeId = 5,      // Nursing Service
+                    ServiceTypeId = 3,      // Treatment/Therapy
+                    IsGroup = false,
+                    Default = false,
+                    IsTelehealth = false,
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new CptCodeAssocation
+                {
+                    CptCodeId = cptCode.Id,
+                    ProviderTitleId = providerTitles[2].Id,
+                    ServiceCodeId = 3,      // Other Service
+                    ServiceTypeId = 3,      // Treatment/Therapy
+                    IsGroup = false,
+                    Default = false,
+                    IsTelehealth = false,
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                }
+            };
+            Context.CptCodeAssocations.AddRange(cptCodeAssociations);
+            Context.SaveChanges();
+
+            // Create diagnosis codes
+            var diagnosisCode = new DiagnosisCode
+            {
+                Code = "Z71.89",
+                Description = "Other specified counseling",
+                Archived = false,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.DiagnosisCodes.Add(diagnosisCode);
+            Context.SaveChanges();
+
+            // Create diagnosis code associations
+            var diagnosisCodeAssociations = new[]
+            {
+                new DiagnosisCodeAssociation
+                {
+                    DiagnosisCodeId = diagnosisCode.Id,
+                    ServiceCodeId = 5,      // Nursing Service
+                    ServiceTypeId = 3,      // Treatment/Therapy
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new DiagnosisCodeAssociation
+                {
+                    DiagnosisCodeId = diagnosisCode.Id,
+                    ServiceCodeId = 3,      // Other Service
+                    ServiceTypeId = 3,      // Treatment/Therapy
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                }
+            };
+            Context.DiagnosisCodeAssociations.AddRange(diagnosisCodeAssociations);
+            Context.SaveChanges();
+
+            // Create encounter locations
+            var location = new EncounterLocation
+            {
+                Name = "School"
+            };
+            Context.EncounterLocations.Add(location);
+            Context.SaveChanges();
+
+            // Create goals
+            var goal = new Goal
+            {
+                Description = "SNAP Integration",
+                Archived = false,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.Goals.Add(goal);
+            Context.SaveChanges();
+
+            // Create districts
+            var districts = new[]
+            {
+                new SchoolDistrict
+                {
+                    Name = "Test District",
+                    Code = "TD001",
+                    EinNumber = "123456789",  // 9 digits required
+                    IrnNumber = "123456",     // 6 digits required
+                    NpiNumber = "1234567890", // 10 digits required
+                    ProviderNumber = "1234567", // 7 digits required
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    ActiveStatus = true,
+                    ProgressReports = false,
+                    RequireNotesForAllEncountersSent = false,
+                    UseDisabilityCodes = false,
+                    CaseNotesRequired = false,
+                    IepDatesRequired = false
+                },
+                new SchoolDistrict
+                {
+                    Name = "Duplicate District",
+                    Code = "DD001",
+                    EinNumber = "987654321",  // 9 digits required
+                    IrnNumber = "654321",     // 6 digits required
+                    NpiNumber = "0987654321", // 10 digits required
+                    ProviderNumber = "7654321", // 7 digits required
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    ActiveStatus = true,
+                    ProgressReports = false,
+                    RequireNotesForAllEncountersSent = false,
+                    UseDisabilityCodes = false,
+                    CaseNotesRequired = false,
+                    IepDatesRequired = false
+                },
+                new SchoolDistrict
+                {
+                    Name = "Duplicate District",
+                    Code = "DD002",
+                    EinNumber = "111222333",  // 9 digits required
+                    IrnNumber = "111222",     // 6 digits required
+                    NpiNumber = "1112223333", // 10 digits required
+                    ProviderNumber = "1112222", // 7 digits required
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    ActiveStatus = true,
+                    ProgressReports = false,
+                    RequireNotesForAllEncountersSent = false,
+                    UseDisabilityCodes = false,
+                    CaseNotesRequired = false,
+                    IepDatesRequired = false
+                },
+                new SchoolDistrict
+                {
+                    Name = "Archived District",
+                    Code = "AD001",
+                    EinNumber = "333444555",  // 9 digits required
+                    IrnNumber = "333444",     // 6 digits required
+                    NpiNumber = "3334445555", // 10 digits required
+                    ProviderNumber = "3334444", // 7 digits required
+                    Archived = true,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    ActiveStatus = false,
+                    ProgressReports = false,
+                    RequireNotesForAllEncountersSent = false,
+                    UseDisabilityCodes = false,
+                    CaseNotesRequired = false,
+                    IepDatesRequired = false
+                }
+            };
+
+            Context.SchoolDistricts.AddRange(districts);
+            Context.SaveChanges();
+
+            var district = districts[0]; // Keep reference to the first district for later use
+
+            // Create all schools
+            var allSchools = new[]
+            {
+                new School
+                {
+                    Name = "Test School",
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new School
+                {
+                    Name = "Archived School",
+                    Archived = true,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new School
+                {
+                    Name = "Duplicate Name School", // Same name as first school
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new School
+                {
+                    Name = "Duplicate Name School", // Same name as first school
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                }
+            };
+            Context.Schools.AddRange(allSchools);
+            Context.SaveChanges();
+
+            var school = allSchools[0]; // Keep reference to the first school for later use
+
+            // Create all school-district relationships
+            var allSchoolDistrictSchools = new[]
+            {
+                new SchoolDistrictsSchool
+                {
+                    SchoolDistrictId = district.Id,
+                    SchoolId = allSchools[0].Id, // Test School
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new SchoolDistrictsSchool
+                {
+                    SchoolDistrictId = district.Id,
+                    SchoolId = allSchools[1].Id, // Archived School
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new SchoolDistrictsSchool
+                {
+                    SchoolDistrictId = district.Id,
+                    SchoolId = allSchools[2].Id, // Second Test School
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                },
+                new SchoolDistrictsSchool
+                {
+                    SchoolDistrictId = district.Id,
+                    SchoolId = allSchools[3].Id, // Third Test School
+                    Archived = false,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow
+                }
+            };
+            Context.SchoolDistrictsSchools.AddRange(allSchoolDistrictSchools);
+            Context.SaveChanges();
+
+            // Create user role for provider
+            var userRole = new UserRole
+            {
+                Name = "Provider Role",
+                Description = "Provider Role",
+                UserTypeId = 2, // Provider type
+                Archived = false,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.UserRoles.Add(userRole);
+            Context.SaveChanges();
+
+            // Create all auth users in one batch
+            var allAuthUsers = new[]
+            {
+                new AuthUser
+                {
+                    Username = "provider@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "archived.title@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "duplicate.npi1@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "duplicate.npi2@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "john.smith1@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "john.smith2@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                },
+                new AuthUser
+                {
+                    Username = "non-nursing.provider@example.com",
+                    Password = new byte[] { 0 },
+                    Salt = new byte[] { 0 },
+                    ResetKey = new byte[] { 0 },
+                    ResetKeyExpirationUtc = DateTime.UtcNow,
+                    RoleId = userRole.Id,
+                    HasAccess = true,
+                    IsEditable = true,
+                    HasLoggedIn = false
+                }
+            };
+            Context.AuthUsers.AddRange(allAuthUsers);
+            Context.SaveChanges();
+
+            // Create all users in one batch
+            var allUsers = new[]
+            {
+                new User
+                {
+                    FirstName = "Provider",
+                    LastName = "Test",
+                    Email = "provider@example.com",
+                    AuthUserId = allAuthUsers[0].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "Archived",
+                    LastName = "Title",
+                    Email = "archived.title@example.com",
+                    AuthUserId = allAuthUsers[1].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "Duplicate",
+                    LastName = "NPI1",
+                    Email = "duplicate.npi1@example.com",
+                    AuthUserId = allAuthUsers[2].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "Duplicate",
+                    LastName = "NPI2",
+                    Email = "duplicate.npi2@example.com",
+                    AuthUserId = allAuthUsers[3].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "John",
+                    LastName = "Smith",
+                    Email = "john.smith1@example.com",
+                    AuthUserId = allAuthUsers[4].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "John",
+                    LastName = "Smith",
+                    Email = "john.smith2@example.com",
+                    AuthUserId = allAuthUsers[5].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new User
+                {
+                    FirstName = "Non-nursing",
+                    LastName = "Provider",
+                    Email = "non-nursing.provider@example.com",
+                    AuthUserId = allAuthUsers[6].Id,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                }
+            };
+            Context.Users.AddRange(allUsers);
+            Context.SaveChanges();
+
+            // Create all providers in one batch
+            var allProviders = new[]
+            {
+                new Provider
+                {
+                    ProviderUserId = allUsers[0].Id,
+                    TitleId = providerTitles[0].Id,
+                    Npi = "1234567890",
+                    Phone = "(555)-555-5555",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[1].Id,
+                    TitleId = providerTitles[1].Id,
+                    Npi = "0987654321",
+                    Phone = "(555)-555-5556",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[2].Id,
+                    TitleId = providerTitles[0].Id,
+                    Npi = "1112223333",
+                    Phone = "(555)-555-5557",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[3].Id,
+                    TitleId = providerTitles[0].Id,
+                    Npi = "1112223333",
+                    Phone = "(555)-555-5558",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[4].Id,
+                    TitleId = providerTitles[0].Id,
+                    Npi = "2223334444",
+                    Phone = "(555)-555-5559",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[5].Id,
+                    TitleId = providerTitles[0].Id,
+                    Npi = "3334445555",
+                    Phone = "(555)-555-5560",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Provider
+                {
+                    ProviderUserId = allUsers[6].Id,
+                    TitleId = providerTitles[2].Id,
+                    Npi = "4445556666",
+                    Phone = "(555)-555-5561",
+                    ProviderEmploymentTypeId = 1,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                }
+            };
+            Context.Providers.AddRange(allProviders);
+            Context.SaveChanges();
+
+            var provider = allProviders[0];
+            var archivedProvider = allProviders[1];
+            var nonNursingProvider = allProviders[6];
+
+            // Create test address
+            var address = new Address
+            {
+                Address1 = "123 Test St",
+                Address2 = "Apt 4B",
+                City = "Test City",
+                StateCode = "TX",
+                Zip = "12345",
+                CountryCode = "US",
+                Province = "",
+                County = "Test County"
+            };
+            Context.Addresses.Add(address);
+            Context.SaveChanges();
+
+            // Create all students
+            var allStudents = new[]
+            {
+                new Student
+                {
+                    FirstName = "John",
+                    MiddleName = "M",
+                    LastName = "Doe",
+                    StudentCode = "STU001",
+                    MedicaidNo = "MED001234567",
+                    Grade = "10",
+                    DateOfBirth = new DateTime(2008, 1, 1),
+                    Notes = "Test student",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Student
+                {
+                    FirstName = "Archived",
+                    MiddleName = "A",
+                    LastName = "Student",
+                    StudentCode = "STU002",
+                    MedicaidNo = "MED002345678",
+                    Grade = "11",
+                    DateOfBirth = new DateTime(2007, 1, 1),
+                    Notes = "Archived student",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = true
+                },
+                new Student
+                {
+                    FirstName = "Archived",
+                    MiddleName = "S",
+                    LastName = "School",
+                    StudentCode = "STU003",
+                    MedicaidNo = "MED003456789",
+                    Grade = "12",
+                    DateOfBirth = new DateTime(2006, 1, 1),
+                    Notes = "Student in archived school",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[1].Id, // Archived School
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Student
+                {
+                    FirstName = "Duplicate",
+                    MiddleName = "C",
+                    LastName = "Code1",
+                    StudentCode = "STU004", // Same code as next student
+                    MedicaidNo = "MED004567890",
+                    Grade = "9",
+                    DateOfBirth = new DateTime(2009, 1, 1),
+                    Notes = "First student with duplicate code",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Student
+                {
+                    FirstName = "Duplicate",
+                    MiddleName = "C",
+                    LastName = "Code2",
+                    StudentCode = "STU004", // Same code as previous student
+                    MedicaidNo = "MED005678901",
+                    Grade = "9",
+                    DateOfBirth = new DateTime(2009, 1, 1),
+                    Notes = "Second student with duplicate code",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Student
+                {
+                    FirstName = "John", // Same name as next student
+                    MiddleName = "D",
+                    LastName = "Smith",
+                    StudentCode = "STU005",
+                    MedicaidNo = "MED006789012",
+                    Grade = "10",
+                    DateOfBirth = new DateTime(2008, 1, 1),
+                    Notes = "First student with duplicate name",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                },
+                new Student
+                {
+                    FirstName = "John", // Same name as previous student
+                    MiddleName = "D",
+                    LastName = "Smith",
+                    StudentCode = "STU006",
+                    MedicaidNo = "MED007890123",
+                    Grade = "10",
+                    DateOfBirth = new DateTime(2008, 1, 1),
+                    Notes = "Second student with duplicate name",
+                    AddressId = address.Id,
+                    SchoolId = allSchools[0].Id,
+                    DistrictId = district.Id,
+                    EnrollmentDate = DateTime.UtcNow.Date,
+                    CreatedById = 1,
+                    DateCreated = DateTime.UtcNow,
+                    Archived = false
+                }
+            };
+            Context.Students.AddRange(allStudents);
+            Context.SaveChanges();
+
+            var student = allStudents[0]; // Keep reference to the first student for later use
+            var archivedStudent = allStudents[1];
+            var archivedSchoolStudent = allStudents[2];
+
+            // Create provider-student relationship
+            var providerStudent = new ProviderStudent
+            {
+                ProviderId = allProviders[0].Id,
+                StudentId = student.Id,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.ProviderStudents.Add(providerStudent);
+            Context.SaveChanges();
+
+            // Create parental consent
+            var parentalConsent = new StudentParentalConsent
+            {
+                StudentId = student.Id,
+                ParentalConsentEffectiveDate = DateTime.UtcNow.Date,
+                ParentalConsentDateEntered = DateTime.UtcNow.Date,
+                ParentalConsentTypeId = 1,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow
+            };
+            Context.StudentParentalConsents.Add(parentalConsent);
+            Context.SaveChanges();
+
+            // Create case load
+            var caseLoad = new CaseLoad
+            {
+                StudentTypeId = 1, // IEP
+                ServiceCodeId = 5, // Nursing Service
+                StudentId = student.Id,
+                DiagnosisCodeId = diagnosisCode.Id,
+                IepStartDate = DateTime.UtcNow.Date,
+                IepEndDate = DateTime.UtcNow.Date.AddYears(1),
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow,
+                Archived = false
+            };
+            Context.CaseLoads.Add(caseLoad);
+            Context.SaveChanges();
+
+            // Create case load script
+            var caseLoadScript = new CaseLoadScript
+            {
+                CaseLoadId = caseLoad.Id,
+                Npi = "1234567890",
+                DiagnosisCodeId = diagnosisCode.Id,
+                DoctorFirstName = "John",
+                DoctorLastName = "Smith",
+                InitiationDate = DateTime.UtcNow.Date,
+                ExpirationDate = DateTime.UtcNow.Date.AddYears(1),
+                FileName = "test_script.pdf",
+                FilePath = "/test/path/test_script.pdf",
+                UploadedById = 1,
+                DateUpload = DateTime.UtcNow.Date,
+                Archived = false
+            };
+            Context.CaseLoadScripts.Add(caseLoadScript);
+            Context.SaveChanges();
+
+            // Create case load script goal
+            var caseLoadScriptGoal = new CaseLoadScriptGoal
+            {
+                CaseLoadScriptId = caseLoadScript.Id,
+                GoalId = goal.Id,
+                Archived = false,
+                CreatedById = 1,
+                DateCreated = DateTime.UtcNow.Date
+            };
+            Context.CaseLoadScriptGoals.Add(caseLoadScriptGoal);
+            Context.SaveChanges();
+
+            // Load the test data objects with their navigation properties
+            TestDistrict = district;
+            TestSchool = school;
+            TestProvider = Context.Providers
+                .Include(p => p.ProviderUser)
+                .First(p => p.Id == provider.Id);
+            TestArchivedProvider = Context.Providers
+                .Include(p => p.ProviderUser)
+                .First(p => p.Id == archivedProvider.Id);
+            TestNonNursingProvider = Context.Providers
+                .Include(p => p.ProviderUser)
+                .First(p => p.Id == nonNursingProvider.Id);
+            TestStudent = Context.Students
+                .Include(s => s.Address)
+                .First(s => s.Id == student.Id);
+            TestArchivedStudent = Context.Students
+                .Include(s => s.Address)
+                .First(s => s.Id == archivedStudent.Id);
+            TestArchivedSchoolStudent = Context.Students
+                .Include(s => s.Address)
+                .First(s => s.Id == archivedSchoolStudent.Id); // Student in archived school
+            TestCaseLoad = Context.CaseLoads
+                .Include(c => c.ServiceCode)
+                .Include(c => c.DiagnosisCode)
+                .Include(c => c.CaseLoadScripts.Select(cs => cs.DiagnosisCode))
+                .Include(c => c.CaseLoadScripts.Select(cs => cs.CaseLoadScriptGoals))
+                .First(c => c.Id == caseLoad.Id);
+        }
+
+        protected virtual void Setup()
+        {
+            // Additional setup can be done in derived classes
+        }
+
+        protected virtual void Teardown()
+        {
+            // Additional cleanup can be done in derived classes
+        }
+
+        /// <summary>
+        /// Returns a dictionary mapping CSV headers to their valid test values.
+        /// The order matches the GenerateTemplate method's header order.
+        /// </summary>
+        protected Dictionary<string, string> GetValidCsvRowData()
+        {
+            var now = DateTime.UtcNow;
+            var rowData = new Dictionary<string, string>
+            {
+                // Integration information
+                { "ImportSource", "SNAP Integration" },
+                
+                // District and School information
+                { "DistrictId", TestDistrict.Id.ToString() },
+                { "DistrictName", TestDistrict.Name },
+                { "DistrictCode", TestDistrict.Code },
+                { "SchoolId", TestSchool.Id.ToString() },
+                { "SchoolName", TestSchool.Name },
+                
+                // Provider information
+                { "ProviderId", TestProvider.Id.ToString() },
+                { "ProviderNPI", TestProvider.Npi },
+                { "ProviderFirstName", TestProvider.ProviderUser.FirstName },
+                { "ProviderLastName", TestProvider.ProviderUser.LastName },
+                
+                // Student information
+                { "StudentId", TestStudent.Id.ToString() },
+                { "StudentCode", TestStudent.StudentCode },
+                { "StudentFirstName", TestStudent.FirstName },
+                { "StudentMiddleName", TestStudent.MiddleName },
+                { "StudentLastName", TestStudent.LastName },
+                { "StudentDateOfBirth", $"{TestStudent.DateOfBirth:MM/dd/yyyy}" },
+                { "StudentGrade", TestStudent.Grade },
+                { "StudentMedicaidNo", TestStudent.MedicaidNo },
+                { "StudentNotes", TestStudent.Notes },
+                { "StudentAddressLine1", TestStudent.Address.Address1 },
+                { "StudentAddressLine2", TestStudent.Address.Address2 },
+                { "StudentCity", TestStudent.Address.City },
+                { "StudentState", TestStudent.Address.StateCode },
+                { "StudentZip", TestStudent.Address.Zip },
+                { "StudentEnrollmentDate", $"{TestStudent.EnrollmentDate:MM/dd/yyyy}" },
+                { "StudentTypeId", "1" }, // IEP
+                { "StudentTypeName", "IEP" }, // IEP
+                
+                // Case Load information
+                { "ServiceCodeId", TestCaseLoad.ServiceCodeId.ToString() },
+                { "ServiceCodeName", TestCaseLoad.ServiceCode.Name },
+                { "CaseLoadDiagnosisCode", TestCaseLoad.DiagnosisCode.Code },
+                { "IEPStartDate", $"{TestCaseLoad.IepStartDate:MM/dd/yyyy}" },
+                { "IEPEndDate", $"{TestCaseLoad.IepEndDate:MM/dd/yyyy}" },
+                
+                // Prescription/Script information
+                { "DoctorFirstName", TestCaseLoad.CaseLoadScripts.First().DoctorFirstName },
+                { "DoctorLastName", TestCaseLoad.CaseLoadScripts.First().DoctorLastName },
+                { "DoctorNPI", TestCaseLoad.CaseLoadScripts.First().Npi },
+                { "PrescriptionInitiationDate", $"{TestCaseLoad.CaseLoadScripts.First().InitiationDate:MM/dd/yyyy}" },
+                { "PrescriptionExpirationDate", $"{TestCaseLoad.CaseLoadScripts.First().ExpirationDate:MM/dd/yyyy}" },
+                { "CaseLoadScriptDiagnosisCode", TestCaseLoad.CaseLoadScripts.First().DiagnosisCode.Code },
+                
+                // Encounter data
+                { "EncounterDate", $"{now:MM/dd/yyyy}" },
+                { "EncounterStartTime", "09:00" },
+                { "EncounterEndTime", "10:00" },
+                { "ServiceTypeId", "3" }, // Treatment/Therapy
+                { "EvaluationTypeId", null }, // Initial Evaluation
+                { "EncounterDiagnosisCode", TestCaseLoad.DiagnosisCode.Code },
+                { "IsGroup", "false" },
+                { "AdditionalStudents", "0" },
+
+                // EncounterStudent data
+                { "EncounterLocation", "School" },
+                { "StudentStartTime", "09:00" },
+                { "StudentEndTime", "10:00" },
+                { "EncounterStudentDate", $"{now:MM/dd/yyyy}" },
+                { "EncounterStudentDiagnosisCode", TestCaseLoad.DiagnosisCode.Code },
+                { "CPTCode", "NU" },
+                { "TherapyCaseNotes", "Test therapy notes" },
+                { "SupervisorComments", "Test supervisor comments" },
+                { "IsTelehealth", "false" }
+            };
+
+            return rowData;
+        }
+
+        public void Dispose()
+        {
+            // Roll back transaction to ensure test isolation
+            Transaction?.Rollback();
+            
+            // Dispose of resources
+            Transaction?.Dispose();
+            Context?.Dispose();
+        }
+    }
+}
+
diff --git a/src/Service.Test/DataImport/EncounterImportServiceTests.cs b/src/Service.Test/DataImport/EncounterImportServiceTests.cs
new file mode 100644
index 000000000..e0c011895
--- /dev/null
+++ b/src/Service.Test/DataImport/EncounterImportServiceTests.cs
@@ -0,0 +1,3942 @@
+using System;
+using System.Collections.Generic;
+using System.Data.Entity;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using BreckServiceBase.Utilities.Interfaces;
+using Model;
+using Moq;
+using Service.Encounters;
+using Xunit;
+using CsvHelper;
+using System.Globalization;
+using System.IO;
+using Model.DataImport;
+
+namespace Service.DataImport;
+
+public class EncounterImportServiceTests : EncounterImportServiceTestBase
+{
+    [Fact]
+    public void EncounterImportService_ShouldHaveCorrectImportType()
+    {
+        // Act & Assert - use the Service instance from the base class
+        Assert.Equal("encounters", Service.ImportType);
+    }
+
+    [Fact]
+    public void GenerateEncounterTemplate_ShouldReturnValidCsvBytes()
+    {
+        // Act - use the Service instance from the base class
+        var templateBytes = Service.GenerateTemplate();
+
+        // Assert
+        Assert.NotNull(templateBytes);
+        Assert.True(templateBytes.Length > 0);
+
+        // Convert bytes back to string using UTF-8 encoding
+        var templateString = Encoding.UTF8.GetString(templateBytes);
+
+        // Verify the template is not empty
+        Assert.False(string.IsNullOrWhiteSpace(templateString));
+
+        // Split the file into lines
+        var lines = templateString.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+
+        // Verify we have at least 3 lines (legend + 2 example rows)
+        Assert.True(lines.Length >= 3, $"Expected at least 3 lines, but found {lines.Length}");
+
+        // Get the headers from the first row
+        var actualHeaders = lines[0].Split(',').Select(h => h.Trim('"')).ToList();
+
+        // Verify all required headers are present
+        AssertHeadersInclude(actualHeaders, "ImportSource");
+        
+        // District and School information
+        AssertHeadersInclude(actualHeaders, "DistrictId", "DistrictName", "DistrictCode", "SchoolId", "SchoolName");
+        
+        // Provider information
+        AssertHeadersInclude(actualHeaders, "ProviderId", "ProviderNPI", "ProviderFirstName", "ProviderLastName");
+        
+        // Student information
+        AssertHeadersInclude(actualHeaders, "StudentId", "StudentCode", "StudentFirstName", "StudentMiddleName", 
+            "StudentLastName", "StudentDateOfBirth", "StudentGrade", "StudentMedicaidNo");
+        
+        // Address fields
+        AssertHeadersInclude(actualHeaders, "StudentAddressLine1", "StudentAddressLine2", "StudentCity", 
+            "StudentState", "StudentZip");
+        
+        // Case Load information
+        AssertHeadersInclude(actualHeaders, "ServiceCodeId", "ServiceCodeName", "CaseLoadDiagnosisCode", 
+            "IEPStartDate", "IEPEndDate");
+        
+        // Prescription/Script information
+        AssertHeadersInclude(actualHeaders, "DoctorFirstName", "DoctorLastName", "DoctorNPI", 
+            "PrescriptionInitiationDate", "PrescriptionExpirationDate", "CaseLoadScriptDiagnosisCode");
+        
+        // Encounter data
+        AssertHeadersInclude(actualHeaders, "EncounterDate", "EncounterStartTime", "EncounterEndTime", 
+            "ServiceTypeId", "EvaluationTypeId", "EncounterDiagnosisCode", "IsGroup", "AdditionalStudents");
+        
+        // EncounterStudent data
+        AssertHeadersInclude(actualHeaders, "EncounterLocation", "StudentStartTime", "StudentEndTime", 
+            "EncounterStudentDate", "EncounterStudentDiagnosisCode", "CPTCode", "TherapyCaseNotes", 
+            "SupervisorComments", "IsTelehealth");
+        
+        // Validation field
+        AssertHeadersInclude(actualHeaders, "ValidationErrors");
+
+        // Verify that the second line contains legend values
+        using var memoryStream = new MemoryStream(templateBytes);
+        using var reader = new StreamReader(memoryStream);
+        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
+        
+        // Skip header row
+        csv.Read();
+        csv.ReadHeader();
+        
+        // Read legend row
+        csv.Read();
+        var legendRow = csv.GetRecord<EncounterImportRow>();
+        
+        Assert.Contains("Source of the import data", legendRow.ImportSource);
+        Assert.Contains("REQUIRED", legendRow.DistrictId);
+        
+        // Verify that the example rows have valid sample data
+        csv.Read();
+        var exampleRow1 = csv.GetRecord<EncounterImportRow>();
+        Assert.Equal("MST Integration", exampleRow1.ImportSource);
+        Assert.Equal("Sample District", exampleRow1.DistrictName);
+        
+        if (csv.Read())
+        {
+            var exampleRow2 = csv.GetRecord<EncounterImportRow>();
+            Assert.Equal("MST Integration", exampleRow2.ImportSource);
+            Assert.Equal("true", exampleRow2.IsGroup);
+        }
+    }
+
+    private void AssertHeadersInclude(List<string> actualHeaders, params string[] expectedHeaders)
+    {
+        foreach (var header in expectedHeaders)
+        {
+            Assert.Contains(header, actualHeaders);
+        }
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidData_ShouldCreateEncounter()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data
+        var rowData = GetValidCsvRowData();
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows", result.Message);
+
+        // Verify encounter was created
+        var createdEncounter = Context.Encounters
+            .Include(e => e.EncounterStudents)
+            .FirstOrDefault(e => e.ProviderId == TestProvider.Id && e.EncounterDate.HasValue && 
+                e.EncounterDate.Value.Year == DateTime.UtcNow.Year &&
+                e.EncounterDate.Value.Month == DateTime.UtcNow.Month &&
+                e.EncounterDate.Value.Day == DateTime.UtcNow.Day);
+
+        Assert.NotNull(createdEncounter);
+        Assert.Equal(TestProvider.Id, createdEncounter.ProviderId);
+        Assert.Equal(3, createdEncounter.ServiceTypeId); // Treatment/Therapy
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounter.DiagnosisCodeId);
+        Assert.False(createdEncounter.IsGroup);
+        Assert.Equal(0, createdEncounter.AdditionalStudents);
+
+        // Verify encounter student was created
+        var createdEncounterStudent = createdEncounter.EncounterStudents.FirstOrDefault();
+        Assert.NotNull(createdEncounterStudent);
+        Assert.Equal(TestStudent.Id, createdEncounterStudent.StudentId);
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounterStudent.DiagnosisCodeId);
+        Assert.Equal("Test therapy notes", createdEncounterStudent.TherapyCaseNotes);
+        Assert.Equal("Test supervisor comments", createdEncounterStudent.SupervisorComments);
+        Assert.False(createdEncounterStudent.IsTelehealth);
+
+        // Verify CPT code was associated
+        var cptCodeAssociation = Context.EncounterStudentCptCodes
+            .FirstOrDefault(esc => esc.EncounterStudentId == createdEncounterStudent.Id);
+        Assert.NotNull(cptCodeAssociation);
+        Assert.Equal(TestCptCode.Id, cptCodeAssociation.CptCodeId); // Use the actual test CPT code ID
+        Assert.Equal(60, cptCodeAssociation.Minutes); // 1 hour duration
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithEmptyFile_ShouldReturnError()
+    {
+        // Arrange
+        var emptyFileContent = new byte[] { }; // Empty byte array
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(emptyFileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail for empty file");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Equal("No data rows found in the import file.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMissingImportSource_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove ImportSource
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ImportSource");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when ImportSource is missing");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("ImportSource is required to determine the appropriate goal for the case load script.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidImportSource_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set ImportSource to a non-existent goal
+        var rowData = GetValidCsvRowData();
+        rowData["ImportSource"] = "NonExistentGoal";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when ImportSource doesn't match any goal");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("No matching goal found for ImportSource 'NonExistentGoal'", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidDistrictId_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set DistrictId to a non-existent ID
+        var rowData = GetValidCsvRowData();
+        rowData["DistrictId"] = "999999"; // Use a non-existent district ID
+        rowData.Remove("DistrictName"); // Remove DistrictName to force using DistrictId
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when DistrictId doesn't match any district");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("District with ID 999999 not found or is archived", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidDistrictIdFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set DistrictId to an invalid format
+        var rowData = GetValidCsvRowData();
+        rowData["DistrictId"] = "not-a-number"; // Use an invalid format for DistrictId
+        rowData.Remove("DistrictName"); // Remove DistrictName to force using DistrictId
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when DistrictId is in invalid format");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Invalid District ID format: not-a-number", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithSingleDistrictByName_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use DistrictName instead of DistrictId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("DistrictId"); // Remove DistrictId to force using DistrictName
+        rowData["DistrictName"] = TestDistrict.Name; // Use the name of our test district
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when a single district is found by name");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Equal("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMultipleDistrictsWithSameName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set DistrictName to match multiple districts
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("DistrictId"); // Remove DistrictId to force using DistrictName
+        rowData["DistrictName"] = "Duplicate District"; // Use the name that matches multiple districts in test data
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when multiple districts match the name");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Multiple districts found with name 'Duplicate District'. Please specify a district ID.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithArchivedDistrictName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set DistrictName to an archived district
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("DistrictId"); // Remove DistrictId to force using DistrictName
+        rowData["DistrictName"] = "Archived District"; // Use the name of the archived district from test data
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when district is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Equal("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("District with name 'Archived District' not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoDistrictIdentifier_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove both DistrictId and DistrictName
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("DistrictId");
+        rowData.Remove("DistrictName");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when no district identifier is provided");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Equal("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("District could not be identified. Please provide a valid District ID or District Name.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithArchivedProviderTitle_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set ProviderId to the provider with archived title
+        var rowData = GetValidCsvRowData();
+        rowData["ProviderId"] = TestArchivedProvider.Id.ToString(); // Use the provider with archived title
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when provider's title is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Equal("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Provider (ID: " + TestArchivedProvider.Id + ") has a title that is archived or not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonexistentProvider_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set ProviderId to a non-existent ID
+        var rowData = GetValidCsvRowData();
+        rowData["ProviderId"] = "999999"; // Use a non-existent provider ID
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when provider is not found");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Provider with ID 999999 not found or is archived", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidProviderIdFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set ProviderId to an invalid format
+        var rowData = GetValidCsvRowData();
+        rowData["ProviderId"] = "not-a-number"; // Use an invalid format for ProviderId
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when Provider ID format is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Invalid Provider ID format: not-a-number", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithSingleProviderByNPI_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use ProviderNPI instead of ProviderId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId"); // Remove ProviderId to force using ProviderNPI
+        rowData["ProviderNPI"] = TestProvider.Npi; // Use the NPI of our test provider
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when a single provider is found by NPI");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Equal("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMultipleProvidersWithSameNPI_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use ProviderNPI that matches multiple providers
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId"); // Remove ProviderId to force using ProviderNPI
+        rowData["ProviderNPI"] = "1112223333"; // Use the NPI that matches multiple providers in test data
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when multiple providers match the NPI");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Multiple providers found with NPI '1112223333'. Please specify a provider ID.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonexistentProviderNPI_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent ProviderNPI
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId"); // Remove ProviderId to force using ProviderNPI
+        rowData["ProviderNPI"] = "9999999999"; // Use a non-existent NPI
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when provider with NPI is not found");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Provider with NPI '9999999999' not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonexistentProviderName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use ProviderFirstName and ProviderLastName instead of ProviderId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId"); // Remove ProviderId to force using name
+        rowData.Remove("ProviderNPI"); // Remove ProviderNPI to force using name
+        rowData["ProviderFirstName"] = "Nonexistent"; // Use a non-existent first name
+        rowData["ProviderLastName"] = "Provider"; // Use a non-existent last name
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when no provider is found with the given name");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("No provider found with name 'Nonexistent Provider'.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMultipleProvidersWithSameName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use ProviderFirstName and ProviderLastName instead of ProviderId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId"); // Remove ProviderId to force using name
+        rowData.Remove("ProviderNPI"); // Remove ProviderNPI to force using name
+        rowData["ProviderFirstName"] = "John"; // Use the first name that matches multiple providers
+        rowData["ProviderLastName"] = "Smith"; // Use the last name that matches multiple providers
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when multiple providers match the name");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Multiple providers found with name 'John Smith'. Please specify a Provider ID or NPI.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoProviderInformation_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove all provider-related fields
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("ProviderId");
+        rowData.Remove("ProviderNPI");
+        rowData.Remove("ProviderFirstName");
+        rowData.Remove("ProviderLastName");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when no provider information is provided");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Provider information is required. Please provide a Provider ID NPI or Name.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentInArchivedSchool_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a student that is in an archived school
+        var rowData = GetValidCsvRowData();
+        rowData["StudentId"] = TestArchivedSchoolStudent.Id.ToString();
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student is in an archived school");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal($"Student (ID: {TestArchivedSchoolStudent.Id}) has a school that is archived or not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithArchivedStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an archived student ID
+        var rowData = GetValidCsvRowData();
+        rowData["StudentId"] = TestArchivedStudent.Id.ToString(); // Use the ID of the archived student from test data
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal($"Student with ID {TestArchivedStudent.Id} not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidStudentIdFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set StudentId to an invalid format
+        var rowData = GetValidCsvRowData();
+        rowData["StudentId"] = "not-a-number"; // Use an invalid format for StudentId
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when Student ID format is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Invalid Student ID format: not-a-number", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentFoundByCodeAndValidSchool_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use StudentCode instead of StudentId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using StudentCode
+        rowData["StudentCode"] = TestStudent.StudentCode; // Use the code of our test student
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when student is found by code and has a valid school");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Equal("Import completed with 1 successful rows and 0 error rows.", result.Message);
+
+        // Verify encounter was created
+        var createdEncounter = Context.Encounters
+            .Include(e => e.EncounterStudents)
+            .FirstOrDefault(e => e.ProviderId == TestProvider.Id && e.EncounterDate.HasValue && 
+                e.EncounterDate.Value.Year == DateTime.UtcNow.Year &&
+                e.EncounterDate.Value.Month == DateTime.UtcNow.Month &&
+                e.EncounterDate.Value.Day == DateTime.UtcNow.Day);
+
+        Assert.NotNull(createdEncounter);
+        Assert.Equal(TestProvider.Id, createdEncounter.ProviderId);
+        Assert.Equal(3, createdEncounter.ServiceTypeId); // Treatment/Therapy
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounter.DiagnosisCodeId);
+        Assert.False(createdEncounter.IsGroup);
+        Assert.Equal(0, createdEncounter.AdditionalStudents);
+
+        // Verify encounter student was created
+        var createdEncounterStudent = createdEncounter.EncounterStudents.FirstOrDefault();
+        Assert.NotNull(createdEncounterStudent);
+        Assert.Equal(TestStudent.Id, createdEncounterStudent.StudentId);
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounterStudent.DiagnosisCodeId);
+        Assert.Equal("Test therapy notes", createdEncounterStudent.TherapyCaseNotes);
+        Assert.Equal("Test supervisor comments", createdEncounterStudent.SupervisorComments);
+        Assert.False(createdEncounterStudent.IsTelehealth);
+
+        // Verify CPT code was associated
+        var cptCodeAssociation = Context.EncounterStudentCptCodes
+            .FirstOrDefault(esc => esc.EncounterStudentId == createdEncounterStudent.Id);
+        Assert.NotNull(cptCodeAssociation);
+        Assert.Equal(TestCptCode.Id, cptCodeAssociation.CptCodeId);
+        Assert.Equal(60, cptCodeAssociation.Minutes); // 1 hour duration
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentFoundByCodeButArchivedSchool_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use StudentCode instead of StudentId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using StudentCode
+        rowData["StudentCode"] = TestArchivedSchoolStudent.StudentCode; // Use the code of the student with archived school
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student's school is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal($"Student (ID: {TestArchivedSchoolStudent.Id}) has a school that is archived or not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithDuplicateStudentCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use StudentCode instead of StudentId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using StudentCode
+        rowData["StudentCode"] = "STU004"; // Use the code that matches multiple students
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student code matches multiple students");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Multiple students found with code 'STU004'. Please specify a student ID.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentFoundByNameAndDOB_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use name and DOB instead of StudentId
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = TestStudent.FirstName;
+        rowData["StudentLastName"] = TestStudent.LastName;
+        rowData["StudentDateOfBirth"] = $"{TestStudent.DateOfBirth:MM/dd/yyyy}";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when student is found by name and DOB");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Equal("Import completed with 1 successful rows and 0 error rows.", result.Message);
+
+        // Verify encounter was created
+        var createdEncounter = Context.Encounters
+            .Include(e => e.EncounterStudents)
+            .FirstOrDefault(e => e.ProviderId == TestProvider.Id && e.EncounterDate.HasValue && 
+                e.EncounterDate.Value.Year == DateTime.UtcNow.Year &&
+                e.EncounterDate.Value.Month == DateTime.UtcNow.Month &&
+                e.EncounterDate.Value.Day == DateTime.UtcNow.Day);
+
+        Assert.NotNull(createdEncounter);
+        Assert.Equal(TestProvider.Id, createdEncounter.ProviderId);
+        Assert.Equal(3, createdEncounter.ServiceTypeId); // Treatment/Therapy
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounter.DiagnosisCodeId);
+        Assert.False(createdEncounter.IsGroup);
+        Assert.Equal(0, createdEncounter.AdditionalStudents);
+
+        // Verify encounter student was created
+        var createdEncounterStudent = createdEncounter.EncounterStudents.FirstOrDefault();
+        Assert.NotNull(createdEncounterStudent);
+        Assert.Equal(TestStudent.Id, createdEncounterStudent.StudentId);
+        Assert.Equal(TestCaseLoad.DiagnosisCodeId, createdEncounterStudent.DiagnosisCodeId);
+        Assert.Equal("Test therapy notes", createdEncounterStudent.TherapyCaseNotes);
+        Assert.Equal("Test supervisor comments", createdEncounterStudent.SupervisorComments);
+        Assert.False(createdEncounterStudent.IsTelehealth);
+
+        // Verify CPT code was associated
+        var cptCodeAssociation = Context.EncounterStudentCptCodes
+            .FirstOrDefault(esc => esc.EncounterStudentId == createdEncounterStudent.Id);
+        Assert.NotNull(cptCodeAssociation);
+        Assert.Equal(TestCptCode.Id, cptCodeAssociation.CptCodeId);
+        Assert.Equal(60, cptCodeAssociation.Minutes); // 1 hour duration
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentFoundByNameAndDOBButArchivedSchool_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use name and DOB of student with archived school
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = TestArchivedSchoolStudent.FirstName;
+        rowData["StudentLastName"] = TestArchivedSchoolStudent.LastName;
+        rowData["StudentDateOfBirth"] = TestArchivedSchoolStudent.DateOfBirth.ToString("MM/dd/yyyy");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student's school is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal($"Student (ID: {TestArchivedSchoolStudent.Id}) has a school that is archived or not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMultipleStudentsFoundByNameAndDOB_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use name and DOB that matches multiple students
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "John"; // Use the first name that matches multiple students
+        rowData["StudentLastName"] = "Smith"; // Use the last name that matches multiple students
+        rowData["StudentDateOfBirth"] = "01/01/2008"; // Use the DOB that matches multiple students
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when multiple students match name and DOB");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Multiple students found with name 'John Smith' and DOB '01/01/2008'. Please specify a student ID or code.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentNotFoundByNameAndDOB_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student name and DOB
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "Nonexistent";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student is not found by name and DOB");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Student with name 'Nonexistent Student' and DOB '01/01/2000' not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidStudentDateOfBirthFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set StudentDateOfBirth to an invalid format
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentDateOfBirth"] = "not-a-date"; // Use an invalid date format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when StudentDateOfBirth is in invalid format");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Invalid date format for Student Date of Birth: not-a-date", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoStudentIdentifier_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove all student identifiers
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId
+        rowData.Remove("StudentCode"); // Remove StudentCode
+        rowData.Remove("StudentFirstName"); // Remove StudentFirstName
+        rowData.Remove("StudentLastName"); // Remove StudentLastName
+        rowData.Remove("StudentDateOfBirth"); // Remove StudentDateOfBirth
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, false, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when no student identifier is provided");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Student could not be identified. Please provide a valid Student ID Student Code or Name with Date of Birth.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoMatchingStudentButValidSchool_ShouldFindSchool()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student name and DOB
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "Nonexistent";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when no matching student is found but school is valid and createMissingStudentRecords is true");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows", result.Message);
+
+        // Parse the date before using it in the query
+        var expectedDateOfBirth = DateTime.Parse("01/01/2000");
+
+        // Verify a new student was created with the correct school
+        var createdStudent = Context.Students
+            .FirstOrDefault(s => s.FirstName == "Nonexistent" && 
+                               s.LastName == "Student" && 
+                               s.DateOfBirth == expectedDateOfBirth);
+
+        Assert.NotNull(createdStudent);
+        Assert.Equal(TestSchool.Id, createdStudent.SchoolId);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidSchoolIdWhenCreatingMissingStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set SchoolId to a non-existent ID and use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData["SchoolId"] = "99999"; // Use a non-existent school ID
+        rowData.Remove("SchoolName"); // Remove SchoolName to force using SchoolId
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when SchoolId doesn't match any school while creating missing student");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("School with ID 99999 not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidSchoolIdFormatWhenCreatingMissingStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set SchoolId to an invalid format and use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData["SchoolId"] = "not-a-number"; // Use an invalid format for SchoolId
+        rowData.Remove("SchoolName"); // Remove SchoolName to force using SchoolId
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when SchoolId format is invalid while creating missing student");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("Invalid School ID format: not-a-number", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithSingleSchoolInDistrictWhenCreatingMissingStudent_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when there is exactly one school in the district while creating missing student");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows", result.Message);
+
+        // Parse the date before using it in the query
+        var expectedDateOfBirth = DateTime.Parse("01/01/2000");
+
+        // Verify a new student was created with the correct school
+        var createdStudent = Context.Students
+            .FirstOrDefault(s => s.FirstName == "New" && 
+                               s.LastName == "Student" && 
+                               s.DateOfBirth == expectedDateOfBirth);
+
+        Assert.NotNull(createdStudent);
+        Assert.Equal(TestSchool.Id, createdStudent.SchoolId);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMultipleSchoolsSameNameWhenCreatingMissingStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData.Remove("SchoolId"); // Remove SchoolId to force using school name
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["SchoolName"] = "Duplicate Name School"; // Use the name that has multiple schools
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when multiple schools with same name are found");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+
+        // Parse the error file content
+        var errorContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        var headerRow = errorLines[0].Split(new[] { ',' }, StringSplitOptions.None);
+        var errorRow = errorLines[1].Split(new[] { ',' }, StringSplitOptions.None);
+        var validationErrorsIndex = Array.IndexOf(headerRow, "ValidationErrors");
+
+        Assert.Equal($"Multiple schools found with name 'Duplicate Name School' in district '{TestDistrict.Name}'. Please specify a school ID.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonexistentSchoolNameWhenCreatingMissingStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and school name
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData.Remove("SchoolId"); // Remove SchoolId to force using school name
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["SchoolName"] = "Nonexistent School"; // Use a non-existent school name
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when school with given name is not found");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+
+        // Parse the error file content
+        var errorContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        var headerRow = errorLines[0].Split(new[] { ',' }, StringSplitOptions.None);
+        var errorRow = errorLines[1].Split(new[] { ',' }, StringSplitOptions.None);
+        var validationErrorsIndex = Array.IndexOf(headerRow, "ValidationErrors");
+
+        Assert.Equal("School with name 'Nonexistent School' not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoSchoolIdentifierWhenCreatingMissingStudent_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and remove all school identifiers
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData.Remove("SchoolId"); // Remove SchoolId
+        rowData.Remove("SchoolName"); // Remove SchoolName
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when no school identifier is provided while creating missing student");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+
+        // Parse the error file content
+        var errorContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        var headerRow = errorLines[0].Split(new[] { ',' }, StringSplitOptions.None);
+        var errorRow = errorLines[1].Split(new[] { ',' }, StringSplitOptions.None);
+        var validationErrorsIndex = Array.IndexOf(headerRow, "ValidationErrors");
+
+        Assert.Equal("School could not be identified. Please provide a valid School ID or Name.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoAddressFields_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove all address-related fields and use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData.Remove("StudentAddressLine1");
+        rowData.Remove("StudentAddressLine2");
+        rowData.Remove("StudentCity");
+        rowData.Remove("StudentState");
+        rowData.Remove("StudentZip");
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when no address fields are provided");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+
+        var expectedDateOfBirth = DateTime.Parse("01/01/2000");
+
+        // Verify a new student was created
+        var createdStudent = Context.Students
+            .FirstOrDefault(s => s.FirstName == "New" && 
+                               s.LastName == "Student" && 
+                               s.DateOfBirth == expectedDateOfBirth);
+
+        Assert.NotNull(createdStudent);
+        Assert.Equal(TestSchool.Id, createdStudent.SchoolId);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithPartialAddressFields_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove all address fields except StudentAddressLine2 and use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData.Remove("StudentAddressLine1");
+        rowData.Remove("StudentCity");
+        rowData.Remove("StudentState");
+        rowData.Remove("StudentZip");
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when only some address fields are provided");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("The following address fields are required when any address information is provided: StudentAddressLine1 StudentCity StudentState StudentZip", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidStateCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid state code
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentState"] = "XX"; // Use an invalid state code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when an invalid state code is provided");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Equal("StudentState must be a 2-character state code. Provided value was not found. Got: XX", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidAddress_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and valid address
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentAddressLine1"] = "123 Main St";
+        rowData["StudentAddressLine2"] = "Apt 4B";
+        rowData["StudentCity"] = "Anytown";
+        rowData["StudentState"] = "CA"; // Use a valid state code
+        rowData["StudentZip"] = "12345";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when a valid address is provided");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+
+        var expectedDateOfBirth = DateTime.Parse("01/01/2000");
+
+        // Verify a new student was created with the correct address
+        var createdStudent = Context.Students
+            .Include(s => s.Address)
+            .FirstOrDefault(s => s.FirstName == "New" && 
+                               s.LastName == "Student" && 
+                               s.DateOfBirth == expectedDateOfBirth);
+
+        Assert.NotNull(createdStudent);
+        Assert.Equal(TestSchool.Id, createdStudent.SchoolId);
+        Assert.NotNull(createdStudent.Address);
+        Assert.Equal("123 Main St", createdStudent.Address.Address1);
+        Assert.Equal("Apt 4B", createdStudent.Address.Address2);
+        Assert.Equal("Anytown", createdStudent.Address.City);
+        Assert.Equal("CA", createdStudent.Address.StateCode);
+        Assert.Equal("12345", createdStudent.Address.Zip);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithAddressValidationFailure_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid address
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentAddressLine1"] = "123 Main St";
+        rowData["StudentAddressLine2"] = "Apt 4B";
+        rowData["StudentCity"] = "Anytown";
+        rowData["StudentState"] = "CA"; // Use a valid state code
+        rowData["StudentZip"] = "123456789009876543211234567890"; // Use an invalid ZIP format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when address validation fails");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Address validation error:", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidIncomingCaseLoadStudentTypeId_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentTypeId"] = "1";
+        rowData["StudentTypeName"] = "IEP";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with valid student type ID");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadStudentTypeId_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid student type
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentTypeId"] = "99999";
+        rowData["StudentTypeName"] = "IEP";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid student type ID");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Student type with ID 99999 not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadStudentTypeIdFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid student type format
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentTypeId"] = "not-a-number";
+        rowData["StudentTypeName"] = "IEP";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid student type ID format");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid StudentTypeId format: not-a-number", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidIncomingCaseLoadStudentTypeName_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData.Remove("StudentTypeId"); // Remove ID to force using name
+        rowData["StudentTypeName"] = "IEP";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with valid student type name");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadStudentTypeName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid student type name
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData.Remove("StudentTypeId"); // Remove ID to force using name
+        rowData["StudentTypeName"] = "NonExistentType";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid student type name");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Student type with name 'NonExistentType' not found.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidIncomingCaseLoadDiagnosisCode_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["CaseLoadDiagnosisCode"] = "Z71.89"; // Valid diagnosis code from test data
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with valid diagnosis code");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadDiagnosisCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid diagnosis code
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["CaseLoadDiagnosisCode"] = "INVALID"; // Invalid diagnosis code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid diagnosis code");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Diagnosis code 'INVALID' not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidIncomingCaseLoadIEPDates_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["IEPStartDate"] = "01/01/2024";
+        rowData["IEPEndDate"] = "12/31/2024";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with valid IEP dates");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadIEPStartDateFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid IEP start date format
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["IEPStartDate"] = "not-a-date"; // Invalid format that cannot be parsed
+        rowData["IEPEndDate"] = "12/31/2024";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid IEP start date format");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid date format for IEPStartDate: not-a-date. Use MM/DD/YYYY format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidIncomingCaseLoadIEPEndDateFormat_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid IEP end date format
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["IEPStartDate"] = "01/01/2024";
+        rowData["IEPEndDate"] = "invalid-date"; // Invalid format that cannot be parsed
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail with invalid IEP end date format");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid date format for IEPEndDate: invalid-date. Use MM/DD/YYYY format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithIncomingCaseLoadIEPEndDateBeforeStartDate_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and invalid IEP dates
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["IEPStartDate"] = "12/31/2024";
+        rowData["IEPEndDate"] = "01/01/2024"; // End date before start date
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when IEP end date is before start date");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("IEPEndDate (1/1/2024) must be after IEPStartDate (12/31/2024).", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNoIncomingCaseLoadFields_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student and remove all case load fields
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData.Remove("StudentTypeId");
+        rowData.Remove("StudentTypeName");
+        rowData.Remove("CaseLoadDiagnosisCode");
+        rowData.Remove("IEPStartDate");
+        rowData.Remove("IEPEndDate");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when no case load fields are provided");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithValidCaseLoadScriptData_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add valid case load script data
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with valid case load script data");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonNursingServiceCode_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+
+        // Add non-nursing provider data
+        rowData["ProviderId"] = TestNonNursingProvider.Id.ToString();
+        rowData.Remove("ProviderFirstName");
+        rowData.Remove("ProviderLastName");
+        rowData.Remove("ProviderNPI");
+        
+        // Add case load script data with missing required fields
+        // This should be ignored since we're using a non-nursing service code
+        rowData["DoctorFirstName"] = ""; // Missing required field
+        rowData["DoctorLastName"] = ""; // Missing required field
+        rowData["DoctorNPI"] = ""; // Missing required field
+        rowData["PrescriptionInitiationDate"] = ""; // Missing required field
+        rowData["CaseLoadScriptDiagnosisCode"] = ""; // Missing required field
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed with non-nursing service code regardless of case load script data");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMissingCaseLoadScriptRequiredFields_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with missing required fields
+        rowData["DoctorFirstName"] = ""; // Missing required field
+        rowData["DoctorLastName"] = ""; // Missing required field
+        rowData["DoctorNPI"] = ""; // Missing required field
+        rowData["PrescriptionInitiationDate"] = ""; // Missing required field
+        rowData["CaseLoadScriptDiagnosisCode"] = ""; // Missing required field
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when case load script required fields are missing");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("The following prescription fields are required:", errorRow[validationErrorsIndex]);
+        Assert.Contains("DoctorFirstName", errorRow[validationErrorsIndex]);
+        Assert.Contains("DoctorLastName", errorRow[validationErrorsIndex]);
+        Assert.Contains("DoctorNPI", errorRow[validationErrorsIndex]);
+        Assert.Contains("PrescriptionInitiationDate", errorRow[validationErrorsIndex]);
+        Assert.Contains("CaseLoadScriptDiagnosisCode", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithLongDoctorFirstName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with a doctor first name that exceeds 50 characters
+        rowData["DoctorFirstName"] = new string('A', 51); // 51 characters
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when doctor first name exceeds 50 characters");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("DoctorFirstName cannot exceed 50 characters", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithLongDoctorLastName_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with a doctor last name that exceeds 50 characters
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = new string('A', 51); // 51 characters
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when doctor last name exceeds 50 characters");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("DoctorLastName cannot exceed 50 characters", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidDoctorNPI_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with an invalid doctor NPI (not exactly 10 characters)
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "123456789"; // Only 9 characters
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when doctor NPI is not exactly 10 characters");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("DoctorNPI must be exactly 10 characters", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidPrescriptionInitiationDate_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with an invalid prescription initiation date
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "invalid-date"; // Invalid date format
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when prescription initiation date is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid date format for PrescriptionInitiationDate: invalid-date. Use MM/DD/YYYY format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidPrescriptionExpirationDate_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with an invalid prescription expiration date
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["PrescriptionExpirationDate"] = "invalid-date"; // Invalid date format
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when prescription expiration date is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid date format for PrescriptionExpirationDate: invalid-date. Use MM/DD/YYYY format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithPrescriptionExpirationDateBeforeInitiationDate_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with expiration date before initiation date
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["PrescriptionExpirationDate"] = "12/31/2023"; // Before initiation date
+        rowData["CaseLoadScriptDiagnosisCode"] = "Z71.89";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when prescription expiration date is before initiation date");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("PrescriptionExpirationDate (12/31/2023) must be after PrescriptionInitiationDate (1/1/2024).", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithArchivedCaseLoadScriptDiagnosisCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with an archived diagnosis code
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = "ARCHIVED"; // Archived diagnosis code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when case load script diagnosis code is archived");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Diagnosis code 'ARCHIVED' not found or is archived.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMissingCaseLoadScriptDiagnosisCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a non-existent student to force createMissingStudentRecords path
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        
+        // Add case load script data with a missing diagnosis code
+        rowData["DoctorFirstName"] = "John";
+        rowData["DoctorLastName"] = "Doe";
+        rowData["DoctorNPI"] = "1234567890";
+        rowData["PrescriptionInitiationDate"] = "01/01/2024";
+        rowData["CaseLoadScriptDiagnosisCode"] = ""; // Missing diagnosis code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when case load script diagnosis code is missing");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("The following prescription fields are required: CaseLoadScriptDiagnosisCode", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentFieldLengthViolations_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but modify fields to exceed length limits
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId");
+        rowData["StudentFirstName"] = new string('a', 51); // Exceeds 50 chars
+        rowData["StudentLastName"] = new string('b', 51); // Exceeds 50 chars
+        rowData["StudentMiddleName"] = new string('c', 51); // Exceeds 50 chars
+        rowData["StudentGrade"] = "123"; // Exceeds 2 chars
+        rowData["StudentCode"] = new string('d', 13); // Exceeds 12 chars
+        rowData["StudentNotes"] = new string('e', 251); // Exceeds 250 chars
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student fields exceed length limits");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Fields exceed maximum length: StudentFirstName (max 50 characters) StudentLastName (max 50 characters) StudentMiddleName (max 50 characters) StudentGrade (max 2 characters) StudentCode (max 12 characters) StudentNotes (max 250 characters)", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithMissingRequiredStudentFields_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but remove all required student fields
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId");
+        rowData.Remove("StudentCode");
+        rowData.Remove("StudentFirstName");
+        rowData.Remove("StudentLastName");
+        rowData.Remove("StudentDateOfBirth");
+        rowData.Remove("StudentGrade");
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when required student fields are missing");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Missing required fields for creating a student: StudentFirstName StudentLastName StudentDateOfBirth StudentGrade", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidMedicaidNoLength_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid Medicaid number length
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentMedicaidNo"] = "12345"; // Not exactly 12 characters
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when Medicaid number is not exactly 12 characters");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Fields exceed maximum length: StudentMedicaidNo (must be exactly 12 characters)", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithEmptyOptionalStudentFields_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set optional fields to empty strings
+        var rowData = GetValidCsvRowData();
+        rowData.Remove("StudentId"); // Remove StudentId to force using name and DOB
+        rowData.Remove("StudentCode"); // Remove StudentCode to force using name and DOB
+        rowData["StudentFirstName"] = "New";
+        rowData["StudentLastName"] = "Student";
+        rowData["StudentDateOfBirth"] = "01/01/2000";
+        rowData["StudentGrade"] = "10";
+        rowData["StudentMiddleName"] = "";
+        rowData["StudentCode"] = "";
+        rowData["StudentMedicaidNo"] = "";
+        rowData["StudentNotes"] = "";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when optional student fields are empty");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEncounterDate_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid encounter date
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterDate"] = "invalid-date"; // Invalid date format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounter date is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid date format for EncounterDate: invalid-date. Use MM/DD/YYYY format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEncounterStartTime_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid encounter start time
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterStartTime"] = "invalid-time"; // Invalid time format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounter start time is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid time format for EncounterStartTime: invalid-time. Use HH:MM or HH:MM AM/PM format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEncounterEndTime_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid encounter end time
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterEndTime"] = "invalid-time"; // Invalid time format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounter end time is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid time format for EncounterEndTime: invalid-time. Use HH:MM or HH:MM AM/PM format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidStudentStartTime_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid student start time
+        var rowData = GetValidCsvRowData();
+        rowData["StudentStartTime"] = "invalid-time"; // Invalid time format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student start time is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid time format for StudentStartTime: invalid-time. Use HH:MM or HH:MM AM/PM format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidStudentEndTime_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid student end time
+        var rowData = GetValidCsvRowData();
+        rowData["StudentEndTime"] = "invalid-time"; // Invalid time format
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student end time is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid time format for StudentEndTime: invalid-time. Use HH:MM or HH:MM AM/PM format.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithStudentEndTimeBeforeStartTime_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but set student end time before start time
+        var rowData = GetValidCsvRowData();
+        rowData["StudentStartTime"] = "10:00";
+        rowData["StudentEndTime"] = "09:00"; // End time before start time
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when student end time is before start time");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("StudentStartTime (14:00:00) must be before StudentEndTime (13:00:00).", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidServiceTypeId_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid service type ID
+        var rowData = GetValidCsvRowData();
+        rowData["ServiceTypeId"] = "4"; // Invalid service type ID (valid values are 1, 2, or 3)
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when service type ID is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid ServiceTypeId: 4. Valid values are: 1 (Evaluation/Assessment); 2 (Other/Non-Billable); 3 (Treatment/Therapy)", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEvaluationTypeId_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid evaluation type ID
+        var rowData = GetValidCsvRowData();
+        rowData["EvaluationTypeId"] = "3"; // Invalid evaluation type ID (valid values are 1 or 2)
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when evaluation type ID is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Invalid EvaluationTypeId: 3. Valid values are: 1 (Initial Evaluation/Assessment); 2 (Re-evaluation/Re-assessment)", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEncounterDiagnosisCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid diagnosis code
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterDiagnosisCode"] = "INVALID"; // Invalid diagnosis code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounter diagnosis code is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Diagnosis code 'INVALID' not found or is archived.; Error creating data: Failed to create encounter data", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithOverlappingEncounters_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a time that overlaps with an existing encounter
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterDate"] = DateTime.Today.ToString("MM/dd/yyyy");
+        rowData["EncounterStartTime"] = "09:00";
+        rowData["EncounterEndTime"] = "10:00";
+        rowData["StudentStartTime"] = "09:00";
+        rowData["StudentEndTime"] = "10:00";
+
+        var rowData2 = GetValidCsvRowData();
+        rowData["EncounterDate"] = DateTime.Today.ToString("MM/dd/yyyy");
+        rowData["EncounterStartTime"] = "09:00";
+        rowData["EncounterEndTime"] = "10:00";
+        rowData["StudentStartTime"] = "09:00";
+        rowData["StudentEndTime"] = "10:00";
+
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        // Add second encounter data
+        csvContent.AppendLine(string.Join(",", rowData2.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounters overlap");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains($"This student already has an encounter with this provider on {DateTime.UtcNow:M/dd/yyyy} from 13:00:00 to 14:00:00.; Error creating data: Failed to create encounter data", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithNonOverlappingEncounters_ShouldSucceed()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use a time that doesn't overlap with existing encounters
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterDate"] = DateTime.Today.ToString("MM/dd/yyyy");
+        rowData["EncounterStartTime"] = "11:00";
+        rowData["EncounterEndTime"] = "12:00";
+        rowData["StudentStartTime"] = "11:00";
+        rowData["StudentEndTime"] = "12:00";
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.True(result.Success, "Import should succeed when encounters don't overlap");
+        Assert.Equal(1, result.SuccessCount);
+        Assert.Equal(0, result.ErrorCount);
+        Assert.Null(result.ErrorFileContent);
+        Assert.Contains("Import completed with 1 successful rows and 0 error rows.", result.Message);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidEncounterLocation_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid encounter location
+        var rowData = GetValidCsvRowData();
+        rowData["EncounterLocation"] = "INVALID"; // Invalid location
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when encounter location is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("Encounter location 'INVALID' not found. Please provide a valid location name.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithInvalidCPTCode_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use an invalid CPT code
+        var rowData = GetValidCsvRowData();
+        rowData["CPTCode"] = "INVALID"; // Invalid CPT code
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when CPT code is invalid");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("CPT code 'INVALID' not found or is archived. Please provide a valid CPT code.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithLongTherapyCaseNotes_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use therapy case notes that exceed the maximum length
+        var rowData = GetValidCsvRowData();
+        rowData["TherapyCaseNotes"] = new string('x', 6001); // Exceeds 6000 character limit
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when therapy case notes exceed maximum length");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("TherapyCaseNotes cannot exceed 6000 characters.", errorRow[validationErrorsIndex]);
+    }
+
+    [Fact]
+    public async Task ProcessImportFileAsync_WithLongSupervisorComments_ShouldReturnError()
+    {
+        // Arrange
+        var csvContent = new StringBuilder();
+        
+        // Get the valid row data but use supervisor comments that exceed the maximum length
+        var rowData = GetValidCsvRowData();
+        rowData["SupervisorComments"] = new string('x', 1001); // Exceeds 1000 character limit
+        
+        // Write headers (using the keys from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Keys));
+
+        // Write data row (using the values from the dictionary)
+        csvContent.AppendLine(string.Join(",", rowData.Values));
+
+        var fileContent = Encoding.UTF8.GetBytes(csvContent.ToString());
+
+        // Act
+        var result = await Service.ProcessImportFileAsync(fileContent, 1, true, Transaction);
+
+        // Assert
+        Assert.False(result.Success, "Import should fail when supervisor comments exceed maximum length");
+        Assert.Equal(0, result.SuccessCount);
+        Assert.Equal(1, result.ErrorCount);
+        Assert.NotNull(result.ErrorFileContent);
+        Assert.Contains("Import completed with 0 successful rows and 1 error rows.", result.Message);
+
+        // Verify the error file content
+        var errorFileContent = Encoding.UTF8.GetString(result.ErrorFileContent);
+        var errorLines = errorFileContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+        
+        // Should have header row + 1 data row
+        Assert.Equal(2, errorLines.Length);
+        
+        // Verify the error message is in the ValidationErrors column
+        var headers = errorLines[0].Split(',');
+        var validationErrorsIndex = Array.IndexOf(headers, "ValidationErrors");
+        var errorRow = errorLines[1].Split(',');
+        Assert.Contains("SupervisorComments cannot exceed 1000 characters.", errorRow[validationErrorsIndex]);
+    }
+}
diff --git a/src/Service.Test/Service.Test.csproj b/src/Service.Test/Service.Test.csproj
index 211d37797..314e39495 100644
--- a/src/Service.Test/Service.Test.csproj
+++ b/src/Service.Test/Service.Test.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+∩╗┐<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFramework>net8.0</TargetFramework>
@@ -13,15 +13,22 @@
       <PrivateAssets>all</PrivateAssets>
       <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
     </PackageReference>
+    <PackageReference Include="EntityFramework" Version="6.4.4" />
+    <PackageReference Include="FluentAssertions" Version="8.2.0" />
     <PackageReference Include="Microsoft.NET.Test.Sdk" Version="16.2.0" />
     <PackageReference Include="Moq" Version="4.14.7" />
     <PackageReference Include="xunit" Version="2.4.1" />
     <PackageReference Include="xunit.runner.visualstudio" Version="2.4.3" />
-	<PackageReference Include="coverlet.collector" Version="1.0.1" />
   </ItemGroup>
 
   <ItemGroup>
     <ProjectReference Include="..\Service\Service.csproj" />
   </ItemGroup>
 
+  <ItemGroup>
+    <None Update="appsettings.json">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+
 </Project>
diff --git a/src/Service.Test/appsettings.json b/src/Service.Test/appsettings.json
new file mode 100644
index 000000000..f2d269e1b
--- /dev/null
+++ b/src/Service.Test/appsettings.json
@@ -0,0 +1,5 @@
+{
+  "ConnectionStrings": {
+    "Primary": "Data Source=(localdb)\\ProjectsV13;Initial Catalog=edudoc-integration.SQL;Integrated Security=True"
+  }
+} 
\ No newline at end of file
diff --git a/src/Service/DataImport/EncounterImportService.cs b/src/Service/DataImport/EncounterImportService.cs
new file mode 100644
index 000000000..15e60820a
--- /dev/null
+++ b/src/Service/DataImport/EncounterImportService.cs
@@ -0,0 +1,2844 @@
+using BreckServiceBase.Utilities.Interfaces;
+using Model;
+using Model.Enums;
+using Model.DataImport;
+using Service.Base;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using CsvHelper;
+using System.Globalization;
+using Service.Encounters;
+using System.Data.Entity;
+using System.Data.Entity.Validation;
+using Newtonsoft.Json;
+
+namespace Service.DataImport
+{
+    public class EncounterImportService : IDataImportService
+    {
+        private readonly IPrimaryContext _context;
+        private readonly IEncounterStudentService _encounterStudentService;
+        private readonly IEncounterStudentStatusService _encounterStudentStatusService;
+
+        public EncounterImportService(IPrimaryContext context, IEncounterStudentService encounterStudentService, IEncounterStudentStatusService encounterStudentStatusService)
+        {
+            _context = context;
+            _encounterStudentService = encounterStudentService;
+            _encounterStudentStatusService = encounterStudentStatusService;
+        }
+
+        public string ImportType => "encounters";
+
+        /// <summary>
+        /// Generates a CSV template for encounter imports
+        /// </summary>
+        /// <returns>Byte array containing the CSV template</returns>
+        public byte[] GenerateTemplate()
+        {
+            // Create CSV with example rows
+            using var memoryStream = new MemoryStream();
+            using var writer = new StreamWriter(memoryStream);
+            using var csv = new CsvWriter(writer, CultureInfo.InvariantCulture);
+
+            // Create example data row
+            var exampleRow = new EncounterImportRow
+            {
+                // Integration information
+                ImportSource = "MST Integration",
+
+                // District and School information
+                DistrictId = "1",
+                DistrictName = "Sample District",
+                DistrictCode = "DIST001",
+                SchoolId = "1",
+                SchoolName = "Sample School",
+
+                // Provider information
+                ProviderId = "1",
+                ProviderNPI = "1234567890",
+                ProviderFirstName = "Jane",
+                ProviderLastName = "Smith",
+
+                // Student information
+                StudentId = "1",
+                StudentCode = "STU001",
+                StudentFirstName = "John",
+                StudentMiddleName = "A",
+                StudentLastName = "Doe",
+                StudentDateOfBirth = "01/15/2010",
+                StudentGrade = "3",
+                StudentMedicaidNo = "ABC123456",
+                StudentNotes = "Allergy to peanuts",
+                StudentAddressLine1 = "123 Main St",
+                StudentAddressLine2 = "Apt 4B",
+                StudentCity = "Anytown",
+                StudentState = "OH",
+                StudentZip = "12345",
+                StudentEnrollmentDate = "01/01/2023",
+                StudentTypeId = "1",
+                StudentTypeName = "Regular Ed",
+
+                // Case Load information
+                ServiceCodeId = "100",
+                ServiceCodeName = "Speech Therapy",
+                CaseLoadDiagnosisCode = "F84.0",
+                IEPStartDate = "01/01/2023",
+                IEPEndDate = "12/31/2023",
+
+                // Prescription/Script information
+                DoctorFirstName = "Dr. Robert",
+                DoctorLastName = "Johnson",
+                DoctorNPI = "0987654321",
+                PrescriptionInitiationDate = "01/01/2023",
+                PrescriptionExpirationDate = "12/31/2023",
+                CaseLoadScriptDiagnosisCode = "F84.0",
+
+                // Encounter data
+                EncounterDate = "05/15/2023",
+                EncounterStartTime = "09:00",
+                EncounterEndTime = "10:00",
+                ServiceTypeId = "3",
+                EvaluationTypeId = "2",
+                EncounterDiagnosisCode = "F84.0",
+                IsGroup = "false",
+                AdditionalStudents = "0",
+
+                // EncounterStudent data
+                EncounterLocation = "School Therapy Room",
+                StudentStartTime = "09:00",
+                StudentEndTime = "10:00",
+                EncounterStudentDate = "05/15/2023",
+                EncounterStudentDiagnosisCode = "F84.0",
+                CPTCode = "99213",
+                TherapyCaseNotes = "Initial assessment session",
+                SupervisorComments = "Approved by supervisor",
+                IsTelehealth = "false"
+            };
+
+            // Create example data for a group session
+            var groupExampleRow = new EncounterImportRow
+            {
+                // Integration information
+                ImportSource = "MST Integration",
+
+                // District and School information
+                DistrictId = "1",
+                DistrictName = "Sample District",
+                DistrictCode = "DIST001",
+                SchoolId = "1",
+                SchoolName = "Sample School",
+
+                // Provider information
+                ProviderId = "1",
+                ProviderNPI = "1234567890",
+                ProviderFirstName = "Jane",
+                ProviderLastName = "Smith",
+
+                // Student information
+                StudentId = "2",
+                StudentCode = "STU002",
+                StudentFirstName = "Sarah",
+                StudentMiddleName = "",
+                StudentLastName = "Johnson",
+                StudentDateOfBirth = "02/20/2010",
+                StudentGrade = "3",
+                StudentMedicaidNo = "DEF654321",
+                StudentNotes = "",
+                StudentAddressLine1 = "456 Oak St",
+                StudentAddressLine2 = "",
+                StudentCity = "Anytown",
+                StudentState = "OH",
+                StudentZip = "12345",
+                StudentEnrollmentDate = "01/01/2023",
+                StudentTypeId = "1",
+                StudentTypeName = "Regular Ed",
+
+                // Case Load information
+                ServiceCodeId = "100",
+                ServiceCodeName = "Speech Therapy",
+                CaseLoadDiagnosisCode = "F81.2",
+                IEPStartDate = "02/01/2023",
+                IEPEndDate = "01/31/2024",
+
+                // Prescription/Script information
+                DoctorFirstName = "Dr. Mary",
+                DoctorLastName = "Williams",
+                DoctorNPI = "5678901234",
+                PrescriptionInitiationDate = "02/01/2023",
+                PrescriptionExpirationDate = "01/31/2024",
+                CaseLoadScriptDiagnosisCode = "F84.0",
+
+                // Encounter data
+                EncounterDate = "05/15/2023",
+                EncounterStartTime = "09:00",
+                EncounterEndTime = "10:00",
+                ServiceTypeId = "3",
+                EvaluationTypeId = "2",
+                EncounterDiagnosisCode = "F81.2",
+                IsGroup = "true",
+                AdditionalStudents = "3",
+
+                // EncounterStudent data
+                EncounterLocation = "School Therapy Room",
+                StudentStartTime = "09:00",
+                StudentEndTime = "10:00",
+                EncounterStudentDate = "05/15/2023",
+                EncounterStudentDiagnosisCode = "F81.2",
+                CPTCode = "99213",
+                TherapyCaseNotes = "Group therapy session",
+                SupervisorComments = "Student showed good progress",
+                IsTelehealth = "false"
+            };
+
+            // Get the legend row with descriptive values
+            var legendRow = getLegendValues();
+
+            // Create a list of rows including the legend and examples
+            var allRows = new List<EncounterImportRow> { legendRow, exampleRow, groupExampleRow };
+
+            // Write all records with automatic header generation
+            csv.WriteRecords(allRows);
+
+            writer.Flush();
+            return memoryStream.ToArray();
+        }
+
+        /// <summary>
+        /// Gets descriptive legend values for each header to indicate requirements
+        /// </summary>
+        /// <returns>An EncounterImportRow with descriptive values</returns>
+        private EncounterImportRow getLegendValues()
+        {
+            return new EncounterImportRow
+            {
+                // Integration information
+                ImportSource = "Source of the import data",
+
+                // District and School information (identification only - cannot create)
+                DistrictId = "REQUIRED: Either DistrictId or DistrictName",
+                DistrictName = "REQUIRED: Either DistrictId or DistrictName",
+                DistrictCode = "Optional: Additional information",
+                SchoolId = "REQUIRED: Either SchoolId or SchoolName",
+                SchoolName = "REQUIRED: Either SchoolId or SchoolName",
+
+                // Provider information (identification only - cannot create)
+                ProviderId = "Use this ID if available, otherwise use alternative identification fields",
+                ProviderNPI = "Provider NPI number can be used instead of ID",
+                ProviderFirstName = "Provider first name (use with last name when ID/NPI not available)",
+                ProviderLastName = "Provider last name (use with first name when ID/NPI not available)",
+
+                // Student information (can create if missing)
+                StudentId = "Use to identify existing student by ID",
+                StudentCode = "School code for student (alternative to ID)",
+                StudentFirstName = "REQUIRED for new student creation",
+                StudentMiddleName = "Optional middle name",
+                StudentLastName = "REQUIRED for new student creation",
+                StudentDateOfBirth = "REQUIRED for new student: format MM/DD/YYYY",
+                StudentGrade = "REQUIRED for new student (K, 1, 2, etc.)",
+                StudentMedicaidNo = "Optional Medicaid number",
+                StudentNotes = "Optional notes about the student",
+                StudentAddressLine1 = "Optional street address",
+                StudentAddressLine2 = "Optional apartment/unit number",
+                StudentCity = "Optional city",
+                StudentState = "Optional state (2-letter code)",
+                StudentZip = "Optional zip/postal code",
+                StudentEnrollmentDate = "Optional enrollment date: format MM/DD/YYYY",
+                StudentTypeId = "Student type ID - use StudentTypeName if ID unknown",
+                StudentTypeName = "Name of student type (alternative to ID)",
+
+                // Case Load information (can create if missing)
+                ServiceCodeId = "Service code ID - use ServiceCodeName if ID unknown",
+                ServiceCodeName = "Name of service (e.g., \"Speech Therapy\")",
+                CaseLoadDiagnosisCode = "Diagnosis code for CaseLoad (e.g., \"F84.0\")",
+                IEPStartDate = "IEP start date: format MM/DD/YYYY",
+                IEPEndDate = "IEP end date: format MM/DD/YYYY",
+
+                // Prescription/Script information (can create if missing)
+                DoctorFirstName = "Prescribing doctor's first name",
+                DoctorLastName = "Prescribing doctor's last name",
+                DoctorNPI = "Doctor's NPI number (required for billing)",
+                PrescriptionInitiationDate = "When prescription becomes valid: format MM/DD/YYYY",
+                PrescriptionExpirationDate = "When prescription expires: format MM/DD/YYYY",
+                CaseLoadScriptDiagnosisCode = "Diagnosis code for CaseLoadScript (e.g., \"F84.0\")",
+
+                // Encounter data (Encounters table)
+                EncounterDate = "Date of service: format MM/DD/YYYY",
+                EncounterStartTime = "Overall session start time: format HH:MM or HH:MM AM/PM",
+                EncounterEndTime = "Overall session end time: format HH:MM or HH:MM AM/PM",
+                ServiceTypeId = "Type of service ID - valid values: 1 (Evaluation/Assessment), 2 (Other/Non-Billable), 3 (Treatment/Therapy)",
+                EvaluationTypeId = "Evaluation type ID - valid values: 1 (Initial Evaluation/Assessment), 2 (Re-evaluation/Re-assessment)",
+                EncounterDiagnosisCode = "Diagnosis code for this encounter (e.g., \"F84.0\")",
+                IsGroup = "Group session indicator: true/false (default: false)",
+                AdditionalStudents = "Number of additional students in group (default: 0)",
+
+                // EncounterStudent data (per-student details)
+                EncounterLocation = "Location of the encounter with the student",
+                StudentStartTime = "This student's session start time: format HH:MM or HH:MM AM/PM",
+                StudentEndTime = "This student's session end time: format HH:MM or HH:MM AM/PM",
+                EncounterStudentDate = "Optional: Date for this specific student's encounter (may differ from main EncounterDate)",
+                EncounterStudentDiagnosisCode = "Student-specific diagnosis code (e.g., \"F84.0\")",
+                CPTCode = "CPT code for billing (e.g., \"99213\")",
+                TherapyCaseNotes = "Notes from the session for this student",
+                SupervisorComments = "Comments from supervisor",
+                IsTelehealth = "Telehealth indicator: true/false (default: false)",
+
+                // ValidationErrors
+                ValidationErrors = "Any validation errors encountered during import"
+            };
+        }
+        
+        /// <summary>
+        /// Processes an import file and returns a result with validation information
+        /// </summary>
+        /// <param name="fileContent">The content of the file to process</param>
+        /// <param name="createMissingStudentRecords">Whether to create missing records instead of reporting errors</param>
+        /// <returns>A result containing the processed data and any errors</returns>
+        public async Task<ImportResult> ProcessImportFileAsync(byte[] fileContent, int userId, bool createMissingStudentRecords = false, DbContextTransaction transaction = null)
+        {
+            var result = new ImportResult
+            {
+                Success = true,
+                SuccessCount = 0,
+                ErrorCount = 0,
+                CreatedRecordCount = 0,
+                ErrorRows = new List<ImportRow>()
+            };
+
+            try
+            {
+                // Parse the CSV content
+                using (var memoryStream = new MemoryStream(fileContent))
+                using (var reader = new StreamReader(memoryStream))
+                using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
+                {
+                    // Read all records
+                    var records = csv.GetRecords<EncounterImportRow>().ToList();
+
+                    if (!records.Any())
+                    {
+                        result.Success = false;
+                        result.Message = "No data rows found in the import file.";
+                        return result;
+                    }
+
+                    // Clean time fields in all records
+                    foreach (var record in records)
+                    {
+                        CleanTimeFields(record);
+                    }
+
+                    // Process each record
+                    foreach (var typedRow in records)
+                    {
+                        try {
+                            // Validate the row
+                            var validationResult = ValidateMatchingRecords(typedRow, createMissingStudentRecords) as EncounterImportRowValidationResult;
+
+                            if (validationResult.IsValid)
+                            {
+                                CreateData(typedRow, validationResult, userId, createMissingStudentRecords, transaction);
+                                
+                                if (validationResult.IsValid)
+                                {
+                                    result.SuccessCount++;
+                                }
+                                else
+                                {
+                                    result.ErrorCount++;
+                                    PopulateErrorRow(typedRow, validationResult);
+                                    result.ErrorRows.Add(typedRow);
+                                }
+                            }
+                            else
+                            {
+                                result.ErrorCount++;
+                                PopulateErrorRow(typedRow, validationResult);
+                                result.ErrorRows.Add(typedRow);
+                            }
+                        } catch (Exception ex) {
+                            var validationResult = new EncounterImportRowValidationResult {
+                                IsValid = false,
+                                OriginalTypedRow = typedRow,
+                                Errors = new List<string> { $"Error processing row: {ex.Message}" }
+                            };
+
+                            result.ErrorCount++;
+                            PopulateErrorRow(typedRow, validationResult);
+                            result.ErrorRows.Add(typedRow);
+                        }
+                    }
+
+                    // Generate error file content if there are errors
+                    if (result.ErrorCount > 0)
+                    {
+                        result.ErrorFileContent = GenerateErrorFileContent(result.ErrorRows.Cast<EncounterImportRow>().ToList());
+                    }
+
+                    // Set overall success based on whether there were any errors
+                    result.Success = result.ErrorCount == 0;
+
+                    // Add summary message
+                    var createdStudentsMessage = result.CreatedRecordCount > 0
+                        ? $", {result.CreatedRecordCount} new students"
+                        : "";
+
+                    result.Message =
+                        $"Import completed with {result.SuccessCount} successful rows{createdStudentsMessage} and {result.ErrorCount} error rows.";
+
+                    return result;
+                }
+            }
+            catch (Exception ex)
+            {
+                result.Success = false;
+                result.Message = $"Error processing import file: {ex.Message}";
+                return result;
+            }
+        }
+
+        /// <summary>
+        /// Converts time fields from Eastern Time to UTC before processing
+        /// </summary>
+        private void CleanTimeFields(EncounterImportRow row)
+        {
+            var easternTime = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
+            
+            // Parse the encounter date first
+            if (!DateTime.TryParse(row.EncounterDate, out DateTime encounterDate))
+            {
+                return; // If we can't parse the date, we can't proceed with time conversions
+            }
+
+            // Parse the encounter student date if provided
+            DateTime? studentDate = null;
+            if (!string.IsNullOrWhiteSpace(row.EncounterStudentDate) && 
+                DateTime.TryParse(row.EncounterStudentDate, out DateTime parsedStudentDate))
+            {
+                studentDate = parsedStudentDate;
+            }
+
+            // Clean EncounterStartTime
+            if (!string.IsNullOrWhiteSpace(row.EncounterStartTime) && 
+                DateTime.TryParse(row.EncounterStartTime, out DateTime startTime))
+            {
+                // Combine the encounter date with the time
+                var startDateTime = encounterDate.Date.Add(startTime.TimeOfDay);
+                var utcTime = TimeZoneInfo.ConvertTimeToUtc(startDateTime, easternTime);
+                row.EncounterStartTime = utcTime.ToString("HH:mm");
+            }
+
+            // Clean EncounterEndTime
+            if (!string.IsNullOrWhiteSpace(row.EncounterEndTime) && 
+                DateTime.TryParse(row.EncounterEndTime, out DateTime endTime))
+            {
+                // Combine the encounter date with the time
+                var endDateTime = encounterDate.Date.Add(endTime.TimeOfDay);
+                var utcTime = TimeZoneInfo.ConvertTimeToUtc(endDateTime, easternTime);
+                row.EncounterEndTime = utcTime.ToString("HH:mm");
+            }
+
+            // Clean StudentStartTime if provided
+            if (!string.IsNullOrWhiteSpace(row.StudentStartTime) && 
+                DateTime.TryParse(row.StudentStartTime, out DateTime studentStartTime))
+            {
+                // Use student date if available, otherwise fall back to encounter date
+                var dateToUse = studentDate ?? encounterDate;
+                var studentStartDateTime = dateToUse.Date.Add(studentStartTime.TimeOfDay);
+                var utcTime = TimeZoneInfo.ConvertTimeToUtc(studentStartDateTime, easternTime);
+                row.StudentStartTime = utcTime.ToString("HH:mm");
+            }
+
+            // Clean StudentEndTime if provided
+            if (!string.IsNullOrWhiteSpace(row.StudentEndTime) && 
+                DateTime.TryParse(row.StudentEndTime, out DateTime studentEndTime))
+            {
+                // Use student date if available, otherwise fall back to encounter date
+                var dateToUse = studentDate ?? encounterDate;
+                var studentEndDateTime = dateToUse.Date.Add(studentEndTime.TimeOfDay);
+                var utcTime = TimeZoneInfo.ConvertTimeToUtc(studentEndDateTime, easternTime);
+                row.StudentEndTime = utcTime.ToString("HH:mm");
+            }
+        }
+
+        /// <summary>
+        /// Validates a row from an encounter import file
+        /// </summary>
+        /// <param name="row">Dictionary containing the row data with column names as keys</param>
+        /// <param name="createMissingStudentRecords">Whether to create missing records instead of reporting errors</param>
+        /// <returns>A validation result containing any errors found</returns>
+        private DataImportRowValidationResult ValidateMatchingRecords(EncounterImportRow typedRow, bool createMissingStudentRecords = false)
+        {
+            var result = new EncounterImportRowValidationResult
+            {
+                IsValid = true,
+                OriginalTypedRow = typedRow,
+                Errors = new List<string>()
+            };
+
+            // Validate District
+            ValidateMatchingDistrict(typedRow, result);
+
+            // If district validation failed, no need to continue with other validations
+            if (!result.IsValid)
+                return result;
+
+            // Validate Provider
+            ValidateMatchingProvider(typedRow, result);
+
+            // If provider validation failed, no need to continue
+            if (!result.IsValid)
+                return result;
+
+            // Check if the provider's service code is 5 (nursing)
+            // Only perform import source/goal validation for nursing encounters
+            if (result.MatchingProviderTitle != null && result.MatchingProviderTitle.ServiceCodeId == 5)
+            {
+                // Look up a goal for the script based on the ImportSource
+                if (string.IsNullOrWhiteSpace(typedRow.ImportSource))
+                {
+                    result.Errors.Add("ImportSource is required to determine the appropriate goal for the case load script.");
+                    result.IsValid = false;
+                    return result;
+                }
+
+                string importSource = typedRow.ImportSource.Trim();
+                var matchingGoal = _context.Goals
+                    .FirstOrDefault(g => g.Description.Equals(importSource) && !g.Archived);
+
+                if (matchingGoal == null)
+                {
+                    result.Errors.Add($"No matching goal found for ImportSource '{importSource}'. Please ensure a goal with this description exists in the system.");
+                    result.IsValid = false;
+                    return result;
+                } else {
+                    result.MatchingGoal = matchingGoal;
+                }
+            }
+
+            // Validate Student
+            ValidateMatchingStudent(typedRow, result, createMissingStudentRecords);
+
+            if (result.MatchingStudent == null && !createMissingStudentRecords)
+                return result;
+
+            // Validate School - we may have already found the school in ValidateMatchingStudent,
+            // in which case we want to use that instead of what the row might have provided
+            if (result.MatchingSchool == null) {
+                ValidateMatchingSchool(typedRow, result);
+            }
+
+            // Validate Provider-Student Relationship
+            ValidateMatchingProviderStudentRelationship(result);
+
+            // Validate Student Case Load
+            ValidateMatchingStudentCaseLoad(typedRow, result);
+
+            return result;
+        }
+
+        private void ValidateMatchingDistrict(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            int districtId = 0;
+            string districtName = null;
+
+            // Try to get district ID from the row
+            if (!string.IsNullOrWhiteSpace(typedRow.DistrictId))
+            {
+                if (int.TryParse(typedRow.DistrictId, out districtId))
+                {
+                    // Look up district by ID
+                    var district = _context.SchoolDistricts
+                        .FirstOrDefault(d => d.Id == districtId && !d.Archived);
+
+                    if (district != null)
+                    {
+                        result.MatchingDistrict = district;
+                        return;
+                    }
+                    else
+                    {
+                        result.Errors.Add($"District with ID {districtId} not found or is archived.");
+                        result.IsValid = false;
+                        return;
+                    }
+                }
+                else
+                {
+                    result.Errors.Add($"Invalid District ID format: {typedRow.DistrictId}");
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            // If we couldn't find by ID, try by name
+            if (!string.IsNullOrWhiteSpace(typedRow.DistrictName))
+            {
+                districtName = typedRow.DistrictName.Trim();
+                var matchingDistricts = _context.SchoolDistricts
+                    .Where(d => d.Name == districtName && !d.Archived)
+                    .ToList();
+
+                if (matchingDistricts.Count == 1)
+                {
+                    result.MatchingDistrict = matchingDistricts.First();
+                    return;
+                }
+                else if (matchingDistricts.Count > 1)
+                {
+                    result.Errors.Add(
+                        $"Multiple districts found with name '{districtName}'. Please specify a district ID.");
+                    result.IsValid = false;
+                    return;
+                }
+                else
+                {
+                    result.Errors.Add($"District with name '{districtName}' not found or is archived.");
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            // If we get here, we couldn't identify the district
+            result.Errors.Add("District could not be identified. Please provide a valid District ID or District Name.");
+            result.IsValid = false;
+        }
+
+        private void ValidateMatchingProvider(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            // Check if provider ID is provided
+            if (!string.IsNullOrWhiteSpace(typedRow.ProviderId))
+            {
+                // Try to parse provider ID
+                if (int.TryParse(typedRow.ProviderId, out int providerId))
+                {
+                    // Look up provider by ID
+                    var provider = _context.Providers.FirstOrDefault(p => p.Id == providerId && !p.Archived);
+                    if (provider != null)
+                    {
+                        result.MatchingProvider = provider;
+
+                        // Validate that provider has a title with service code
+                        ValidateProviderTitle(result);
+                    }
+                    else
+                    {
+                        result.Errors.Add($"Provider with ID {providerId} not found or is archived.");
+                        result.IsValid = false;
+                    }
+                }
+                else
+                {
+                    result.Errors.Add($"Invalid Provider ID format: {typedRow.ProviderId}");
+                    result.IsValid = false;
+                }
+            }
+            // Check if provider NPI is provided
+            else if (!string.IsNullOrWhiteSpace(typedRow.ProviderNPI))
+            {
+                // Look up providers by NPI
+                var npi = typedRow.ProviderNPI.Trim();
+                var matchingProviders = _context.Providers
+                    .Where(p => p.Npi == npi && !p.Archived)
+                    .ToList();
+
+                if (matchingProviders.Count == 1)
+                {
+                    result.MatchingProvider = matchingProviders.First();
+
+                    // Validate that provider has a title with service code
+                    ValidateProviderTitle(result);
+                }
+                else if (matchingProviders.Count > 1)
+                {
+                    result.Errors.Add(
+                        $"Multiple providers found with NPI '{typedRow.ProviderNPI}'. Please specify a provider ID.");
+                    result.IsValid = false;
+                }
+                else
+                {
+                    result.Errors.Add($"Provider with NPI '{typedRow.ProviderNPI}' not found or is archived.");
+                    result.IsValid = false;
+                }
+            }
+            // Check if provider name is provided
+            else if (!string.IsNullOrWhiteSpace(typedRow.ProviderFirstName) || !string.IsNullOrWhiteSpace(typedRow.ProviderLastName))
+            {
+                string firstName = typedRow.ProviderFirstName;
+                string lastName = typedRow.ProviderLastName;
+
+                // Look up provider by user's name
+                var users = _context.Users.Where(u =>
+                    u.FirstName.Contains(firstName) &&
+                    u.LastName.Contains(lastName) &&
+                    !u.Archived
+                ).ToList();
+
+                if (users.Count == 1)
+                {
+                    var user = users.First();
+                    var provider =
+                        _context.Providers.FirstOrDefault(p => p.ProviderUserId == user.Id && !p.Archived);
+                    if (provider != null)
+                    {
+                        result.MatchingProvider = provider;
+
+                        // Validate that provider has a title with service code
+                        ValidateProviderTitle(result);
+                    }
+                    else
+                    {
+                        result.Errors.Add($"No provider found with name '{users[0].FirstName} {users[0].LastName}'.");
+                        result.IsValid = false;
+                    }
+                }
+                else if (users.Count > 1)
+                {
+                    result.Errors.Add(
+                        $"Multiple providers found with name '{firstName} {lastName}'. Please specify a Provider ID or NPI.");
+                    result.IsValid = false;
+                }
+                else
+                {
+                    result.Errors.Add($"No provider found with name '{firstName} {lastName}'.");
+                    result.IsValid = false;
+                }
+            }
+            else
+            {
+                result.Errors.Add("Provider information is required. Please provide a Provider ID NPI or Name.");
+                result.IsValid = false;
+            }
+        }
+
+        private void ValidateProviderTitle(EncounterImportRowValidationResult result)
+        {
+            // Get the provider title directly using the TitleId from the already-populated Provider object
+            var providerTitle = _context.ProviderTitles
+                .FirstOrDefault(pt => pt.Id == result.MatchingProvider.TitleId && !pt.Archived);
+
+            if (providerTitle == null)
+            {
+                result.Errors.Add($"Provider (ID: {result.MatchingProvider.Id}) has a title that is archived or not found.");
+                result.IsValid = false;
+                return;
+            }
+
+            // Store the provider title in the result
+            result.MatchingProviderTitle = providerTitle;
+        }
+
+        private void ValidateMatchingStudent(EncounterImportRow typedRow, EncounterImportRowValidationResult result, bool createMissingStudentRecords = false)
+        {
+            int studentId = 0;
+            string studentCode = null;
+            string studentFirstName = null;
+            string studentLastName = null;
+            DateTime studentDob = DateTime.MinValue;
+
+            // Try to get student ID from the row
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentId))
+            {
+                if (int.TryParse(typedRow.StudentId, out studentId))
+                {
+                    // Look up student by ID
+                    var student = _context.Students
+                        .FirstOrDefault(s => s.Id == studentId && !s.Archived);
+
+                    if (student != null)
+                    {
+                        result.MatchingStudent = student;
+
+                        // If we found a student, get their school information
+                        if (student.SchoolId > 0)
+                        {
+                            var school = _context.Schools.FirstOrDefault(s => s.Id == student.SchoolId && !s.Archived);
+                            if (school != null)
+                            {
+                                result.MatchingSchool = school;
+                            }
+                            else
+                            {
+                                result.Errors.Add($"Student (ID: {student.Id}) has a school that is archived or not found.");
+                                result.IsValid = false;
+                            }
+                        }
+
+                        return;
+                    }
+                    else
+                    {
+                        result.Errors.Add($"Student with ID {studentId} not found or is archived.");
+                        result.IsValid = false;
+                        return;
+                    }
+                }
+                else
+                {
+                    result.Errors.Add($"Invalid Student ID format: {typedRow.StudentId}");
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            // If we couldn't find by ID, try by code
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentCode))
+            {
+                studentCode = typedRow.StudentCode.Trim();
+                var matchingStudents = _context.Students
+                    .Where(s => s.StudentCode == studentCode && !s.Archived)
+                    .ToList();
+
+                if (matchingStudents.Count == 1)
+                {
+                    result.MatchingStudent = matchingStudents.First();
+
+                    // If we found a student, get their school information
+                    if (result.MatchingStudent.SchoolId > 0)
+                    {
+                        var school =
+                            _context.Schools.FirstOrDefault(s => s.Id == result.MatchingStudent.SchoolId && !s.Archived);
+                        if (school != null)
+                        {
+                            result.MatchingSchool = school;
+                        }
+                        else
+                        {
+                            result.Errors.Add($"Student (ID: {result.MatchingStudent.Id}) has a school that is archived or not found.");
+                            result.IsValid = false;
+                        }
+                    }
+
+                    return;
+                }
+                else if (matchingStudents.Count > 1)
+                {
+                    result.Errors.Add(
+                        $"Multiple students found with code '{studentCode}'. Please specify a student ID.");
+                    result.IsValid = false;
+                    return;
+                }
+                // If no students found, continue to next identification method
+            }
+
+            // If we couldn't find by ID or code, try by name and DOB
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentFirstName) && 
+                !string.IsNullOrWhiteSpace(typedRow.StudentLastName) && 
+                !string.IsNullOrWhiteSpace(typedRow.StudentDateOfBirth))
+            {
+                studentFirstName = typedRow.StudentFirstName.Trim();
+                studentLastName = typedRow.StudentLastName.Trim();
+
+                // Try to parse the date of birth
+                if (DateTime.TryParse(typedRow.StudentDateOfBirth, out studentDob))
+                {
+                    // Look for students with matching name and DOB
+                    var matchingStudents = _context.Students
+                        .Where(s => s.FirstName == studentFirstName &&
+                                    s.LastName == studentLastName &&
+                                    s.DateOfBirth.Year == studentDob.Year &&
+                                    s.DateOfBirth.Month == studentDob.Month &&
+                                    s.DateOfBirth.Day == studentDob.Day &&
+                                    !s.Archived)
+                        .ToList();
+
+                    if (matchingStudents.Count == 1)
+                    {
+                        result.MatchingStudent = matchingStudents.First();
+
+                        // If we found a student, get their school information
+                        if (result.MatchingStudent.SchoolId > 0)
+                        {
+                            var school =
+                                _context.Schools.FirstOrDefault(s => s.Id == result.MatchingStudent.SchoolId && !s.Archived);
+                            if (school != null)
+                            {
+                                result.MatchingSchool = school;
+                            }
+                            else
+                            {
+                                result.Errors.Add($"Student (ID: {result.MatchingStudent.Id}) has a school that is archived or not found.");
+                                result.IsValid = false;
+                            }
+                        }
+
+                        return;
+                    }
+                    else if (matchingStudents.Count > 1)
+                    {
+                        result.Errors.Add(
+                            $"Multiple students found with name '{studentFirstName} {studentLastName}' and DOB '{studentDob:MM/dd/yyyy}'. Please specify a student ID or code.");
+                        result.IsValid = false;
+                        return;
+                    }
+                    else if (!createMissingStudentRecords)
+                    {
+                        result.Errors.Add(
+                            $"Student with name '{studentFirstName} {studentLastName}' and DOB '{studentDob:MM/dd/yyyy}' not found.");
+                        result.IsValid = false;
+                        return;
+                    }
+                }
+                else
+                {
+                    result.Errors.Add($"Invalid date format for Student Date of Birth: {typedRow.StudentDateOfBirth}");
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            if (result.MatchingStudent == null && !createMissingStudentRecords)
+            {
+                // If we get here, we couldn't identify the student
+                result.Errors.Add(
+                    "Student could not be identified. Please provide a valid Student ID Student Code or Name with Date of Birth.");
+                result.IsValid = false;
+            }
+        }
+
+        private void ValidateMatchingSchool(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            int schoolId = 0;
+            string schoolName = null;
+
+            // Try to get school ID from the row
+            if (!string.IsNullOrWhiteSpace(typedRow.SchoolId))
+            {
+                if (int.TryParse(typedRow.SchoolId, out schoolId))
+                {
+                    // Look up school by ID
+                    var school = _context.Schools
+                        .FirstOrDefault(s => s.Id == schoolId && !s.Archived);
+
+                    if (school != null)
+                    {
+                        result.MatchingSchool = school;
+                        return;
+                    }
+                    else
+                    {
+                        result.Errors.Add($"School with ID {schoolId} not found or is archived.");
+                        result.IsValid = false;
+                        return;
+                    }
+                }
+                else
+                {
+                    result.Errors.Add($"Invalid School ID format: {typedRow.SchoolId}");
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            // If we couldn't find by ID, try by name
+            if (!string.IsNullOrWhiteSpace(typedRow.SchoolName))
+            {
+                schoolName = typedRow.SchoolName.Trim();
+
+                // If we have a district, look for schools associated with that district
+                if (result.MatchingDistrict != null)
+                {
+                    // Find schools associated with this district through the many-to-many relationship
+                    var schoolsInDistrict = _context.SchoolDistrictsSchools
+                        .Where(sds => sds.SchoolDistrictId == result.MatchingDistrict.Id)
+                        .Select(sds => sds.School)
+                        .Where(s => s.Name == schoolName && !s.Archived)
+                        .ToList();
+
+                    if (schoolsInDistrict.Count == 1)
+                    {
+                        result.MatchingSchool = schoolsInDistrict.First();
+                        return;
+                    }
+                    else if (schoolsInDistrict.Count > 1)
+                    {
+                        result.Errors.Add(
+                            $"Multiple schools found with name '{schoolName}' in district '{result.MatchingDistrict.Name}'. Please specify a school ID.");
+                        result.IsValid = false;
+                        return;
+                    }
+                    // If no schools found in this district, fall through to the general search
+                }
+
+                result.Errors.Add($"School with name '{schoolName}' not found or is archived.");
+                result.IsValid = false;
+                return;
+            }
+
+            result.Errors.Add($"School could not be identified. Please provide a valid School ID or Name.");
+            result.IsValid = false;
+        }
+
+        private void ValidateMatchingProviderStudentRelationship(EncounterImportRowValidationResult result)
+        {
+            // We can only validate the relationship if we have both a provider and a student
+            if (result.MatchingStudent == null)
+            {
+                return; // Can't validate the relationship without both entities
+            }
+
+            // Check if the relationship already exists
+            var existingRelationship = _context.ProviderStudents
+                .FirstOrDefault(ps => ps.ProviderId == result.MatchingProvider.Id &&
+                                      ps.StudentId == result.MatchingStudent.Id);
+
+            result.MatchingProviderStudentRelationship = existingRelationship;
+        }
+
+        private void ValidateMatchingStudentCaseLoad(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            // We can only validate case loads if we have a student
+            if (result.MatchingStudent == null)
+            {
+                return;
+            }
+
+            // Check if the student has any active case loads with matching service code
+            var matchingCaseLoad = _context.CaseLoads
+                .FirstOrDefault(cl =>
+                    cl.StudentId == result.MatchingStudent.Id &&
+                    !cl.Archived &&
+                    cl.ServiceCodeId == result.MatchingProviderTitle.ServiceCodeId);
+
+            // If found, set the matching case load
+            if (matchingCaseLoad != null)
+            {
+                result.MatchingCaseLoad = matchingCaseLoad;
+                
+                // Get the date for which we're validating (encounter date if provided, otherwise current date)
+                DateTime validationDate = DateTime.Today;
+                if (!string.IsNullOrWhiteSpace(typedRow.EncounterDate))
+                {
+                    if (DateTime.TryParse(typedRow.EncounterDate, out DateTime encounterDate))
+                    {
+                        validationDate = encounterDate;
+                    }
+                }
+                
+                // Now check for matching CaseLoadScript with valid date range
+                var matchingCaseLoadScript = _context.CaseLoadScripts
+                    .FirstOrDefault(cls => 
+                        cls.CaseLoadId == matchingCaseLoad.Id && 
+                        !cls.Archived &&
+                        cls.InitiationDate.Year <= validationDate.Year &&
+                        (cls.InitiationDate.Year < validationDate.Year || 
+                         (cls.InitiationDate.Year == validationDate.Year && 
+                          (cls.InitiationDate.Month < validationDate.Month || 
+                           (cls.InitiationDate.Month == validationDate.Month && 
+                            cls.InitiationDate.Day <= validationDate.Day)))) &&
+                        (cls.ExpirationDate == null || 
+                         (cls.ExpirationDate.Value.Year > validationDate.Year ||
+                          (cls.ExpirationDate.Value.Year == validationDate.Year &&
+                           (cls.ExpirationDate.Value.Month > validationDate.Month ||
+                            (cls.ExpirationDate.Value.Month == validationDate.Month &&
+                             cls.ExpirationDate.Value.Day >= validationDate.Day))))));
+                
+                if (matchingCaseLoadScript != null)
+                {
+                    result.MatchingCaseLoadScript = matchingCaseLoadScript;
+                }
+                // If no matching CaseLoadScript is found, we'll leave MatchingCaseLoadScript as null
+                // and create one later when processing the import if needed
+            }
+            // If no matching case load found, we'll leave MatchingCaseLoad as null
+            // and create one later when processing the import
+        }
+
+        private (bool isValid, 
+                 List<string> errors, 
+                 DateTime encounterDate, 
+                 DateTime? encounterStudentDate, 
+                 TimeSpan encounterStartTime, 
+                 TimeSpan encounterEndTime,
+                 TimeSpan studentStartTime,
+                 TimeSpan studentEndTime) 
+        ValidateEncounterDatesAndTimes(EncounterImportRow typedRow)
+        {
+            var errors = new List<string>();
+            DateTime encounterDate;
+            DateTime? encounterStudentDate = null;
+            TimeSpan encounterStartTime = TimeSpan.Zero;
+            TimeSpan encounterEndTime = TimeSpan.Zero;
+            TimeSpan studentStartTime = TimeSpan.Zero;
+            TimeSpan studentEndTime = TimeSpan.Zero;
+
+            // Validate encounter date
+            if (string.IsNullOrWhiteSpace(typedRow.EncounterDate))
+            {
+                errors.Add("EncounterDate is required.");
+                return (false, errors, DateTime.MinValue, null, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+
+            if (!DateTime.TryParse(typedRow.EncounterDate, out encounterDate))
+            {
+                errors.Add($"Invalid date format for EncounterDate: {typedRow.EncounterDate}. Use MM/DD/YYYY format.");
+                return (false, errors, DateTime.MinValue, null, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+
+            // Validate encounter student date if provided
+            if (!string.IsNullOrWhiteSpace(typedRow.EncounterStudentDate))
+            {
+                if (!DateTime.TryParse(typedRow.EncounterStudentDate, out DateTime studentDate))
+                {
+                    errors.Add($"Invalid date format for EncounterStudentDate: {typedRow.EncounterStudentDate}. Use MM/DD/YYYY format.");
+                    return (false, errors, encounterDate, null, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+                }
+                
+                encounterStudentDate = studentDate;
+            }
+            else
+            {
+                // If not provided, use encounter date
+                encounterStudentDate = encounterDate;
+            }
+
+            // Validate encounter start time
+            if (string.IsNullOrWhiteSpace(typedRow.EncounterStartTime))
+            {
+                errors.Add("EncounterStartTime is required.");
+                return (false, errors, encounterDate, encounterStudentDate, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+
+            if (!DateTime.TryParse(typedRow.EncounterStartTime, out DateTime encounterStartDateTime))
+            {
+                errors.Add($"Invalid time format for EncounterStartTime: {typedRow.EncounterStartTime}. Use HH:MM or HH:MM AM/PM format.");
+                return (false, errors, encounterDate, encounterStudentDate, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+            encounterStartTime = encounterStartDateTime.TimeOfDay;
+
+            // Validate encounter end time
+            if (string.IsNullOrWhiteSpace(typedRow.EncounterEndTime))
+            {
+                errors.Add("EncounterEndTime is required.");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+
+            if (!DateTime.TryParse(typedRow.EncounterEndTime, out DateTime encounterEndDateTime))
+            {
+                errors.Add($"Invalid time format for EncounterEndTime: {typedRow.EncounterEndTime}. Use HH:MM or HH:MM AM/PM format.");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, TimeSpan.Zero, TimeSpan.Zero, TimeSpan.Zero);
+            }
+            encounterEndTime = encounterEndDateTime.TimeOfDay;
+
+            // Validate that encounter start time is before end time
+            if (encounterStartTime >= encounterEndTime)
+            {
+                errors.Add($"EncounterStartTime ({encounterStartTime}) must be before EncounterEndTime ({encounterEndTime}).");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, TimeSpan.Zero, TimeSpan.Zero);
+            }
+
+            // Validate student start time
+            if (string.IsNullOrWhiteSpace(typedRow.StudentStartTime))
+            {
+                // Default to encounter start time
+                studentStartTime = encounterStartTime;
+            }
+            else if (!DateTime.TryParse(typedRow.StudentStartTime, out DateTime studentStartDateTime))
+            {
+                errors.Add($"Invalid time format for StudentStartTime: {typedRow.StudentStartTime}. Use HH:MM or HH:MM AM/PM format.");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, TimeSpan.Zero, TimeSpan.Zero);
+            }
+            else
+            {
+                studentStartTime = studentStartDateTime.TimeOfDay;
+            }
+
+            // Validate student end time
+            if (string.IsNullOrWhiteSpace(typedRow.StudentEndTime))
+            {
+                // Default to encounter end time
+                studentEndTime = encounterEndTime;
+            }
+            else if (!DateTime.TryParse(typedRow.StudentEndTime, out DateTime studentEndDateTime))
+            {
+                errors.Add($"Invalid time format for StudentEndTime: {typedRow.StudentEndTime}. Use HH:MM or HH:MM AM/PM format.");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, studentStartTime, TimeSpan.Zero);
+            }
+            else
+            {
+                studentEndTime = studentEndDateTime.TimeOfDay;
+            }
+
+            // Validate that student start time is before end time
+            if (studentStartTime >= studentEndTime)
+            {
+                errors.Add($"StudentStartTime ({studentStartTime}) must be before StudentEndTime ({studentEndTime}).");
+                return (false, errors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, studentStartTime, studentEndTime);
+            }
+
+            return (true, errors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, studentStartTime, studentEndTime);
+        }
+        
+        private (bool isValid, string errorMessage) CheckForOverlappingEncounters(
+            int studentId, 
+            int providerId, 
+            DateTime? encounterStudentDate, 
+            TimeSpan studentStartTime, 
+            TimeSpan studentEndTime)
+        {
+            // Check for overlapping encounters
+            var overlappingEncounters = (from es in _context.EncounterStudents
+                           where es.StudentId == studentId
+                           && es.Encounter.ProviderId == providerId
+                           && !es.Archived
+                           && es.EncounterDate.Year == encounterStudentDate.Value.Year
+                           && es.EncounterDate.Month == encounterStudentDate.Value.Month
+                           && es.EncounterDate.Day == encounterStudentDate.Value.Day
+                           && ((es.EncounterStartTime <= studentStartTime && es.EncounterEndTime > studentStartTime) || // Starts during existing encounter
+                              (es.EncounterStartTime < studentEndTime && es.EncounterEndTime >= studentEndTime) || // Ends during existing encounter
+                              (es.EncounterStartTime >= studentStartTime && es.EncounterEndTime <= studentEndTime)) // Contained within the new encounter
+                           select es).ToList();
+
+            if (overlappingEncounters.Any())
+            {
+                var firstOverlap = overlappingEncounters.First();
+                return (false, $"This student already has an encounter with this provider on {encounterStudentDate.Value.ToShortDateString()} from {firstOverlap.EncounterStartTime} to {firstOverlap.EncounterEndTime}.");
+            }
+
+            return (true, null);
+        }
+
+        private (bool isValid, string errorMessage, Encounter encounter) CreateEncounter(
+            EncounterImportRow typedRow, 
+            Provider matchingProvider, 
+            DateTime encounterDate, 
+            TimeSpan encounterStartTime, 
+            TimeSpan encounterEndTime,
+            EncounterImportRowValidationResult result)
+        {
+            // Create the Encounter object
+            var encounter = new Encounter
+            {
+                ProviderId = matchingProvider.Id,
+                EncounterDate = encounterDate,
+                EncounterStartTime = encounterStartTime,
+                EncounterEndTime = encounterEndTime,
+                DateCreated = DateTime.UtcNow,
+                CreatedById = matchingProvider.ProviderUserId
+            };
+            
+            // Parse optional encounter fields
+            if (!string.IsNullOrWhiteSpace(typedRow.ServiceTypeId) && int.TryParse(typedRow.ServiceTypeId, out int serviceTypeId))
+            {
+                // Verify that the service type exists and is a valid value (1, 2, or 3)
+                if (serviceTypeId >= 1 && serviceTypeId <= 3)
+                {
+                    encounter.ServiceTypeId = serviceTypeId;
+                }
+                else
+                {
+                    return (false, $"Invalid ServiceTypeId: {serviceTypeId}. Valid values are: 1 (Evaluation/Assessment); 2 (Other/Non-Billable); 3 (Treatment/Therapy)", null);
+                }
+            }
+            else
+            {
+                return (false, "ServiceTypeId is required. Valid values are: 1 (Evaluation/Assessment); 2 (Other/Non-Billable); 3 (Treatment/Therapy)", null);
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.EvaluationTypeId) && int.TryParse(typedRow.EvaluationTypeId, out int evalTypeId))
+            {
+                // Verify that the evaluation type exists and is a valid value (1 or 2)
+                if (evalTypeId >= 1 && evalTypeId <= 2)
+                {
+                    encounter.EvaluationTypeId = evalTypeId;
+                }
+                else
+                {
+                    return (false, $"Invalid EvaluationTypeId: {evalTypeId}. Valid values are: 1 (Initial Evaluation/Assessment); 2 (Re-evaluation/Re-assessment)", null);
+                }
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.EncounterDiagnosisCode))
+            {
+                // Get the service code ID from the provider title
+                int serviceCodeId = result.MatchingProviderTitle.ServiceCodeId;
+                
+                // For encounters, we use the service type from the encounter
+                int encounterServiceTypeId = encounter.ServiceTypeId;
+                
+                var (isValid, errorMessage) = ValidateDiagnosisCode(typedRow.EncounterDiagnosisCode, serviceCodeId, encounterServiceTypeId);
+                if (!isValid)
+                {
+                    return (false, errorMessage, null);
+                }
+                
+                // Look up the diagnosis code
+                var diagCode = typedRow.EncounterDiagnosisCode.Trim();
+                var diagnosisCode = _context.DiagnosisCodes.FirstOrDefault(dc => dc.Code == diagCode && !dc.Archived);
+                encounter.DiagnosisCodeId = diagnosisCode.Id;
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.IsGroup) && bool.TryParse(typedRow.IsGroup, out bool isGroup))
+            {
+                encounter.IsGroup = isGroup;
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.AdditionalStudents) && int.TryParse(typedRow.AdditionalStudents, out int additionalStudents))
+            {
+                encounter.AdditionalStudents = additionalStudents;
+            }
+
+            return (true, null, encounter);
+        }
+
+        private (bool isValid, string errorMessage, EncounterStudent encounterStudent, CptCode cptCode) CreateEncounterStudent(
+            EncounterImportRow typedRow, 
+            int? studentId, 
+            DateTime encounterStudentDate, 
+            TimeSpan studentStartTime, 
+            TimeSpan studentEndTime,
+            CaseLoad caseLoad,
+            Provider matchingProvider,
+            EncounterImportRowValidationResult result,
+            Encounter encounter)
+        {
+            // Create the EncounterStudent object
+            var encounterStudent = new EncounterStudent
+            {
+                EncounterDate = encounterStudentDate,
+                EncounterStartTime = studentStartTime,
+                EncounterEndTime = studentEndTime,
+                DateCreated = DateTime.UtcNow,
+                CreatedById = matchingProvider.ProviderUserId,
+                ESignedById = matchingProvider.ProviderUserId,
+                EncounterStatusId = 1, // Default to status ID 1 (typically "Draft" or "Pending")
+            };
+
+            // Set StudentId only if it has a value
+            if (studentId.HasValue)
+            {
+                encounterStudent.StudentId = studentId.Value;
+            }
+            
+            CptCode cptCodeEntity = null;
+            
+            // Parse optional encounter student fields
+            if (!string.IsNullOrWhiteSpace(typedRow.EncounterLocation))
+            {
+                // Look up location by name
+                var locationName = typedRow.EncounterLocation.Trim();
+                var location = _context.EncounterLocations.FirstOrDefault(l => l.Name == locationName);
+                
+                if (location != null)
+                {
+                    encounterStudent.EncounterLocationId = location.Id;
+                }
+                else
+                {
+                    return (false, $"Encounter location '{locationName}' not found. Please provide a valid location name.", null, null);
+                }
+            }
+            else
+            {
+                return (false, "EncounterLocation is required.", null, null);
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.EncounterStudentDiagnosisCode))
+            {
+                // Get the service code ID from the provider title
+                int serviceCodeId = result.MatchingProviderTitle.ServiceCodeId;
+                
+                // For encounter students, we use the service type from the encounter
+                int encounterServiceTypeId = encounter.ServiceTypeId;
+                
+                var (isValid, errorMessage) = ValidateDiagnosisCode(typedRow.EncounterStudentDiagnosisCode, serviceCodeId, encounterServiceTypeId);
+                if (!isValid)
+                {
+                    return (false, errorMessage, null, null);
+                }
+                
+                // Look up the diagnosis code
+                var diagnosisCode = _context.DiagnosisCodes.FirstOrDefault(dc => dc.Code == typedRow.EncounterStudentDiagnosisCode.Trim() && !dc.Archived);
+                encounterStudent.DiagnosisCodeId = diagnosisCode.Id;
+            }
+            else if (!string.IsNullOrWhiteSpace(typedRow.EncounterDiagnosisCode))
+            {
+                // If no encounter student diagnosis code is provided, use the encounter diagnosis code
+                // No need to validate again since it was already validated in CreateEncounter
+                encounterStudent.DiagnosisCodeId = encounter.DiagnosisCodeId;
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.CPTCode))
+            {
+                // Note: CPT codes are stored in EncounterStudentCptCodes table, not directly on EncounterStudent
+                // We will store the CPT code in the validation result and create the association later
+                var cptCode = typedRow.CPTCode.Trim();
+                cptCodeEntity = _context.CptCodes.FirstOrDefault(cc => cc.Code == cptCode && !cc.Archived);
+                
+                if (cptCodeEntity == null)
+                {
+                    return (false, $"CPT code '{cptCode}' not found or is archived. Please provide a valid CPT code.", null, null);
+                }
+            }
+            else
+            {
+                return (false, "CPTCode is required.", null, null);
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.TherapyCaseNotes))
+            {
+                if (typedRow.TherapyCaseNotes.Length > 6000)
+                {
+                    return (false, "TherapyCaseNotes cannot exceed 6000 characters.", null, null);
+                }
+                encounterStudent.TherapyCaseNotes = typedRow.TherapyCaseNotes;
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.SupervisorComments))
+            {
+                if (typedRow.SupervisorComments.Length > 1000)
+                {
+                    return (false, "SupervisorComments cannot exceed 1000 characters.", null, null);
+                }
+                encounterStudent.SupervisorComments = typedRow.SupervisorComments;
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.IsTelehealth) && bool.TryParse(typedRow.IsTelehealth, out bool isTelehealth))
+            {
+                encounterStudent.IsTelehealth = isTelehealth;
+            }
+
+            encounterStudent.CaseLoadId = caseLoad.Id;
+
+            return (true, null, encounterStudent, cptCodeEntity);
+        }
+
+        /// <summary>
+        /// Validates that the CPT code is compatible with the service attributes
+        /// </summary>
+        /// <param name="cptCodeId">The ID of the CPT code to validate</param>
+        /// <param name="serviceCodeId">The service code ID from the provider's title</param>
+        /// <param name="serviceTypeId">The service type ID from the encounter</param>
+        /// <param name="providerTitleId">The provider title ID</param>
+        /// <param name="evaluationTypeId">The evaluation type ID (if applicable)</param>
+        /// <param name="isGroup">Whether this is a group session</param>
+        /// <param name="isTelehealth">Whether this is a telehealth session</param>
+        /// <returns>A tuple with validation result and error message</returns>
+        private (bool isValid, string errorMessage) ValidateCptCodeCompatibility(
+            int cptCodeId,
+            int serviceCodeId,
+            int serviceTypeId,
+            int providerTitleId,
+            int? evaluationTypeId,
+            bool isGroup,
+            bool isTelehealth)
+        {
+            // Query the CPTCodeAssocations table to find a matching record
+            var query = _context.CptCodeAssocations
+                .Where(ca => ca.CptCodeId == cptCodeId &&
+                             ca.ServiceCodeId == serviceCodeId &&
+                             ca.ServiceTypeId == serviceTypeId &&
+                             ca.ProviderTitleId == providerTitleId &&
+                             ca.IsGroup == isGroup &&
+                             ca.IsTelehealth == isTelehealth &&
+                             !ca.Archived);
+
+            // If evaluation type is provided, add it to the query
+            if (evaluationTypeId.HasValue)
+            {
+                query = query.Where(ca => ca.EvaluationTypeId == evaluationTypeId.Value);
+            }
+            else
+            {
+                // If no evaluation type is provided, only include records where EvaluationTypeId is null
+                query = query.Where(ca => ca.EvaluationTypeId == null);
+            }
+
+            // Check if any matching records exist
+            var matchingAssociations = query.ToList();
+
+            if (!matchingAssociations.Any())
+            {
+                // Build a descriptive error message
+                var errorMessage = $"CPT code is not valid for the specified combination of service attributes. ";
+                errorMessage += $"Service Code ID: {serviceCodeId}, Service Type ID: {serviceTypeId}, ";
+                errorMessage += $"Provider Title ID: {providerTitleId}, ";
+                
+                if (evaluationTypeId.HasValue)
+                {
+                    errorMessage += $"Evaluation Type ID: {evaluationTypeId.Value}, ";
+                }
+                
+                errorMessage += $"Is Group: {isGroup}, Is Telehealth: {isTelehealth}";
+                
+                return (false, errorMessage);
+            }
+
+            return (true, null);
+        }
+
+        private void ValidateIncomingEncounterData(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            // Validate dates and times
+            var (isValid, timeErrors, encounterDate, encounterStudentDate, encounterStartTime, encounterEndTime, studentStartTime, studentEndTime) = 
+                ValidateEncounterDatesAndTimes(typedRow);
+
+            if (!isValid)
+            {
+                result.Errors.AddRange(timeErrors);
+                result.IsValid = false;
+                return;
+            }
+
+            // Check for overlapping encounters only if student exists
+            if (result.MatchingStudent != null)
+            {
+                var (noOverlaps, overlapErrorMessage) = CheckForOverlappingEncounters(
+                    result.MatchingStudent.Id, result.MatchingProvider.Id, encounterStudentDate, studentStartTime, studentEndTime);
+
+                if (!noOverlaps)
+                {
+                    // The given student and provider already have an encounter on the given date and time
+                    result.Errors.Add(overlapErrorMessage);
+                    result.IsValid = false;
+                    return;
+                }
+            }
+
+            // Create the Encounter object
+            var (encounterValid, encounterError, encounter) = CreateEncounter(typedRow, result.MatchingProvider, encounterDate, encounterStartTime, encounterEndTime, result);
+
+            if (!encounterValid)
+            {
+                result.Errors.Add(encounterError);
+                result.IsValid = false;
+                return;
+            }
+            
+            // Create the EncounterStudent object - use student ID if available
+            int? studentId = result.MatchingStudent != null ? result.MatchingStudent.Id : result.CreatedStudent.Id;
+            
+            // Only create EncounterStudent if we have a student ID or will get one later
+            var (encounterStudentValid, studentError, encounterStudent, cptCode) = CreateEncounterStudent(
+                typedRow, studentId, encounterStudentDate.Value, studentStartTime, studentEndTime, result.MatchingCaseLoad ?? result.CreatedCaseLoad, result.MatchingProvider, result, encounter);
+
+            if (!encounterStudentValid)
+            {
+                result.Errors.Add(studentError);
+                result.IsValid = false;
+                return;
+            }
+            
+            // Validate CPT code compatibility
+            var (cptValid, cptErrorMessage) = ValidateCptCodeCompatibility(
+                cptCode.Id,
+                result.MatchingProviderTitle.ServiceCodeId,
+                encounter.ServiceTypeId,
+                result.MatchingProviderTitle.Id,
+                encounter.EvaluationTypeId,
+                encounter.IsGroup,
+                encounterStudent.IsTelehealth);
+            
+            if (!cptValid)
+            {
+                result.Errors.Add(cptErrorMessage);
+                result.IsValid = false;
+                return;
+            }
+            
+            // Store the objects in the result
+            result.Encounter = encounter;
+            result.EncounterStudent = encounterStudent;
+            result.EncounterStudentCptCode = cptCode;
+        }
+
+        private void PopulateErrorRow(EncounterImportRow typedRow, EncounterImportRowValidationResult validationResult)
+        {
+            // Update the typedRow with found entity information
+            if (validationResult.MatchingDistrict != null)
+            {
+                // Update district information in the original columns
+                typedRow.DistrictId = validationResult.MatchingDistrict.Id.ToString();
+                typedRow.DistrictName = validationResult.MatchingDistrict.Name;
+            }
+
+            if (validationResult.MatchingSchool != null)
+            {
+                // Update school information in the original columns
+                typedRow.SchoolId = validationResult.MatchingSchool.Id.ToString();
+                typedRow.SchoolName = validationResult.MatchingSchool.Name;
+            }
+
+            if (validationResult.MatchingProvider != null)
+            {
+                // Update provider information in the original columns
+                typedRow.ProviderId = validationResult.MatchingProvider.Id.ToString();
+                typedRow.ProviderNPI = validationResult.MatchingProvider.Npi;
+
+                // Get provider name from user if available
+                var providerUser = _context.Users.FirstOrDefault(u =>
+                    u.Id == validationResult.MatchingProvider.ProviderUserId);
+                if (providerUser != null)
+                {
+                    typedRow.ProviderFirstName = providerUser.FirstName;
+                    typedRow.ProviderLastName = providerUser.LastName;
+                }
+            }
+
+            if (validationResult.MatchingStudent != null)
+            {
+                // Update student information in the original columns
+                typedRow.StudentId = validationResult.MatchingStudent.Id.ToString();
+                typedRow.StudentFirstName = validationResult.MatchingStudent.FirstName;
+                typedRow.StudentLastName = validationResult.MatchingStudent.LastName;
+                typedRow.StudentCode = validationResult.MatchingStudent.StudentCode;
+
+                // DateOfBirth is not nullable, so we can use it directly
+                typedRow.StudentDateOfBirth = validationResult.MatchingStudent.DateOfBirth.ToString("MM/dd/yyyy");
+            }
+
+            // Add error messages in a new column
+            typedRow.ValidationErrors = string.Join("; ", validationResult.Errors);
+        }
+
+        private byte[] GenerateErrorFileContent(List<EncounterImportRow> errorRows)
+        {
+            if (errorRows == null || !errorRows.Any())
+                return null;
+
+            using (var memoryStream = new MemoryStream())
+            using (var writer = new StreamWriter(memoryStream))
+            using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
+            {
+                // Write records
+                csv.WriteRecords(errorRows);
+                writer.Flush();
+                return memoryStream.ToArray();
+            }
+        }
+
+        /// <summary>
+        /// Creates records from import data
+        /// </summary>
+        /// <param name="typedRow">The strongly typed import data for the records to create</param>
+        /// <param name="result">The validation result containing district, school, provider information</param>
+        /// <param name="createMissingStudentRecords">Whether to create missing records instead of reporting errors</param>
+        /// <param name="transaction">Optional transaction to use. If not provided, a new transaction will be created and managed.</param>
+        private void CreateData(EncounterImportRow typedRow, EncounterImportRowValidationResult result, int userId, bool createMissingStudentRecords = false, DbContextTransaction transaction = null)
+        {
+            // Use the provided user ID or default to 1 if not provided
+            int currentUserId = userId; // Default to system user if not provided
+
+            // If no transaction is provided, create our own
+            var shouldManageTransaction = transaction == null;
+            transaction = transaction ?? _context.Database.BeginTransaction();
+
+            try
+            {
+                // Check if we need to create a student
+                if (result.MatchingStudent == null && createMissingStudentRecords)
+                {
+                    // Validate all required data before creating student. Since this student does
+                    // not exist yet, we know we definitely need to validate the address and case load.
+                    if (!ValidateIncomingAddress(typedRow, result) ||
+                        !ValidateIncomingCaseLoad(typedRow, result) ||
+                        !ValidateIncomingCaseLoadScript(typedRow, result) ||
+                        !ValidateIncomingStudent(typedRow, result))
+                    {
+                        // Validation failed, the result.IsValid is already set to false 
+                        // and error messages added to result.Errors in the validation methods
+                        return;
+                    }
+
+                    if (HasAnyAddressField(typedRow)) {
+                        // Create address from the row data
+                        CreateStudentAddress(typedRow, result);
+                    }
+                    
+                    // Create student and student parental consent
+                    // This is the first call where we're actually persisting data
+                    CreateStudentAndParentalConsent(typedRow, result, currentUserId);
+                    
+                    // Create provider-student relationship
+                    CreateProviderStudentRelationship(result, currentUserId);
+
+                    // Create case load
+                    CreateCaseLoad(typedRow, result, currentUserId);
+
+                    if (result.MatchingProviderTitle.ServiceCodeId == 5) {
+                        // Create case load script
+                        CreateCaseLoadScript(typedRow, result, currentUserId);
+                    }
+
+                } else if (result.MatchingStudent != null) {
+                    // If we have a matching student, we need to check if we need to create a provider-student relationship,
+                    if (result.MatchingProviderStudentRelationship == null) {
+                        CreateProviderStudentRelationship(result, currentUserId);
+                    }
+                    if (result.MatchingCaseLoad == null) {
+                        if (ValidateIncomingCaseLoad(typedRow, result)){
+                            CreateCaseLoad(typedRow, result, currentUserId);
+                        } else {
+                            throw new Exception("Failed to create case load");
+                        }
+                    }
+                    if (result.MatchingCaseLoadScript == null && result.MatchingProviderTitle.ServiceCodeId == 5) {
+                        if (ValidateIncomingCaseLoadScript(typedRow, result)) {
+                            CreateCaseLoadScript(typedRow, result, currentUserId);
+                        } else {
+                            throw new Exception("Failed to create case load script for existing case load");
+                        }
+                    } else if (result.MatchingProviderTitle.ServiceCodeId == 5) {
+                        // If there's a matching case load script, we need to add the goal related
+                        // to the ImportSource to the case load script goals if it isn't already there.
+                        if (!result.MatchingCaseLoadScript.CaseLoadScriptGoals.Any(g => g.GoalId == result.MatchingGoal.Id)) {
+                            _context.CaseLoadScriptGoals.Add(new CaseLoadScriptGoal {
+                                CaseLoadScriptId = result.MatchingCaseLoadScript.Id,
+                                GoalId = result.MatchingGoal.Id,
+                                CreatedById = currentUserId,
+                                DateCreated = DateTime.UtcNow
+                            });
+                        }
+                    }
+                }
+                
+                // Validate Encounter Data
+                ValidateIncomingEncounterData(typedRow, result);
+                
+                // If we made it here, we are ready to create the actual encounter data
+                if (result.IsValid && result.Encounter != null && result.EncounterStudent != null && result.EncounterStudentCptCode != null) {
+                    _context.Encounters.Add(result.Encounter);
+                    result.EncounterStudent.EncounterId = result.Encounter.Id;
+                    _context.EncounterStudents.Add(result.EncounterStudent);
+                    var encounterStudentCptCode = new EncounterStudentCptCode {
+                        EncounterStudentId = result.EncounterStudent.Id,
+                        CptCodeId = result.EncounterStudentCptCode.Id,
+                        Minutes = (int)(result.EncounterStudent.EncounterEndTime - result.EncounterStudent.EncounterStartTime).TotalMinutes,
+                        CreatedById = currentUserId,
+                        DateCreated = DateTime.UtcNow
+                    };
+                    _context.EncounterStudentCptCodes.Add(encounterStudentCptCode);
+
+                    // Create encounter student goal if the service code is nursing
+                    if (result.MatchingProviderTitle.ServiceCodeId == 5) {
+                        _context.EncounterStudentGoals.Add(new EncounterStudentGoal{
+                            EncounterStudentId = result.EncounterStudent.Id,
+                            Goal = result.MatchingGoal,
+                            CreatedById = currentUserId,
+                            DateCreated = DateTime.UtcNow,
+                            NursingResponseNote = typedRow.ImportSource,
+                            NursingResultNote = typedRow.ImportSource,
+                            NursingGoalResultId = result.MatchingGoal.NursingGoalResponse?.NursingGoalResults?.FirstOrDefault()?.Id
+                        });
+                    }
+                    _context.SaveChanges();
+
+                    result.EncounterStudent = _encounterStudentService.GenerateEncounterNumber(result.Encounter.ServiceTypeId, result.EncounterStudent, result.MatchingDistrict.Id);
+                    _encounterStudentStatusService.CheckEncounterStudentStatus(result.EncounterStudent.Id, currentUserId);
+                    _context.SaveChanges();
+                } else {
+                    throw new Exception("Failed to create encounter data");
+                }
+                
+                // Only commit if we created the transaction
+                if (shouldManageTransaction)
+                {
+                    transaction.Commit();
+                }
+            }
+            catch (Exception ex)
+            {
+                // Only rollback if we created the transaction
+                if (shouldManageTransaction)
+                {
+                    transaction.Rollback();
+                }
+                
+                // Log the error and add it to the result
+                result.Errors.Add($"Error creating data: {ex.Message}");
+                result.IsValid = false;
+            }
+            finally
+            {
+                // Only dispose if we created the transaction
+                if (shouldManageTransaction)
+                {
+                    transaction.Dispose();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Validates if all required student data is present in the import row
+        /// </summary>
+        /// <param name="row">Dictionary containing the import data</param>
+        /// <param name="result">Validation result to update with errors</param>
+        /// <returns>True if validation passes, false otherwise</returns>
+        private bool ValidateIncomingStudent(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            List<string> missingFields = new List<string>();
+            List<string> invalidFields = new List<string>();
+            
+            // Check required fields
+            if (string.IsNullOrWhiteSpace(typedRow.StudentFirstName))
+                missingFields.Add("StudentFirstName");
+            else if (typedRow.StudentFirstName.Length > 50)
+                invalidFields.Add("StudentFirstName (max 50 characters)");
+        
+            if (string.IsNullOrWhiteSpace(typedRow.StudentLastName))
+                missingFields.Add("StudentLastName");
+            else if (typedRow.StudentLastName.Length > 50)
+                invalidFields.Add("StudentLastName (max 50 characters)");
+
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentMiddleName) && typedRow.StudentMiddleName.Length > 50)
+                invalidFields.Add("StudentMiddleName (max 50 characters)");
+        
+            if (string.IsNullOrWhiteSpace(typedRow.StudentDateOfBirth))
+                missingFields.Add("StudentDateOfBirth");
+            else
+            {
+                // Validate date format
+                if (!DateTime.TryParse(typedRow.StudentDateOfBirth, out _))
+                {
+                    result.Errors.Add($"Invalid date format for StudentDateOfBirth: {typedRow.StudentDateOfBirth}. Use MM/DD/YYYY format.");
+                    result.IsValid = false;
+                    return false;
+                }
+            }
+        
+            if (string.IsNullOrWhiteSpace(typedRow.StudentGrade))
+                missingFields.Add("StudentGrade");
+            else if (typedRow.StudentGrade.Length > 2)
+                invalidFields.Add("StudentGrade (max 2 characters)");
+
+            // Validate optional fields if present
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentCode) && typedRow.StudentCode.Length > 12)
+                invalidFields.Add("StudentCode (max 12 characters)");
+
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentMedicaidNo))
+            {
+                if (typedRow.StudentMedicaidNo.Length != 12)
+                    invalidFields.Add("StudentMedicaidNo (must be exactly 12 characters)");
+            }
+
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentNotes) && typedRow.StudentNotes.Length > 250)
+                invalidFields.Add("StudentNotes (max 250 characters)");
+        
+            // If any required fields are missing, add error and return false
+            if (missingFields.Count > 0)
+            {
+                result.Errors.Add($"Missing required fields for creating a student: {string.Join(" ", missingFields)}");
+                result.IsValid = false;
+                return false;
+            }
+
+            // If any fields exceed length limits, add error and return false
+            if (invalidFields.Count > 0)
+            {
+                result.Errors.Add($"Fields exceed maximum length: {string.Join(" ", invalidFields)}");
+                result.IsValid = false;
+                return false;
+            }
+        
+            return true;
+        }
+
+        /// <summary>
+        /// Validates the address data if it's provided in the import row
+        /// </summary>
+        /// <param name="row">Dictionary containing the import data</param>
+        /// <param name="result">Validation result to update with errors</param>
+        /// <returns>True if validation passes, false otherwise</returns>
+        private bool ValidateIncomingAddress(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            if (HasAnyAddressField(typedRow))
+            {
+                List<string> missingFields = new List<string>();
+        
+                // If any address field is provided, these fields become required
+                if (string.IsNullOrWhiteSpace(typedRow.StudentAddressLine1))
+                    missingFields.Add("StudentAddressLine1");
+            
+                if (string.IsNullOrWhiteSpace(typedRow.StudentCity))
+                    missingFields.Add("StudentCity");
+            
+                if (string.IsNullOrWhiteSpace(typedRow.StudentState))
+                    missingFields.Add("StudentState");
+                else
+                {
+                    // Validate state code format
+                    string stateCode = typedRow.StudentState.Trim();
+                    var state = _context.States.FirstOrDefault(s => s.StateCode == stateCode);
+                    if (state == null)
+                    {
+                        result.Errors.Add($"StudentState must be a 2-character state code. Provided value was not found. Got: {stateCode}");
+                        result.IsValid = false;
+                        return false;
+                    }
+                }
+            
+                if (string.IsNullOrWhiteSpace(typedRow.StudentZip))
+                    missingFields.Add("StudentZip");
+            
+                // If any required address fields are missing, add error and return false
+                if (missingFields.Count > 0)
+                {
+                    result.Errors.Add($"The following address fields are required when any address information is provided: {string.Join(" ", missingFields)}");
+                    result.IsValid = false;
+                    return false;
+                }
+
+                // Create Address from row data
+                Address address = new()
+                {
+                    Address1 = typedRow.StudentAddressLine1.Trim(),
+                    Address2 = !string.IsNullOrWhiteSpace(typedRow.StudentAddressLine2) ? typedRow.StudentAddressLine2.Trim() : string.Empty,
+                    City = typedRow.StudentCity.Trim(),
+                    StateCode = typedRow.StudentState.Trim(),
+                    Zip = typedRow.StudentZip.Trim(),
+                    CountryCode = "US", // Default value
+                    Province = string.Empty,
+                    County = string.Empty
+                };
+                
+                // Validate the address using AddressValidator
+                var addressValidator = new Service.Utilities.Validators.AddressValidator();
+                var addressValidationResult = addressValidator.Validate(address);
+                
+                if (!addressValidationResult.IsValid)
+                {
+                    // Add validation errors to result
+                    foreach (var error in addressValidationResult.Errors)
+                    {
+                        result.Errors.Add($"Address validation error: {error.ErrorMessage}");
+                    }
+                    result.IsValid = false;
+                    return false;
+                }
+            }
+
+            // No errors found
+            return true;
+        }
+
+        /// <summary>
+        /// Checks if any address fields are present
+        /// </summary>
+        /// <param name="row">Dictionary containing the import data</param>
+        /// <returns>True if any address field is present</returns>
+        private bool HasAnyAddressField(EncounterImportRow typedRow)
+        {
+            return !string.IsNullOrWhiteSpace(typedRow.StudentAddressLine1) ||
+                   !string.IsNullOrWhiteSpace(typedRow.StudentAddressLine2) ||
+                   !string.IsNullOrWhiteSpace(typedRow.StudentCity) ||
+                   !string.IsNullOrWhiteSpace(typedRow.StudentState) ||
+                   !string.IsNullOrWhiteSpace(typedRow.StudentZip);
+        }
+
+        /// <summary>
+        /// Validates a diagnosis code against the DiagnosisCodeAssociations table
+        /// </summary>
+        /// <param name="diagnosisCode">The diagnosis code to validate</param>
+        /// <param name="serviceCodeId">The service code ID to validate against</param>
+        /// <param name="serviceTypeId">The service type ID to validate against</param>
+        /// <returns>A tuple with validation result and error message</returns>
+        private (bool isValid, string errorMessage) ValidateDiagnosisCode(string diagnosisCode, int serviceCodeId, int serviceTypeId)
+        {
+            if (string.IsNullOrWhiteSpace(diagnosisCode))
+            {
+                return (true, null); // Empty diagnosis codes are allowed
+            }
+
+            string code = diagnosisCode.Trim();
+            var diagnosisCodeEntity = _context.DiagnosisCodes.FirstOrDefault(dc => dc.Code == code && !dc.Archived);
+            
+            if (diagnosisCodeEntity == null)
+            {
+                return (false, $"Diagnosis code '{code}' not found or is archived.");
+            }
+
+            // Check if there's a valid association in the DiagnosisCodeAssociations table
+            var association = _context.DiagnosisCodeAssociations.FirstOrDefault(dca => 
+                dca.DiagnosisCodeId == diagnosisCodeEntity.Id && 
+                dca.ServiceCodeId == serviceCodeId && 
+                dca.ServiceTypeId == serviceTypeId && 
+                !dca.Archived);
+
+            if (association == null)
+            {
+                return (false, $"Diagnosis code '{code}' is not associated with the specified service code and service type.");
+            }
+
+            return (true, null);
+        }
+
+        private bool ValidateIncomingCaseLoad(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            // Optional fields for case load - if provided, attempt to validate them
+            
+            // Validate student type if provided
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentTypeId) || !string.IsNullOrWhiteSpace(typedRow.StudentTypeName))
+            {
+                if (!string.IsNullOrWhiteSpace(typedRow.StudentTypeId))
+                {
+                    if (int.TryParse(typedRow.StudentTypeId, out int parsedTypeId)) {
+                        var studentType = _context.StudentTypes.FirstOrDefault(st => st.Id == parsedTypeId);
+                        if (studentType == null)
+                        {
+                            result.Errors.Add($"Student type with ID {parsedTypeId} not found.");
+                            result.IsValid = false;
+                            return false;
+                        }
+                    } else {
+                        result.Errors.Add($"Invalid StudentTypeId format: {typedRow.StudentTypeId}");
+                        result.IsValid = false;
+                        return false;
+                    }
+                }
+                else
+                {
+                    var studentTypeName = typedRow.StudentTypeName.Trim();
+                    var studentType = _context.StudentTypes.FirstOrDefault(st => st.Name == studentTypeName);
+                    if (studentType == null)
+                    {
+                        result.Errors.Add($"Student type with name '{typedRow.StudentTypeName}' not found.");
+                        result.IsValid = false;
+                        return false;
+                    }
+                }
+            }
+
+            // Validate diagnosis code if provided
+            if (!string.IsNullOrWhiteSpace(typedRow.CaseLoadDiagnosisCode))
+            {
+                // Get the service code ID from the provider title
+                int serviceCodeId = result.MatchingProviderTitle.ServiceCodeId;
+                
+                // For case loads, we use service type 3 (Treatment/Therapy)
+                int serviceTypeId = 3;
+                
+                var (isValid, errorMessage) = ValidateDiagnosisCode(typedRow.CaseLoadDiagnosisCode, serviceCodeId, serviceTypeId);
+                if (!isValid)
+                {
+                    result.Errors.Add(errorMessage);
+                    result.IsValid = false;
+                    return false;
+                }
+            }
+            
+            // Validate IEP dates if provided
+            if (!string.IsNullOrWhiteSpace(typedRow.IEPStartDate))
+            {
+                if (!DateTime.TryParse(typedRow.IEPStartDate, out _))
+                {
+                    result.Errors.Add($"Invalid date format for IEPStartDate: {typedRow.IEPStartDate}. Use MM/DD/YYYY format.");
+                    result.IsValid = false;
+                    return false;
+                }
+            }
+            
+            if (!string.IsNullOrWhiteSpace(typedRow.IEPEndDate))
+            {
+                if (!DateTime.TryParse(typedRow.IEPEndDate, out DateTime iepEndDate))
+                {
+                    result.Errors.Add($"Invalid date format for IEPEndDate: {typedRow.IEPEndDate}. Use MM/DD/YYYY format.");
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                // If both dates are provided, validate that end date is after start date
+                if (!string.IsNullOrWhiteSpace(typedRow.IEPStartDate) && 
+                    DateTime.TryParse(typedRow.IEPStartDate, out DateTime iepStartDate))
+                {
+                    if (iepEndDate < iepStartDate)
+                    {
+                        result.Errors.Add($"IEPEndDate ({iepEndDate.ToShortDateString()}) must be after IEPStartDate ({iepStartDate.ToShortDateString()}).");
+                        result.IsValid = false;
+                        return false;
+                    }
+                }
+            }
+            
+            // All validation checks passed
+            return true;
+        }
+
+        /// <summary>
+        /// Validates the incoming case load script
+        /// </summary>
+        /// <param name="row">Dictionary containing the import data</param>
+        /// <param name="result">Validation result to update with errors</param>
+        /// <returns>True if validation passes, false otherwise</returns>
+        private bool ValidateIncomingCaseLoadScript(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            if (result.MatchingProviderTitle.ServiceCodeId == 5)
+            {
+                // CaseLoadScript (prescription) validation
+                // Check for required prescription fields
+                List<string> missingPrescriptionFields = new List<string>();
+                
+                if (string.IsNullOrWhiteSpace(typedRow.DoctorFirstName))
+                    missingPrescriptionFields.Add("DoctorFirstName");
+                else if (typedRow.DoctorFirstName.Trim().Length > 50)
+                {
+                    result.Errors.Add("DoctorFirstName cannot exceed 50 characters.");
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                if (string.IsNullOrWhiteSpace(typedRow.DoctorLastName))
+                    missingPrescriptionFields.Add("DoctorLastName");
+                else if (typedRow.DoctorLastName.Trim().Length > 50)
+                {
+                    result.Errors.Add("DoctorLastName cannot exceed 50 characters.");
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                if (string.IsNullOrWhiteSpace(typedRow.DoctorNPI))
+                    missingPrescriptionFields.Add("DoctorNPI");
+                else if (typedRow.DoctorNPI.Trim().Length != 10)
+                {
+                    result.Errors.Add("DoctorNPI must be exactly 10 characters.");
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                if (string.IsNullOrWhiteSpace(typedRow.PrescriptionInitiationDate))
+                    missingPrescriptionFields.Add("PrescriptionInitiationDate");
+                
+                // Require CaseLoadDiagnosisCode for the CaseLoadScript
+                if (string.IsNullOrWhiteSpace(typedRow.CaseLoadScriptDiagnosisCode))
+                    missingPrescriptionFields.Add("CaseLoadScriptDiagnosisCode");
+                
+                // If any required prescription fields are missing, add error and return false
+                if (missingPrescriptionFields.Count > 0)
+                {
+                    result.Errors.Add($"The following prescription fields are required: {string.Join(" ", missingPrescriptionFields)}");
+                    result.IsValid = false;
+                    return false;
+                }
+
+                // Validate the diagnosis code using the new validation method
+                int serviceCodeId = result.MatchingProviderTitle.ServiceCodeId;
+                int serviceTypeId = 3; // For case load scripts, we use service type 3  (Treatment/Therapy)
+                
+                var (isValid, errorMessage) = ValidateDiagnosisCode(typedRow.CaseLoadScriptDiagnosisCode, serviceCodeId, serviceTypeId);
+                if (!isValid)
+                {
+                    result.Errors.Add(errorMessage);
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                // Validate prescription dates
+                if (!DateTime.TryParse(typedRow.PrescriptionInitiationDate, out DateTime prescriptionStartDate))
+                {
+                    result.Errors.Add($"Invalid date format for PrescriptionInitiationDate: {typedRow.PrescriptionInitiationDate}. Use MM/DD/YYYY format.");
+                    result.IsValid = false;
+                    return false;
+                }
+                
+                if (!string.IsNullOrWhiteSpace(typedRow.PrescriptionExpirationDate))
+                {
+                    if (!DateTime.TryParse(typedRow.PrescriptionExpirationDate, out DateTime prescriptionEndDate))
+                    {
+                        result.Errors.Add($"Invalid date format for PrescriptionExpirationDate: {typedRow.PrescriptionExpirationDate}. Use MM/DD/YYYY format.");
+                        result.IsValid = false;
+                        return false;
+                    }
+                    
+                    // Validate that expiration date is after initiation date
+                    if (prescriptionEndDate < prescriptionStartDate)
+                    {
+                        result.Errors.Add($"PrescriptionExpirationDate ({prescriptionEndDate.ToShortDateString()}) must be after PrescriptionInitiationDate ({prescriptionStartDate.ToShortDateString()}).");
+                        result.IsValid = false;
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Creates a student address from import data
+        /// </summary>
+        /// <param name="row">Dictionary containing the address data</param>
+        /// <param name="result">Validation result to update with errors</param>
+        /// <returns>Created Address object or null if creation failed</returns>
+        private void CreateStudentAddress(EncounterImportRow typedRow, EncounterImportRowValidationResult result)
+        {
+            // Create Address from row data
+            Address address = new()
+            {
+                Address1 = typedRow.StudentAddressLine1.Trim(),
+                Address2 = !string.IsNullOrWhiteSpace(typedRow.StudentAddressLine2) ? typedRow.StudentAddressLine2.Trim() : string.Empty,
+                City = typedRow.StudentCity.Trim(),
+                StateCode = typedRow.StudentState.Trim(),
+                Zip = typedRow.StudentZip.Trim(),
+                CountryCode = "US", // Default value
+                Province = string.Empty,
+                County = string.Empty
+            };
+            
+            // Store created address in result
+            result.CreatedAddress = address;
+        }
+
+        /// <summary>
+        /// Creates a student and student parental consent from import data
+        /// </summary>
+        /// <param name="row">Dictionary containing the student data</param>
+        /// <param name="address">The student's address (can be null)</param>
+        /// <param name="result">Validation result to update with the created student</param>
+        /// <param name="currentUserId">ID of the user creating the record</param>
+        /// <returns>Created Student object or null if creation failed</returns>
+        private void CreateStudentAndParentalConsent(EncounterImportRow typedRow, EncounterImportRowValidationResult result, int currentUserId)
+        {
+            // Extract required student information from the row
+            string firstName = typedRow.StudentFirstName.Trim();
+            string lastName = typedRow.StudentLastName.Trim();
+            string grade = typedRow.StudentGrade.Trim();
+            DateTime dateOfBirth = DateTime.Parse(typedRow.StudentDateOfBirth);
+            
+            // Extract optional student information
+            string middleName = !string.IsNullOrWhiteSpace(typedRow.StudentMiddleName) ? typedRow.StudentMiddleName.Trim() : null;
+            
+            string studentCode = !string.IsNullOrWhiteSpace(typedRow.StudentCode) ? typedRow.StudentCode.Trim() : null;
+            
+            string medicaidNo = !string.IsNullOrWhiteSpace(typedRow.StudentMedicaidNo) ? typedRow.StudentMedicaidNo.Trim() : null;
+            
+            string notes = !string.IsNullOrWhiteSpace(typedRow.StudentNotes) ? typedRow.StudentNotes.Trim() : null;
+            
+            DateTime enrollmentDate = !string.IsNullOrWhiteSpace(typedRow.StudentEnrollmentDate) ? DateTime.Parse(typedRow.StudentEnrollmentDate) : DateTime.UtcNow;
+            
+            // Create Student record
+            var student = new Student
+            {
+                FirstName = firstName,
+                LastName = lastName,
+                MiddleName = middleName,
+                StudentCode = studentCode,
+                MedicaidNo = medicaidNo,
+                Grade = grade,
+                DateOfBirth = dateOfBirth,
+                Notes = notes,
+                Address = result.CreatedAddress,
+                SchoolId = result.MatchingSchool.Id,
+                DistrictId = result.MatchingDistrict.Id,
+                EnrollmentDate = enrollmentDate,
+                CreatedById = currentUserId,
+                DateCreated = DateTime.UtcNow,
+                Archived = false
+            };
+            
+            // Create Parental Consent record
+            var consent = new StudentParentalConsent
+            {
+                Student = student,
+                ParentalConsentEffectiveDate = DateTime.UtcNow,
+                ParentalConsentDateEntered = DateTime.UtcNow,
+                ParentalConsentTypeId = (int)StudentParentalConsentTypes.PendingConsent,
+                CreatedById = currentUserId,
+                DateCreated = DateTime.UtcNow
+            };
+            
+            // Add the consent to the student's collection
+            student.StudentParentalConsents = new List<StudentParentalConsent> { consent };
+            
+            // Add student to context
+            _context.Students.Add(student);
+            
+            // Save all changes to get the IDs
+            _context.SaveChanges();
+            
+            // Store created student in result
+            result.CreatedStudent = student;
+        }
+
+        /// <summary>
+        /// Creates a provider-student relationship
+        /// </summary>
+        /// <param name="studentId">ID of the student</param>
+        /// <param name="result">Validation result to update with the created relationship</param>
+        /// <param name="currentUserId">ID of the user creating the record</param>
+        /// <returns>Created ProviderStudent object</returns>
+        private void CreateProviderStudentRelationship(EncounterImportRowValidationResult result, int currentUserId)
+        {
+            // Create provider-student relationship
+            var providerStudent = new ProviderStudent
+            {
+                ProviderId = result.MatchingProvider.Id,
+                StudentId = result.CreatedStudent != null ? result.CreatedStudent.Id : result.MatchingStudent.Id,
+                CreatedById = currentUserId,
+                DateCreated = DateTime.UtcNow
+            };
+            
+            _context.ProviderStudents.Add(providerStudent);
+            
+            // Save to get providerStudent ID
+            _context.SaveChanges();
+            
+            // Store created provider-student relationship in result
+            result.CreatedProviderStudentRelationship = providerStudent;
+        }
+
+        /// <summary>
+        /// Creates a case load record
+        /// </summary>
+        /// <param name="row">Dictionary containing the case load data</param>
+        /// <param name="result">Validation result to update with the created case load</param>
+        /// <param name="currentUserId">ID of the user creating the record</param>
+        /// <returns>Created CaseLoad object</returns>
+        private void CreateCaseLoad(EncounterImportRow typedRow, EncounterImportRowValidationResult result, int currentUserId)
+        {
+            // Get student type
+            int studentTypeId = 1; // Default student type
+            if (!string.IsNullOrWhiteSpace(typedRow.StudentTypeId) && int.TryParse(typedRow.StudentTypeId, out int parsedTypeId))
+            {
+                studentTypeId = parsedTypeId;
+            }
+            else if (!string.IsNullOrWhiteSpace(typedRow.StudentTypeName))
+            {
+                var studentTypeName = typedRow.StudentTypeName.Trim();
+                var studentType = _context.StudentTypes.FirstOrDefault(st => st.Name == studentTypeName);
+                if (studentType != null)
+                {
+                    studentTypeId = studentType.Id;
+                }
+            }
+            
+            // Get diagnosis code if provided
+            int? diagnosisCodeId = null;
+            if (!string.IsNullOrWhiteSpace(typedRow.CaseLoadDiagnosisCode))
+            {
+                var diagCode = typedRow.CaseLoadDiagnosisCode.Trim();
+                var diagnosisCode = _context.DiagnosisCodes
+                    .FirstOrDefault(dc => dc.Code == diagCode && !dc.Archived);
+                if (diagnosisCode != null)
+                {
+                    diagnosisCodeId = diagnosisCode.Id;
+                }
+            }
+            
+            // Parse IEP dates
+            DateTime iepStartDate = DateTime.UtcNow;
+            if (!string.IsNullOrWhiteSpace(typedRow.IEPStartDate) && DateTime.TryParse(typedRow.IEPStartDate, out DateTime parsedStartDate))
+            {
+                iepStartDate = parsedStartDate;
+            }
+            
+            DateTime? iepEndDate = DateTime.UtcNow.AddYears(1);
+            if (!string.IsNullOrWhiteSpace(typedRow.IEPEndDate) && DateTime.TryParse(typedRow.IEPEndDate, out DateTime parsedEndDate))
+            {
+                iepEndDate = parsedEndDate;
+            }
+            
+            // Create the case load
+            var caseLoad = new CaseLoad
+            {
+                StudentId = result.CreatedStudent != null ? result.CreatedStudent.Id : result.MatchingStudent.Id,
+                StudentTypeId = studentTypeId,
+                ServiceCodeId = result.MatchingProviderTitle.ServiceCodeId,
+                DiagnosisCodeId = diagnosisCodeId,
+                IepStartDate = iepStartDate,
+                IepEndDate = iepEndDate,
+                Archived = false,
+                CreatedById = currentUserId,
+                DateCreated = DateTime.UtcNow
+            };
+            
+            _context.CaseLoads.Add(caseLoad);
+            _context.SaveChanges();
+
+            result.CreatedCaseLoad = caseLoad;
+        }
+
+        /// <summary>
+        /// Creates a case load script record
+        /// </summary>
+        /// <param name="caseLoadId">ID of the case load</param>
+        /// <param name="row">Dictionary containing the case load script data</param>
+        /// <param name="result">Validation result to update with the created case load script</param>  
+        private void CreateCaseLoadScript(EncounterImportRow typedRow, EncounterImportRowValidationResult result, int currentUserId)
+        {
+            // Parse prescription dates
+            DateTime initiationDate = DateTime.UtcNow;
+            if (DateTime.TryParse(typedRow.PrescriptionInitiationDate, out DateTime parsedInitDate))
+            {
+                initiationDate = parsedInitDate;
+            }
+            
+            DateTime? expirationDate = null;
+            if (!string.IsNullOrWhiteSpace(typedRow.PrescriptionExpirationDate) && 
+                DateTime.TryParse(typedRow.PrescriptionExpirationDate, out DateTime parsedExpDate))
+            {
+                expirationDate = parsedExpDate;
+            }
+
+            // Get diagnosis code if provided
+            var diagCode = typedRow.CaseLoadScriptDiagnosisCode.Trim();
+            var diagnosisCode = _context.DiagnosisCodes.FirstOrDefault(dc => dc.Code == diagCode && !dc.Archived);
+
+            // Create case load script record
+            var caseLoadScript = new CaseLoadScript
+            {
+                CaseLoadId = result.CreatedCaseLoad != null ? result.CreatedCaseLoad.Id : result.MatchingCaseLoad.Id,
+                DiagnosisCodeId = diagnosisCode != null ? diagnosisCode.Id : null,
+                Npi = typedRow.DoctorNPI.Trim(),
+                DoctorFirstName = typedRow.DoctorFirstName.Trim(),
+                DoctorLastName = typedRow.DoctorLastName.Trim(),
+                InitiationDate = initiationDate,
+                ExpirationDate = expirationDate,
+                Archived = false,
+                FileName = string.Empty,
+                FilePath = string.Empty,
+                UploadedById = currentUserId,
+                DateUpload = DateTime.UtcNow
+            };
+            
+            _context.CaseLoadScripts.Add(caseLoadScript);
+            _context.SaveChanges();
+            
+            // Store created case load script in result
+            result.CreatedCaseLoadScript = caseLoadScript;
+            
+            var caseLoadScriptGoal = new CaseLoadScriptGoal
+            {
+                CaseLoadScriptId = caseLoadScript.Id,
+                GoalId = result.MatchingGoal.Id,
+                Archived = false,
+                CreatedById = currentUserId,
+                DateCreated = DateTime.UtcNow
+            };
+            
+            _context.CaseLoadScriptGoals.Add(caseLoadScriptGoal);
+            _context.SaveChanges();
+            
+            // Store created case load script goal in result
+            result.CreatedCaseLoadScriptGoal = caseLoadScriptGoal;
+            
+            // Update the script record with modification info
+            caseLoadScript.ModifiedById = currentUserId;
+            caseLoadScript.DateModified = DateTime.UtcNow;
+            _context.SaveChanges();
+        }
+
+        /// <summary>
+        /// Converts SNAP EMR student and service files into the encounter import format.
+        /// </summary>
+        /// <remarks>
+        /// File Format Specification:
+        /// - Files are pipe-delimited ("|") ASCII text files with quoted values
+        /// - Column names are in the first row
+        /// - File naming: CustomerId_TableName_DateCreated_TimeCreated.Extension
+        /// 
+        /// Student.txt Fields:
+        /// 1. StudentId (50, Alphanumeric) - Required: SNAP's unique identifier
+        /// 2. StudentLocalId (50, Alphanumeric) - Optional: School-assigned identifier
+        /// 3. StudentStateId (50, Alphanumeric) - Optional: State-assigned identifier
+        /// 4. LastName (30, Alpha) - Required: Student's last name
+        /// 5. FirstName (30, Alpha) - Required: Student's first name
+        /// 6. MiddleName (30, Alpha) - Optional: Student's middle name
+        /// 7. GenderCode (1, Alpha) - Required: M => Male, F => Female
+        /// 8. DateOfBirth (10, Alphanumeric) - Required: Format MM/DD/YYYY
+        /// 9. MedicaidNumber (50, Alphanumeric) - Optional: Student's Medicaid number
+        /// 10. ParentAuthorization (1, Alpha) - Optional: Y/N for billing authorization
+        /// 11. AddressLine1 (50, Alphanumeric) - Optional: Primary address
+        /// 12. AddressLine2 (50, Alphanumeric) - Optional: Secondary address
+        /// 13. City (18, Alpha) - Optional: City name
+        /// 14. State (2, Alpha) - Optional: State abbreviation
+        /// 15. ZipCode (15, Alphanumeric) - Optional: Postal code
+        /// 16. HomePhone (13, Alphanumeric) - Optional: Contact number
+        /// 
+        /// ServiceLog.txt Fields:
+        /// 1. ServiceLogId (50, Alphanumeric) - Required: SNAP's unique service identifier
+        /// 2. ProviderFirstName (50, Alphanumeric) - Required: Provider's first name
+        /// 3. ProviderLastName (50, Alphanumeric) - Required: Provider's last name
+        /// 4. ProviderId (20, Alphanumeric) - Optional: Provider's identifier
+        /// 5. School (100, Alphanumeric) - Required: Service location school
+        /// 6. StudentId (50, Alphanumeric) - Required: Links to Student.txt StudentId
+        /// 7. LogDate (10, Alphanumeric) - Required: Format MM/DD/YYYY
+        /// 8. EntryDescription (500, Alphanumeric) - Optional: Service description
+        /// 9. EntryComments (2000, Alphanumeric) - Optional: Additional notes
+        /// 10. TimeIn (10, Alphanumeric) - Required: Format HH:MM (e.g., 1:00 PM)
+        /// 11. TimeOut (10, Alphanumeric) - Required: Format HH:MM (e.g., 1:45 PM)
+        /// 12. DirectTime (10, Numeric) - Required: Session duration in minutes
+        /// 13. DiagnosisCode1 (50, Alphanumeric) - Optional: Primary ICD10 code
+        /// 14. DiagnosisCode2 (50, Alphanumeric) - Optional: Secondary ICD10 code
+        /// 15. PlaceOfServiceCode (2, Alphanumeric) - Optional: Service type identifier
+        /// 16. ProcedureCode (50, Alphanumeric) - Required: Service procedure code
+        /// 
+        /// Conversion Strategy:
+        /// 1. Parse Student.txt to build student records
+        /// 2. Parse ServiceLog.txt and link to students
+        /// 3. Map SNAP fields to encounter import format
+        /// 4. Generate CSV in template format
+        /// 5. Handle required field validation
+        /// 6. Maintain relationships between records
+        /// </remarks>
+        /// <param name="studentFileContent">The content of the Student.txt file as a byte array</param>
+        /// <param name="serviceFileContent">The content of the ServiceLog.txt file as a byte array</param>
+        /// <param name="studentFileName">The name of the student file to extract CustomerId</param>
+        /// <returns>A byte array containing the converted encounter import file</returns>
+        public async Task<byte[]> ConvertSnapFilesAsync(byte[] studentFileContent, byte[] serviceFileContent, string studentFileName)
+        {
+            try
+            {
+                // Extract district ID (CustomerId) from filename
+                // Format: CustomerId_TableName_DateCreated_TimeCreated.Extension
+                string districtId = "";
+                if (!string.IsNullOrEmpty(studentFileName))
+                {
+                    var parts = studentFileName.Split('_');
+                    if (parts.Length >= 1)
+                    {
+                        districtId = parts[0];
+                    }
+                }
+
+                if (string.IsNullOrEmpty(districtId))
+                {
+                    throw new ArgumentException("Could not extract district ID from filename. Expected format: CustomerId_TableName_DateCreated_TimeCreated.Extension");
+                }
+
+                // Dictionary to store student data for lookup when processing services
+                var studentData = new Dictionary<string, SnapStudent>();
+
+                // Parse Student.txt
+                using (var studentStream = new MemoryStream(studentFileContent))
+                using (var studentReader = new StreamReader(studentStream))
+                using (var studentCsv = new CsvReader(studentReader, new CsvHelper.Configuration.CsvConfiguration(CultureInfo.InvariantCulture)
+                {
+                    Delimiter = "|",
+                    HasHeaderRecord = true,
+                    TrimOptions = CsvHelper.Configuration.TrimOptions.Trim
+                }))
+                {
+                    // Read all student records
+                    var studentRecords = studentCsv.GetRecords<SnapStudent>().ToList();
+                    foreach (var student in studentRecords)
+                    {
+                        studentData[student.StudentId] = student;
+                    }
+                }
+
+                // List to store converted EncounterImportRow objects
+                var convertedRows = new List<EncounterImportRow>();
+
+                // Process ServiceLog.txt and convert to EncounterImportRow objects
+                using (var serviceStream = new MemoryStream(serviceFileContent))
+                using (var serviceReader = new StreamReader(serviceStream))
+                using (var serviceCsv = new CsvReader(serviceReader, new CsvHelper.Configuration.CsvConfiguration(CultureInfo.InvariantCulture)
+                {
+                    Delimiter = "|",
+                    HasHeaderRecord = true,
+                    TrimOptions = CsvHelper.Configuration.TrimOptions.Trim
+                }))
+                {
+                    var serviceRecords = serviceCsv.GetRecords<SnapServiceLog>().ToList();
+                    foreach (var service in serviceRecords)
+                    {
+                        // Get corresponding student data
+                        if (studentData.TryGetValue(service.StudentId, out var student))
+                        {
+                            // Create a new EncounterImportRow object
+                            var importRow = new EncounterImportRow
+                            {
+                                // Integration information
+                                ImportSource = "SNAP Integration",
+
+                                // District and School information
+                                DistrictId = "", // Will be looked up during import
+                                DistrictName = "", // Will be looked up during import
+                                DistrictCode = "",
+                                SchoolId = "", // Will be looked up during import
+                                SchoolName = service.School,
+
+                                // Provider information
+                                ProviderId = "", // Will be looked up during import
+                                ProviderNPI = "",
+                                ProviderFirstName = service.ProviderFirstName,
+                                ProviderLastName = service.ProviderLastName,
+
+                                // Student information
+                                StudentId = "", // Will be looked up during import
+                                StudentCode = student.StudentLocalId,
+                                StudentFirstName = student.FirstName,
+                                StudentMiddleName = student.MiddleName,
+                                StudentLastName = student.LastName,
+                                StudentDateOfBirth = student.DateOfBirth,
+                                StudentGrade = "", // Not provided in SNAP data
+                                StudentMedicaidNo = student.MedicaidNumber,
+                                StudentNotes = "",
+                                StudentAddressLine1 = student.AddressLine1,
+                                StudentAddressLine2 = student.AddressLine2,
+                                StudentCity = student.City,
+                                StudentState = student.State,
+                                StudentZip = student.ZipCode,
+                                StudentEnrollmentDate = "", // Not provided in SNAP data
+                                StudentTypeId = "", // Not provided in SNAP data
+                                StudentTypeName = "", // Not provided in SNAP data
+
+                                // Case Load information
+                                ServiceCodeId = "", // Will be determined during import
+                                ServiceCodeName = "", // Will be determined during import
+                                CaseLoadDiagnosisCode = service.DiagnosisCode1,
+                                IEPStartDate = "", // Not provided in SNAP data
+                                IEPEndDate = "", // Not provided in SNAP data
+
+                                // Prescription/Script information
+                                DoctorFirstName = "", // Not provided in SNAP data
+                                DoctorLastName = "", // Not provided in SNAP data
+                                DoctorNPI = "", // Not provided in SNAP data
+                                PrescriptionInitiationDate = "", // Not provided in SNAP data
+                                PrescriptionExpirationDate = "", // Not provided in SNAP data
+                                CaseLoadScriptDiagnosisCode = service.DiagnosisCode1,
+
+                                // Encounter data
+                                EncounterDate = service.LogDate,
+                                EncounterStartTime = service.TimeIn,
+                                EncounterEndTime = service.TimeOut,
+                                ServiceTypeId = "3", // Default to Treatment/Therapy
+                                EvaluationTypeId = "", // Not provided in SNAP data
+                                EncounterDiagnosisCode = service.DiagnosisCode1,
+                                IsGroup = "false", // Default to individual session
+                                AdditionalStudents = "0", // Default to no additional students
+
+                                // EncounterStudent data
+                                EncounterLocation = service.School,
+                                StudentStartTime = service.TimeIn,
+                                StudentEndTime = service.TimeOut,
+                                EncounterStudentDate = service.LogDate,
+                                EncounterStudentDiagnosisCode = service.DiagnosisCode1,
+                                CPTCode = service.ProcedureCode,
+                                TherapyCaseNotes = service.EntryDescription,
+                                SupervisorComments = service.EntryComments,
+                                IsTelehealth = "false" // Default to in-person
+                            };
+
+                            convertedRows.Add(importRow);
+                        }
+                    }
+                }
+
+                // Create output CSV in memory
+                using (var outputStream = new MemoryStream())
+                using (var writer = new StreamWriter(outputStream))
+                using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
+                {
+                    // Write all records with automatic header generation
+                    csv.WriteRecords(convertedRows);
+                    
+                    writer.Flush();
+                    return outputStream.ToArray();
+                }
+            }
+            catch (Exception ex)
+            {
+                throw new Exception($"Error converting SNAP files: {ex.Message}", ex);
+            }
+        }
+
+        /// <summary>
+        /// Converts MST service records into the encounter import format.
+        /// </summary>
+        /// <remarks>
+        /// File Format Specification:
+        /// - Data is provided in JSON format
+        /// - Each record contains complete student and service information
+        /// - JSON structure includes:
+        ///   - CPT codes (up to 3) with durations:
+        ///     - CPT1, CPT1Duration
+        ///     - CPT2, CPT2Duration
+        ///     - CPT3, CPT3Duration
+        ///   - District and location information:
+        ///     - District
+        ///     - Location
+        ///   - Provider details:
+        ///     - ProviderMSTKey
+        ///     - ProviderNPI
+        ///     - ProviderFirstName
+        ///     - ProviderLastName
+        ///     - ProviderTitle
+        ///   - Referral information:
+        ///     - ReferralDate
+        ///     - ReferralTherapistNPI
+        ///     - ReferralTherapistFirstName
+        ///     - ReferralTherapistLastName
+        ///   - Service details:
+        ///     - ServiceDate
+        ///     - ServiceType
+        ///     - SessionStart
+        ///     - SessionEnd
+        ///     - SessionMSTKey
+        ///   - Student information:
+        ///     - StudentDOB
+        ///     - StudentID
+        ///     - StudentMSTKey
+        ///     - StudentFirstName
+        ///     - StudentLastName
+        ///   - Supervisor information:
+        ///     - TherapistSuperMSTKey
+        ///     - TherapistSuperNPI
+        ///     - TherapistSuperFirstName
+        ///     - TherapistSuperLastName
+        ///   - Additional fields:
+        ///     - GroupNumber
+        ///     - ICD10
+        /// 
+        /// Conversion Strategy:
+        /// 1. Parse JSON data into MstService objects
+        /// 2. Map MST fields to encounter import format
+        /// 3. Generate CSV in template format
+        /// 4. Handle required field validation
+        /// </remarks>
+        /// <param name="jsonContent">The content of the JSON file as a byte array</param>
+        /// <returns>A byte array containing the converted encounter import file</returns>
+        public async Task<byte[]> ConvertMstFilesAsync(byte[] jsonContent)
+        {
+            try
+            {
+                // Parse JSON data
+                string jsonString = Encoding.UTF8.GetString(jsonContent);
+                
+                // Deserialize as Dictionary<string, MstService> to handle numbered keys
+                var mstServicesDict = JsonConvert.DeserializeObject<Dictionary<string, MstService>>(jsonString);
+
+                if (mstServicesDict == null || !mstServicesDict.Any())
+                {
+                    throw new ArgumentException("No valid MST service records found in the JSON data.");
+                }
+
+                // Extract the MstService objects from the dictionary values
+                var mstServices = mstServicesDict.Values.ToList();
+
+                // List to store converted EncounterImportRow objects
+                var convertedRows = new List<EncounterImportRow>();
+
+                // Process each MST service record and convert to EncounterImportRow objects
+                foreach (var service in mstServices)
+                {
+                    // Create a new EncounterImportRow object
+                    var importRow = new EncounterImportRow
+                    {
+                        // Integration information
+                        ImportSource = "MST Integration",
+
+                        // District and School information
+                        DistrictId = "", // Will be looked up during import
+                        DistrictName = service.District,
+                        DistrictCode = "",
+                        SchoolId = "", // Will be looked up during import
+                        SchoolName = service.Location,
+
+                        // Provider information
+                        ProviderId = "", // Will be looked up during import
+                        ProviderNPI = service.ProviderNpi,
+                        ProviderFirstName = service.ProviderFirstName,
+                        ProviderLastName = service.ProviderLastName,
+
+                        // Student information
+                        StudentId = "", // Will be looked up during import
+                        StudentCode = service.StudentId,
+                        StudentFirstName = service.StudentFirstName,
+                        StudentMiddleName = "", // Not provided in MST data
+                        StudentLastName = service.StudentLastName,
+                        StudentDateOfBirth = service.StudentDob,
+                        StudentGrade = "", // Not provided in MST data
+                        StudentMedicaidNo = "", // Not provided in MST data
+                        StudentNotes = "",
+                        StudentAddressLine1 = "", // Not provided in MST data
+                        StudentAddressLine2 = "", // Not provided in MST data
+                        StudentCity = "", // Not provided in MST data
+                        StudentState = "", // Not provided in MST data
+                        StudentZip = "", // Not provided in MST data
+                        StudentEnrollmentDate = "", // Not provided in MST data
+                        StudentTypeId = "", // Not provided in MST data
+                        StudentTypeName = "", // Not provided in MST data
+
+                        // Case Load information
+                        ServiceCodeId = "", // Will be determined during import
+                        ServiceCodeName = service.ServiceType,
+                        CaseLoadDiagnosisCode = service.Icd10,
+                        IEPStartDate = "", // Not provided in MST data
+                        IEPEndDate = "", // Not provided in MST data
+
+                        // Prescription/Script information
+                        DoctorFirstName = service.ReferralTherapistFirstName,
+                        DoctorLastName = service.ReferralTherapistLastName,
+                        DoctorNPI = service.ReferralTherapistNpi,
+                        PrescriptionInitiationDate = service.ReferralDate,
+                        PrescriptionExpirationDate = "", // Not provided in MST data
+                        CaseLoadScriptDiagnosisCode = service.Icd10,
+
+                        // Encounter data
+                        EncounterDate = service.ServiceDate,
+                        EncounterStartTime = service.SessionStart,
+                        EncounterEndTime = service.SessionEnd,
+                        ServiceTypeId = "3", // Default to Treatment/Therapy
+                        EvaluationTypeId = "", // Not provided in MST data
+                        EncounterDiagnosisCode = service.Icd10,
+                        IsGroup = service.GroupNumber == "1" ? "false" : "true", // Group if GroupNumber > 1
+                        AdditionalStudents = service.GroupNumber == "1" ? "0" : (int.Parse(service.GroupNumber) - 1).ToString(), // Additional students = GroupNumber - 1
+
+                        // EncounterStudent data
+                        EncounterLocation = service.Location,
+                        StudentStartTime = service.SessionStart,
+                        StudentEndTime = service.SessionEnd,
+                        EncounterStudentDate = service.ServiceDate,
+                        EncounterStudentDiagnosisCode = service.Icd10,
+                        CPTCode = service.Cpt1, // Use primary CPT code
+                        TherapyCaseNotes = "", // Not provided in MST data
+                        SupervisorComments = "", // Not provided in MST data
+                        IsTelehealth = "false" // Default to in-person
+                    };
+
+                    convertedRows.Add(importRow);
+                }
+
+                // Create output CSV in memory
+                using (var outputStream = new MemoryStream())
+                using (var writer = new StreamWriter(outputStream))
+                using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
+                {
+                    // Write all records with automatic header generation
+                    csv.WriteRecords(convertedRows);
+                    
+                    writer.Flush();
+                    return outputStream.ToArray();
+                }
+            }
+            catch (Exception ex)
+            {
+                throw new Exception($"Error converting MST files: {ex.Message}", ex);
+            }
+        }
+    }
+    
+
+    /// <summary>
+    /// Validation result specific to encounter imports
+    /// </summary>
+    public class EncounterImportRowValidationResult : DataImportRowValidationResult
+    {
+        public SchoolDistrict MatchingDistrict { get; set; }
+        public School MatchingSchool { get; set; }
+        public Provider MatchingProvider { get; set; }
+        public ProviderTitle MatchingProviderTitle { get; set; }
+        public Student MatchingStudent { get; set; }
+        public ProviderStudent MatchingProviderStudentRelationship { get; set; }
+        public CaseLoad MatchingCaseLoad { get; set; }
+        public CaseLoadScript MatchingCaseLoadScript { get; set; }
+        public Goal MatchingGoal { get; set; }
+        public Encounter Encounter { get; set; }
+        public EncounterStudent EncounterStudent { get; set; }
+        public CptCode EncounterStudentCptCode { get; set; }
+        
+        // Properties for tracking newly created records
+        public Address CreatedAddress { get; set; }
+        public Student CreatedStudent { get; set; }
+        public ProviderStudent CreatedProviderStudentRelationship { get; set; }
+        public CaseLoad CreatedCaseLoad { get; set; }
+        public CaseLoadScript CreatedCaseLoadScript { get; set; }
+        public CaseLoadScriptGoal CreatedCaseLoadScriptGoal { get; set; }
+
+        // Keep only the typed row reference
+        public EncounterImportRow OriginalTypedRow { get; set; }
+    }
+}
+
diff --git a/src/Service/DataImport/IDataImportService.cs b/src/Service/DataImport/IDataImportService.cs
new file mode 100644
index 000000000..9c635050c
--- /dev/null
+++ b/src/Service/DataImport/IDataImportService.cs
@@ -0,0 +1,109 @@
+using System.Collections.Generic;
+using System.Data.Entity;
+using System.Threading.Tasks;
+using CsvHelper.Configuration.Attributes;
+using Model.DataImport;
+
+namespace Service.DataImport
+{
+    public interface IDataImportService
+    {
+        /// <summary>
+        /// Gets the type of import this service handles
+        /// </summary>
+        string ImportType { get; }
+        
+        /// <summary>
+        /// Generates a CSV template for data imports
+        /// </summary>
+        /// <returns>Byte array containing the CSV template</returns>
+        byte[] GenerateTemplate();
+        
+        /// <summary>
+        /// Processes an import file and returns a result with validation information
+        /// </summary>
+        /// <param name="fileContent">The content of the file to process</param>
+        /// <param name="createMissingRecords">Whether to create missing records instead of reporting errors</param>
+        /// <param name="userId">The ID of the user performing the import</param>
+        /// <returns>A result containing the processed data and any errors</returns>
+        Task<ImportResult> ProcessImportFileAsync(byte[] fileContent, int userId, bool createMissingRecords = false, DbContextTransaction transaction = null);
+        
+        /// <summary>
+        /// Converts student files to service files
+        /// </summary>
+        /// <param name="studentFileContent">The content of the student file</param>
+        /// <param name="serviceFileContent">The content of the service file</param>
+        /// <param name="studentFileName">The name of the student file to extract CustomerId</param>
+        /// <returns>The converted service file content</returns>
+        Task<byte[]> ConvertSnapFilesAsync(byte[] studentFileContent, byte[] serviceFileContent, string studentFileName);
+        
+        /// <summary>
+        /// Converts MST service records into the encounter import format
+        /// </summary>
+        /// <param name="jsonContent">The content of the JSON file</param>
+        /// <returns>The converted encounter import file content</returns>
+        Task<byte[]> ConvertMstFilesAsync(byte[] jsonContent);
+    }
+    
+    /// <summary>
+    /// Base class for all import row validation results
+    /// </summary>
+    public class DataImportRowValidationResult
+    {
+        /// <summary>
+        /// Indicates whether the row passed validation
+        /// </summary>
+        public bool IsValid { get; set; }
+        
+        /// <summary>
+        /// The original row data from the import file
+        /// </summary>
+        public Dictionary<string, string> OriginalRow { get; set; }
+        
+        /// <summary>
+        /// List of validation errors found in the row
+        /// </summary>
+        public List<string> Errors { get; set; }
+    }
+    
+    /// <summary>
+    /// Result of an import operation
+    /// </summary>
+    public class ImportResult
+    {
+        /// <summary>
+        /// Indicates whether the import was successful overall
+        /// </summary>
+        public bool Success { get; set; }
+        
+        /// <summary>
+        /// Message describing the result of the import
+        /// </summary>
+        public string Message { get; set; }
+        
+        /// <summary>
+        /// Number of rows successfully processed
+        /// </summary>
+        public int SuccessCount { get; set; }
+        
+        /// <summary>
+        /// Number of rows with validation errors
+        /// </summary>
+        public int ErrorCount { get; set; }
+        
+        /// <summary>
+        /// Number of new records created during import
+        /// </summary>
+        public int CreatedRecordCount { get; set; }
+        
+        /// <summary>
+        /// Collection of rows that had validation errors
+        /// </summary>
+        public List<ImportRow> ErrorRows { get; set; }
+        
+        /// <summary>
+        /// Byte array containing the error file content
+        /// </summary>
+        public byte[] ErrorFileContent { get; set; }
+    }
+} 
diff --git a/src/Service/DataImport/SampleData/MST/example_mst_data.json b/src/Service/DataImport/SampleData/MST/example_mst_data.json
new file mode 100644
index 000000000..7edec1fdf
--- /dev/null
+++ b/src/Service/DataImport/SampleData/MST/example_mst_data.json
@@ -0,0 +1,110 @@
+{
+        "1" :
+        {
+                "CPT1" : "97116",
+                "CPT1Duration" : "20",
+                "CPT2" : "",
+                "CPT2Duration" : "",
+                "CPT3" : "",
+                "CPT3Duration" : "",
+                "District" : "Cleveland Metropolitan School District",
+                "GroupNumber" : "1",
+                "ICD10" : "F81.9",
+                "Location" : "School",
+                "ProviderMSTKey" : "518526AD-6EB9-40D9-8D90-20557813192C",
+                "ProviderNPI" : "1720645740",
+                "ProviderFirstName" : "Amanda",
+                "ProviderLastName" : "Klidas",
+                "ProviderTitle" : "Physical Therapy",
+                "ReferralDate" : "9/1/2024",
+                "ReferralTherapistNPI" : "1720645740",
+                "ReferralTherapistFirstName" : "Amanda",
+                "ReferralTherapistLastName" : "Klidas",
+                "ServiceDate" : "2/5/2025",
+                "ServiceType" : "Treatment/Therapy",
+                "SessionEnd" : "10:20 AM",
+                "SessionMSTKey" : "22F46054-738E-DD46-A36E-68609BA7A7D1",
+                "SessionStart" : "10:00 AM",
+                "StudentDOB" : "3/13/2014",
+                "StudentID" : "209064629",
+                "StudentMSTKey" : "8E0D41D0-E562-45A0-8568-F1A39AD97315",
+                "StudentNameFirst" : "Santana",
+                "StudentNameLast" : "Darden",
+                "TherapistSuperMSTKey" : "",
+                "TherapistSuperNPI" : "",
+                "TherapistSuperFirstName" : "",
+                "TherapistSuperLastName" : ""
+        },
+        "2" :
+        {
+                "CPT1" : "97110",
+                "CPT1Duration" : "30",
+                "CPT2" : "97530",
+                "CPT2Duration" : "15",
+                "CPT3" : "",
+                "CPT3Duration" : "",
+                "District" : "Cleveland Metropolitan School District",
+                "GroupNumber" : "2",
+                "ICD10" : "F84.0",
+                "Location" : "School",
+                "ProviderMSTKey" : "518526AD-6EB9-40D9-8D90-20557813192C",
+                "ProviderNPI" : "1720645740",
+                "ProviderFirstName" : "Amanda",
+                "ProviderLastName" : "Klidas",
+                "ProviderTitle" : "Physical Therapy",
+                "ReferralDate" : "9/1/2024",
+                "ReferralTherapistNPI" : "1720645740",
+                "ReferralTherapistFirstName" : "Amanda",
+                "ReferralTherapistLastName" : "Klidas",
+                "ServiceDate" : "2/5/2025",
+                "ServiceType" : "Treatment/Therapy",
+                "SessionEnd" : "11:30 AM",
+                "SessionMSTKey" : "33F46054-738E-DD46-A36E-68609BA7A7D2",
+                "SessionStart" : "10:45 AM",
+                "StudentDOB" : "5/22/2013",
+                "StudentID" : "209064630",
+                "StudentMSTKey" : "9E0D41D0-E562-45A0-8568-F1A39AD97316",
+                "StudentNameFirst" : "Marcus",
+                "StudentNameLast" : "Johnson",
+                "TherapistSuperMSTKey" : "",
+                "TherapistSuperNPI" : "",
+                "TherapistSuperFirstName" : "",
+                "TherapistSuperLastName" : ""
+        },
+        "3" :
+        {
+                "CPT1" : "97140",
+                "CPT1Duration" : "45",
+                "CPT2" : "",
+                "CPT2Duration" : "",
+                "CPT3" : "",
+                "CPT3Duration" : "",
+                "District" : "Cleveland Metropolitan School District",
+                "GroupNumber" : "1",
+                "ICD10" : "F81.0",
+                "Location" : "School",
+                "ProviderMSTKey" : "628526AD-6EB9-40D9-8D90-20557813192D",
+                "ProviderNPI" : "1820645741",
+                "ProviderFirstName" : "Robert",
+                "ProviderLastName" : "Wilson",
+                "ProviderTitle" : "Occupational Therapy",
+                "ReferralDate" : "9/1/2024",
+                "ReferralTherapistNPI" : "1820645741",
+                "ReferralTherapistFirstName" : "Robert",
+                "ReferralTherapistLastName" : "Wilson",
+                "ServiceDate" : "2/6/2025",
+                "ServiceType" : "Treatment/Therapy",
+                "SessionEnd" : "2:15 PM",
+                "SessionMSTKey" : "44F46054-738E-DD46-A36E-68609BA7A7D3",
+                "SessionStart" : "1:30 PM",
+                "StudentDOB" : "8/10/2014",
+                "StudentID" : "209064631",
+                "StudentMSTKey" : "AE0D41D0-E562-45A0-8568-F1A39AD97317",
+                "StudentNameFirst" : "Emily",
+                "StudentNameLast" : "Davis",
+                "TherapistSuperMSTKey" : "518526AD-6EB9-40D9-8D90-20557813192C",
+                "TherapistSuperNPI" : "1720645740",
+                "TherapistSuperFirstName" : "Amanda",
+                "TherapistSuperLastName" : "Klidas"
+        }
+} 
\ No newline at end of file
diff --git a/src/Service/DataImport/SampleData/SNAP/12345_ServiceLog_20240315_143022.txt b/src/Service/DataImport/SampleData/SNAP/12345_ServiceLog_20240315_143022.txt
new file mode 100644
index 000000000..d42ff1b57
--- /dev/null
+++ b/src/Service/DataImport/SampleData/SNAP/12345_ServiceLog_20240315_143022.txt
@@ -0,0 +1,5 @@
+ServiceLogId|ProviderFirstName|ProviderLastName|ProviderId|School|StudentId|LogDate|EntryDescription|EntryComments|TimeIn|TimeOut|DirectTime|DiagnosisCode1|DiagnosisCode2|ServiceTypeCode|ProcedureCode
+SL001|Jane|Smith|PROV001|Sample Elementary|STU001|05/15/2023|Initial assessment session|Student showed good progress|09:00|10:00|60|F84.0|F81.2|03|99213
+SL002|Jane|Smith|PROV001|Sample Elementary|STU002|05/15/2023|Group therapy session|Student participated well|09:00|10:00|60|F84.0||03|99213
+SL003|Jane|Smith|PROV001|Sample Elementary|STU003|05/16/2023|Follow-up session|Continued progress noted|10:30|11:30|60|F84.0||03|99213
+SL004|Jane|Smith|PROV001|Sample Elementary|STU001|05/17/2023|Progress evaluation|Meeting IEP goals|13:00|14:00|60|F84.0||03|99213 
\ No newline at end of file
diff --git a/src/Service/DataImport/SampleData/SNAP/12345_Student_20240315_143022.txt b/src/Service/DataImport/SampleData/SNAP/12345_Student_20240315_143022.txt
new file mode 100644
index 000000000..32feab083
--- /dev/null
+++ b/src/Service/DataImport/SampleData/SNAP/12345_Student_20240315_143022.txt
@@ -0,0 +1,4 @@
+StudentId|StudentLocalId|StudentStateId|LastName|FirstName|MiddleName|GenderCode|DateOfBirth|MedicaidNumber|ParentAuthorization|AddressLine1|AddressLine2|City|State|ZipCode|HomePhone
+STU001|LOC001|STATE001|Smith|John|A|M|01/15/2010|123456789012|Y|123 Main St|Apt 4B|Anytown|OH|12345|555-123-4567
+STU002|LOC002|STATE002|Johnson|Sarah||F|02/20/2010|234567890123|Y|456 Oak St||Somewhere|OH|54321|555-234-5678
+STU003|LOC003|STATE003|Williams|Michael|B|M|03/10/2010|345678901234|Y|789 Pine St|Unit 7|Elsewhere|OH|98765|555-345-6789 
\ No newline at end of file
diff --git a/src/Service/Service.csproj b/src/Service/Service.csproj
index ac8287c91..14f0ea3a9 100644
--- a/src/Service/Service.csproj
+++ b/src/Service/Service.csproj
@@ -10,6 +10,7 @@
     <PackageReference Include="Autofac" version="8.1.1" />
     <PackageReference Include="Breckenridge.Service.Base" Version="6.1.1" />
     <PackageReference Include="ClosedXML" Version="0.95.4" />
+    <PackageReference Include="CsvHelper" Version="33.0.1" />
     <PackageReference Include="ExcelDataReader" Version="3.6.0" />
     <PackageReference Include="ExcelDataReader.DataSet" Version="3.6.0" />
     <PackageReference Include="FastMember" Version="1.5.0" />
diff --git a/src/app/admin-portal/admin-routing.module.ts b/src/app/admin-portal/admin-routing.module.ts
index 7ad796437..2710ca13c 100644
--- a/src/app/admin-portal/admin-routing.module.ts
+++ b/src/app/admin-portal/admin-routing.module.ts
@@ -43,6 +43,7 @@ import { summaryReportRoutes } from './summary-report/summary-report-route.libra
 import { userRoleRoutes } from './user-roles/user-role-routes.library';
 import { adminUserRoutes } from './users/admin-user-routes.library';
 import { voucherRoutes } from './vouchers/voucher-routes.library';
+import { dataImportRoutes } from './data-import/data-import-routes.library';
 
 const homeRoleGuard: IRoleGuarded = {
     claimType: ClaimTypes.Users,
@@ -104,6 +105,7 @@ const adminRoutes: Routes = [
             ...auditsRoutes,
             ...annualEntryRoutes,
             ...serviceOutcomeRoutes,
+            ...dataImportRoutes,
             { path: '**', component: AdminNotFoundComponent, data: homeRoleGuard, resolve: { path: PathNotFoundResolveService } },
         ],
         component: AdminComponent,
diff --git a/src/app/admin-portal/admin.module.ts b/src/app/admin-portal/admin.module.ts
index 8d6ef481e..95980a475 100644
--- a/src/app/admin-portal/admin.module.ts
+++ b/src/app/admin-portal/admin.module.ts
@@ -42,6 +42,7 @@ import { UserModule } from './users/user.module';
 import { VoucherModule } from './vouchers/voucher.module';
 import { CaseLoadModule } from '@provider/case-load/case-load.module';
 import { NursingGoalResultModule } from './nurse-progress-quick-text/nursing-goal-result.module';
+import { DataImportModule } from './data-import/data-import.module';
 
 @NgModule({
     declarations: [AdminComponent, AppSettingsComponent, AdminNotFoundComponent],
@@ -85,7 +86,8 @@ import { NursingGoalResultModule } from './nurse-progress-quick-text/nursing-goa
         AnnualEntriesModule,
         AuthModule,
         CaseLoadModule,
-        NursingGoalResultModule
+        NursingGoalResultModule,
+        DataImportModule
     ],
     providers: [AdminPortalGuard],
 })
diff --git a/src/app/admin-portal/data-import/components/data-import/data-import.component.html b/src/app/admin-portal/data-import/components/data-import/data-import.component.html
new file mode 100644
index 000000000..0f0b8bf16
--- /dev/null
+++ b/src/app/admin-portal/data-import/components/data-import/data-import.component.html
@@ -0,0 +1,137 @@
+<div class="import-container">
+    <header class="import-header">
+        <h1>Encounter Data Import</h1>
+        <p>Upload a CSV file containing encounter data to import into the system</p>
+    </header>
+
+    <main class="import-content">
+        <section class="import-section template-section">
+            <div class="section-card">
+                <h2>Get Started</h2>
+                <p>Download a CSV template with the required columns for importing encounter data.</p>
+                <button 
+                    class="btn btn-primary"
+                    (click)="downloadTemplate()" 
+                    [disabled]="isDownloading">
+                    <i class="fa fa-download"></i>
+                    <span *ngIf="!isDownloading">Download Template</span>
+                    <span *ngIf="isDownloading">Downloading...</span>
+                </button>
+            </div>
+        </section>
+
+        <section class="import-section convert-section">
+            <div class="section-card">
+                <h2>Convert Data</h2>
+                <p>Convert integration partner data files into our import format.</p>
+                
+                <div class="select-wrapper">
+                    <select 
+                        [(ngModel)]="selectedPartner" 
+                        (change)="onPartnerChange()"
+                        class="partner-select">
+                        <option value="">Select Integration Partner</option>
+                        <option value="SNAP">SNAP</option>
+                        <option value="MST">MST</option>
+                    </select>
+                </div>
+
+                <ng-container *ngIf="selectedPartner === 'SNAP'">
+                    <div class="file-input-wrapper">
+                        <p class="file-label">Student Data File:</p>
+                        <input
+                            type="file"
+                            accept=".txt"
+                            (change)="onSnapFileSelected($event, 'students')"
+                            class="file-input"
+                        />
+                    </div>
+
+                    <div class="file-input-wrapper">
+                        <p class="file-label">Service Data File:</p>
+                        <input
+                            type="file"
+                            accept=".txt"
+                            (change)="onSnapFileSelected($event, 'services')"
+                            class="file-input"
+                        />
+                    </div>
+
+                    <button 
+                        class="btn btn-primary"
+                        (click)="convertFiles()"
+                        [disabled]="!canConvert">
+                        <i class="fa fa-exchange"></i>
+                        <span *ngIf="!isConverting">Convert Files</span>
+                        <span *ngIf="isConverting">Converting...</span>
+                    </button>
+                </ng-container>
+
+                <ng-container *ngIf="selectedPartner === 'MST'">
+                    <div class="file-input-wrapper">
+                        <p class="file-label">MST Service Data File:</p>
+                        <input
+                            type="file"
+                            accept=".json"
+                            (change)="onMstFileSelected($event)"
+                            class="file-input"
+                        />
+                    </div>
+
+                    <button 
+                        class="btn btn-primary"
+                        (click)="convertFiles()"
+                        [disabled]="!canConvert">
+                        <i class="fa fa-exchange"></i>
+                        <span *ngIf="!isConverting">Convert Files</span>
+                        <span *ngIf="isConverting">Converting...</span>
+                    </button>
+                </ng-container>
+            </div>
+        </section>
+
+        <section class="import-section upload-section">
+            <div class="section-card">
+                <h2>Import Data</h2>
+                <p>Select a CSV file to import your encounter data.</p>
+                
+                <div class="file-input-wrapper">
+                    <input
+                        type="file"
+                        accept=".csv"
+                        (change)="onFileSelected($event)"
+                        #fileInput
+                        class="file-input"
+                    />
+                </div>
+
+                <div class="checkbox-wrapper">
+                    <input 
+                        type="checkbox" 
+                        id="createMissingStudents" 
+                        [(ngModel)]="createMissingStudentRecords">
+                    <label for="createMissingStudents">
+                        Create missing student records
+                    </label>
+                </div>
+
+                <button 
+                    class="btn btn-primary"
+                    (click)="uploadFile()"
+                    [disabled]="!selectedFile || isUploading">
+                    <i class="fa fa-cloud-upload"></i>
+                    <span *ngIf="!isUploading">Upload</span>
+                    <span *ngIf="isUploading">Uploading...</span>
+                </button>
+
+                <div *ngIf="errorMessage" class="message error-message">
+                    {{ errorMessage }}
+                </div>
+
+                <div *ngIf="successMessage" class="message success-message">
+                    {{ successMessage }}
+                </div>
+            </div>
+        </section>
+    </main>
+</div> 
\ No newline at end of file
diff --git a/src/app/admin-portal/data-import/components/data-import/data-import.component.scss b/src/app/admin-portal/data-import/components/data-import/data-import.component.scss
new file mode 100644
index 000000000..a380db381
--- /dev/null
+++ b/src/app/admin-portal/data-import/components/data-import/data-import.component.scss
@@ -0,0 +1,274 @@
+// Variables
+$primary-color: #0078d4;
+$error-color: #f44336;
+$success-color: #4CAF50;
+$text-color: #333;
+$border-color: #e0e0e0;
+$background-color: #f5f5f5;
+$card-background: #ffffff;
+$spacing-unit: 1rem;
+
+// Mixins
+@mixin card {
+    background: $card-background;
+    border-radius: 8px;
+    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.08);
+    padding: $spacing-unit * 2;
+}
+
+@mixin button {
+    padding: 0.5rem 1.25rem;
+    border-radius: 4px;
+    border: 1px solid transparent;
+    font-size: 1rem;
+    font-weight: 500;
+    cursor: pointer;
+    transition: all 0.2s ease;
+    display: inline-flex;
+    align-items: center;
+    gap: 0.5rem;
+    min-width: 140px;
+    justify-content: center;
+
+    &:disabled {
+        opacity: 0.6;
+        cursor: not-allowed;
+    }
+}
+
+// Styles
+.import-container {
+    padding: 2rem;
+    max-width: 1200px;
+    margin: 0 auto;
+
+    .import-header {
+        margin-bottom: 2rem;
+        
+        h1 {
+            font-size: 2rem;
+            font-weight: 500;
+            margin-bottom: 0.5rem;
+            color: #2c3e50;
+        }
+
+        p {
+            font-size: 1.1rem;
+            color: #666;
+            margin: 0;
+        }
+    }
+
+    .import-content {
+        display: grid;
+        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
+        gap: 2rem;
+    }
+
+    .section-card {
+        background: #fff;
+        border-radius: 8px;
+        padding: 2rem;
+        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
+
+        h2 {
+            font-size: 1.5rem;
+            font-weight: 500;
+            margin-bottom: 1rem;
+            color: #2c3e50;
+        }
+
+        p {
+            font-size: 1rem;
+            color: #666;
+            margin-bottom: 1.5rem;
+            line-height: 1.5;
+        }
+    }
+
+    .btn {
+        padding: 0.75rem 1.5rem;
+        font-size: 1rem;
+        font-weight: 500;
+        border-radius: 6px;
+        transition: all 0.2s ease;
+        display: inline-flex;
+        align-items: center;
+        justify-content: center;
+        min-width: 180px;
+        
+        &.btn-primary {
+            background: #3498db;
+            border: none;
+            color: white;
+            
+            &:hover:not([disabled]) {
+                background: #2980b9;
+                transform: translateY(-1px);
+            }
+            
+            &:disabled {
+                background: #bdc3c7;
+                cursor: not-allowed;
+            }
+        }
+
+        i {
+            margin-right: 0.5rem;
+        }
+    }
+
+    .file-input-wrapper {
+        margin-bottom: 1.5rem;
+
+        .file-label {
+            font-size: 1rem;
+            color: #2c3e50;
+            margin-bottom: 0.5rem;
+        }
+
+        .file-input {
+            width: 100%;
+            padding: 0.5rem;
+            border: 2px dashed #bdc3c7;
+            border-radius: 6px;
+            background: #f9f9f9;
+            cursor: pointer;
+            transition: border-color 0.2s ease;
+
+            &:hover {
+                border-color: #3498db;
+            }
+        }
+    }
+
+    .select-wrapper {
+        margin-bottom: 1.5rem;
+
+        select {
+            width: 100%;
+            padding: 0.75rem;
+            font-size: 1rem;
+            border: 1px solid #ddd;
+            border-radius: 6px;
+            background: #fff;
+            color: #2c3e50;
+            cursor: pointer;
+            transition: border-color 0.2s ease;
+
+            &:hover {
+                border-color: #3498db;
+            }
+
+            &:focus {
+                outline: none;
+                border-color: #3498db;
+                box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
+            }
+        }
+    }
+
+    .success-message {
+        padding: 1rem;
+        background: #dff0d8;
+        border: 1px solid #d6e9c6;
+        border-radius: 6px;
+        color: #3c763d;
+        margin-top: 1rem;
+        font-size: 1rem;
+    }
+
+    .error-message {
+        padding: 1rem;
+        background: #f2dede;
+        border: 1px solid #ebccd1;
+        border-radius: 6px;
+        color: #a94442;
+        margin-top: 1rem;
+        font-size: 1rem;
+    }
+}
+
+.import-section {
+    .section-card {
+        @include card;
+        height: 100%;
+        
+        h2 {
+            font-size: 1.25rem;
+            margin-bottom: $spacing-unit * 1.5;
+            color: $text-color;
+            font-weight: 500;
+        }
+        
+        p {
+            color: lighten($text-color, 20%);
+            margin-bottom: $spacing-unit * 1.5;
+            line-height: 1.5;
+        }
+    }
+}
+
+.button {
+    @include button;
+    
+    &.primary-button {
+        background-color: $primary-color;
+        color: white;
+        
+        &:hover:not(:disabled) {
+            background-color: darken($primary-color, 8%);
+            transform: translateY(-1px);
+        }
+
+        &:active:not(:disabled) {
+            transform: translateY(0);
+        }
+    }
+    
+    i {
+        font-size: 1rem;
+    }
+}
+
+.checkbox-wrapper {
+    margin: $spacing-unit * 1.5 0;
+    display: flex;
+    align-items: flex-start;
+    gap: 0.75rem;
+    padding: 0.5rem 0;
+    
+    input[type="checkbox"] {
+        width: 16px;
+        height: 16px;
+        cursor: pointer;
+        accent-color: $primary-color;
+        margin-top: 3px;
+    }
+    
+    label {
+        cursor: pointer;
+        color: $text-color;
+        user-select: none;
+        line-height: 1.4;
+    }
+}
+
+.message {
+    margin-top: $spacing-unit * 1.5;
+    padding: $spacing-unit;
+    border-radius: 4px;
+    font-size: 0.95rem;
+    
+    &.error-message {
+        background-color: rgba($error-color, 0.08);
+        color: darken($error-color, 5%);
+        border: 1px solid rgba($error-color, 0.15);
+    }
+    
+    &.success-message {
+        background-color: rgba($success-color, 0.08);
+        color: darken($success-color, 5%);
+        border: 1px solid rgba($success-color, 0.15);
+    }
+} 
\ No newline at end of file
diff --git a/src/app/admin-portal/data-import/components/data-import/data-import.component.ts b/src/app/admin-portal/data-import/components/data-import/data-import.component.ts
new file mode 100644
index 000000000..48778a224
--- /dev/null
+++ b/src/app/admin-portal/data-import/components/data-import/data-import.component.ts
@@ -0,0 +1,203 @@
+import { Component, ViewChild, ElementRef } from '@angular/core';
+import { DataImportService } from '../../services/data-import.service';
+import { saveAs } from 'file-saver';
+
+@Component({
+    selector: 'app-data-import',
+    templateUrl: './data-import.component.html',
+    styleUrls: ['./data-import.component.scss']
+})
+export class DataImportComponent {
+    @ViewChild('fileInput') fileInput!: ElementRef;
+    isDownloading = false;
+    isUploading = false;
+    isConverting = false;
+    selectedFile: File | null = null;
+    errorMessage: string | null = null;
+    successMessage: string | null = null;
+    createMissingStudentRecords = false;
+
+    // New properties for conversion
+    selectedPartner = '';
+    snapStudentFile: File | null = null;
+    snapServiceFile: File | null = null;
+    mstServiceFile: File | null = null;
+    
+    get canConvert(): boolean {
+        if (this.selectedPartner === 'SNAP') {
+            return !!(this.snapStudentFile && this.snapServiceFile);
+        } else if (this.selectedPartner === 'MST') {
+            return !!this.mstServiceFile;
+        }
+        return false;
+    }
+    
+    constructor(private dataImportService: DataImportService) {}
+    
+    downloadTemplate(): void {
+        this.isDownloading = true;
+        this.errorMessage = null;
+        
+        this.dataImportService.downloadEncounterTemplate().subscribe({
+            next: (response) => {
+                const blob = new Blob([response], { type: 'text/csv' });
+                saveAs(blob, 'encounter_import_template.csv');
+                this.isDownloading = false;
+            },
+            error: (error) => {
+                console.error('Error downloading template:', error);
+                this.isDownloading = false;
+                this.errorMessage = 'Failed to download template. Please try again later.';
+                
+                if (error.status === 401 || error.status === 403) {
+                    this.errorMessage = 'You do not have permission to download this template.';
+                } else if (error.status === 404) {
+                    this.errorMessage = 'Template not found.';
+                } else if (error.status === 500) {
+                    this.errorMessage = 'Server error occurred. Please contact support.';
+                }
+            }
+        });
+    }
+
+    onFileSelected(event: Event): void {
+        const input = event.target as HTMLInputElement;
+        if (input.files && input.files[0]) {
+            this.selectedFile = input.files[0];
+            this.errorMessage = null;
+            this.successMessage = null;
+        }
+    }
+
+    uploadFile(): void {
+        if (!this.selectedFile) {
+            this.errorMessage = 'Please select a file to upload';
+            return;
+        }
+
+        this.isUploading = true;
+        this.errorMessage = null;
+        this.successMessage = null;
+
+        this.dataImportService.importEncounters(this.selectedFile, this.createMissingStudentRecords).subscribe({
+            next: (response: Blob) => {
+                this.isUploading = false;
+                
+                // Check if the response is an error file (CSV)
+                if (response.type === 'text/csv') {
+                    const blob = new Blob([response], { type: 'text/csv' });
+                    const fileName = `${this.selectedFile?.name.replace('.csv', '')}_errors_${new Date().toISOString().slice(0,19).replace(/[:]/g, '')}.csv`;
+                    saveAs(blob, fileName);
+                    this.errorMessage = 'Import completed with errors. Please check the error file.';
+                } else {
+                    // Handle success response
+                    this.successMessage = 'File imported successfully!';
+                }
+                this.resetFileInput();
+            },
+            error: (error) => {
+                this.isUploading = false;
+                this.errorMessage = 'Error uploading file. Please try again.';
+                
+                if (error.status === 400) {
+                    this.errorMessage = 'Invalid file format. Only CSV files are allowed.';
+                } else if (error.status === 401 || error.status === 403) {
+                    this.errorMessage = 'You do not have permission to upload files.';
+                } else if (error.status === 500) {
+                    this.errorMessage = 'Server error occurred. Please contact support.';
+                }
+            }
+        });
+    }
+
+    resetFileInput(): void {
+        this.selectedFile = null;
+        if (this.fileInput) {
+            this.fileInput.nativeElement.value = '';
+        }
+    }
+
+    onPartnerChange(): void {
+        // Reset files when partner changes
+        this.snapStudentFile = null;
+        this.snapServiceFile = null;
+        this.mstServiceFile = null;
+        this.errorMessage = null;
+        this.successMessage = null;
+    }
+
+    onSnapFileSelected(event: Event, fileType: 'students' | 'services'): void {
+        const input = event.target as HTMLInputElement;
+        if (input.files && input.files[0]) {
+            if (fileType === 'students') {
+                this.snapStudentFile = input.files[0];
+            } else {
+                this.snapServiceFile = input.files[0];
+            }
+            this.errorMessage = null;
+            this.successMessage = null;
+        }
+    }
+
+    onMstFileSelected(event: Event): void {
+        const input = event.target as HTMLInputElement;
+        if (input.files && input.files[0]) {
+            this.mstServiceFile = input.files[0];
+            this.errorMessage = null;
+            this.successMessage = null;
+        }
+    }
+
+    convertFiles(): void {
+        if (!this.canConvert) {
+            this.errorMessage = 'Please select all required files before converting';
+            return;
+        }
+
+        this.isConverting = true;
+        this.errorMessage = null;
+        this.successMessage = null;
+
+        if (this.selectedPartner === 'SNAP') {
+            this.dataImportService.convertSnapFiles(this.snapStudentFile, this.snapServiceFile).subscribe({
+                next: (response: ArrayBuffer) => {
+                    this.isConverting = false;
+                    // Handle successful conversion - maybe auto-download the converted file
+                    const blob = new Blob([response], { type: 'text/csv' });
+                    saveAs(blob, 'converted_encounters.csv');
+                    this.successMessage = 'Files converted successfully!';
+                },
+                error: (error) => {
+                    this.isConverting = false;
+                    this.errorMessage = 'Error converting files. Please try again.';
+                    
+                    if (error.status === 400) {
+                        this.errorMessage = 'Invalid file format. Please check your files and try again.';
+                    } else if (error.status === 500) {
+                        this.errorMessage = 'Server error occurred. Please contact support.';
+                    }
+                }
+            });
+        } else if (this.selectedPartner === 'MST') {
+            this.dataImportService.convertMstFiles(this.mstServiceFile).subscribe({
+                next: (response: ArrayBuffer) => {
+                    this.isConverting = false;
+                    // Handle successful conversion - maybe auto-download the converted file
+                    const blob = new Blob([response], { type: 'text/csv' });
+                    saveAs(blob, 'converted_encounters.csv');
+                    this.successMessage = 'Files converted successfully!';
+                },
+                error: (error) => {
+                    this.isConverting = false;
+                    this.errorMessage = 'Error converting files. Please try again.';
+                    
+                    if (error.status === 400) {
+                        this.errorMessage = 'Invalid file format. Please check your files and try again.';
+                    } else if (error.status === 500) {
+                        this.errorMessage = 'Server error occurred. Please contact support.';
+                    }
+                }
+            });
+        }
+    }
+} 
\ No newline at end of file
diff --git a/src/app/admin-portal/data-import/data-import-routes.library.ts b/src/app/admin-portal/data-import/data-import-routes.library.ts
new file mode 100644
index 000000000..0e5d889dd
--- /dev/null
+++ b/src/app/admin-portal/data-import/data-import-routes.library.ts
@@ -0,0 +1,23 @@
+import { Data, Routes } from '@angular/router';
+import { AuthGuard, ClaimValues } from '@mt-ng2/auth-module';
+import { ClaimTypes } from '@model/ClaimTypes';
+import { DataImportComponent } from './components/data-import/data-import.component';
+
+const dataImportRoleGuard: Data = {
+    claimType: ClaimTypes.Encounters, // Using Encounters claim type since we're importing encounters
+    claimValues: [ClaimValues.ReadOnly, ClaimValues.FullAccess],
+    title: 'Encounter Data Import',
+};
+
+export const dataImportPaths = {
+    dataImport: 'data-import',
+};
+
+export const dataImportRoutes: Routes = [
+    {
+        canActivate: [AuthGuard],
+        component: DataImportComponent,
+        data: dataImportRoleGuard,
+        path: dataImportPaths.dataImport,
+    },
+]; 
\ No newline at end of file
diff --git a/src/app/admin-portal/data-import/data-import.module.ts b/src/app/admin-portal/data-import/data-import.module.ts
new file mode 100644
index 000000000..301d5b784
--- /dev/null
+++ b/src/app/admin-portal/data-import/data-import.module.ts
@@ -0,0 +1,27 @@
+import { NgModule } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { RouterModule } from '@angular/router';
+import { FormsModule, ReactiveFormsModule } from '@angular/forms';
+import { SharedModule } from '@common/shared.module';
+import { HttpClientModule } from '@angular/common/http';
+
+import { DataImportComponent } from './components/data-import/data-import.component';
+import { DataImportService } from './services/data-import.service';
+
+@NgModule({
+    declarations: [
+        DataImportComponent
+    ],
+    imports: [
+        CommonModule,
+        RouterModule,
+        FormsModule,
+        ReactiveFormsModule,
+        SharedModule,
+        HttpClientModule
+    ],
+    providers: [
+        DataImportService
+    ]
+})
+export class DataImportModule { } 
\ No newline at end of file
diff --git a/src/app/admin-portal/data-import/services/data-import.service.ts b/src/app/admin-portal/data-import/services/data-import.service.ts
new file mode 100644
index 000000000..b255231ba
--- /dev/null
+++ b/src/app/admin-portal/data-import/services/data-import.service.ts
@@ -0,0 +1,66 @@
+import { Injectable } from '@angular/core';
+import { HttpClient } from '@angular/common/http';
+import { Observable, throwError } from 'rxjs';
+import { catchError } from 'rxjs/operators';
+
+@Injectable({
+    providedIn: 'root'
+})
+export class DataImportService {
+    constructor(private http: HttpClient) {}
+
+    /**
+     * Downloads a CSV template for encounter imports
+     * Calls the backend API to get the template
+     */
+    downloadEncounterTemplate(): Observable<ArrayBuffer> {
+        return this.http.get(`/data-import/encounters/template`, {
+            responseType: 'arraybuffer'
+        }).pipe(catchError(err => throwError(() => err)));
+    }
+
+    /**
+     * Uploads and processes a CSV file for encounter imports
+     * @param file The CSV file to upload
+     * @param createMissingStudentRecords Whether to create missing student records
+     * @returns Observable of the response (either error file or success message)
+     */
+    importEncounters(file: File, createMissingStudentRecords = false): Observable<Blob> {
+        const formData = new FormData();
+        formData.append('file', file);
+        
+        return this.http.post(`/data-import/encounters/import?createMissingStudentRecords=${String(createMissingStudentRecords)}`, formData, {
+            responseType: 'blob'
+        }).pipe(catchError<Blob, Observable<Blob>>(err => throwError(() => err)));
+    }
+
+    /**
+     * Converts SNAP files to our import format
+     * @param studentFile The CSV file containing student data
+     * @param serviceFile The CSV file containing service data
+     * @returns Observable of the converted file content
+     */
+    convertSnapFiles(studentFile: File, serviceFile: File): Observable<ArrayBuffer> {
+        const formData = new FormData();
+        formData.append('studentFile', studentFile);
+        formData.append('serviceFile', serviceFile);
+        
+        return this.http.post('/data-import/convert?partner=SNAP', formData, {
+            responseType: 'arraybuffer'
+        }).pipe(catchError(err => throwError(() => err)));
+    }
+
+    /**
+     * Converts MST files to our import format
+     * @param serviceFile The JSON file containing service data
+     * @returns Observable of the converted file content
+     */
+    convertMstFiles(serviceFile: File): Observable<ArrayBuffer> {
+        const formData = new FormData();
+        formData.append('serviceFile', serviceFile);
+        
+        return this.http.post('/data-import/convert?partner=MST', formData, {
+            responseType: 'arraybuffer'
+        }).pipe(catchError(err => throwError(() => err)));
+    }
+} 
\ No newline at end of file
diff --git a/src/app/admin-portal/nav/admin-nav-menu.config.ts b/src/app/admin-portal/nav/admin-nav-menu.config.ts
index 23bde86d0..93b99882e 100644
--- a/src/app/admin-portal/nav/admin-nav-menu.config.ts
+++ b/src/app/admin-portal/nav/admin-nav-menu.config.ts
@@ -1,5 +1,3 @@
-
-
 import { ClaimTypes } from '@model/ClaimTypes';
 import { ClaimValues } from '@mt-ng2/auth-module';
 import { KeyboardKeys } from '@mt-ng2/keyboard-shortcuts-module';
@@ -427,6 +425,22 @@ export const adminNavMenu: (NavSidebarRowItem | NavSidebarParentRowItem)[] = [
         expanded: false,
         icon: 'fa fa-fw fa-book',
     }),
+    new NavSidebarParentRowItem({
+        children: [
+            new NavSidebarRowItem({
+                claimType: ClaimTypes.Encounters,
+                claimValues: [ClaimValues.ReadOnly, ClaimValues.FullAccess],
+                content: 'Encounters',
+                icon: 'fa fa-fw fa-file-text',
+                link: '/admin/data-import',
+            }),
+            // You can add more import types here in the future
+        ],
+        claimType: ClaimTypes.Encounters,
+        content: 'Data Import',
+        expanded: false,
+        icon: 'fa fa-fw fa-upload',
+    }),
     new NavSidebarRowItem({
         content: 'Sign Out',
         icon: 'fa fa-fw fa-sign-out',
